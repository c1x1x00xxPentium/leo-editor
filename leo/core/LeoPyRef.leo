<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons &amp; commands</vh>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20201018062305.1"><vh>@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018063747.1"><vh>get_content</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
</v>
<v t="ekr.20210113054702.1"><vh>@command pwd</vh></v>
<v t="ekr.20201013034659.1"><vh>Unused buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
</v>
<v t="ekr.20201013034742.1"><vh>Unused buttons re plugins</vh>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20201013034742.14"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20201013034742.15"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20201013034742.25"><vh>@@button test-jup-export</vh></v>
<v t="ekr.20201013034742.26"><vh>@@button test-jup-import</vh></v>
</v>
</v>
<v t="ekr.20210110092457.1"><vh>leojs buttons</vh>
<v t="ekr.20210110092457.5"><vh>@@@button cov @key=ctrl-6</vh></v>
<v t="ekr.20210110092457.6"><vh>@@@button moz @key=ctrl-7</vh></v>
<v t="ekr.20210110092457.7"><vh>@@@button unit</vh></v>
</v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 90</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.1"><vh>@data:@auto leo_cloud.py</vh>
<v t="ekr.20210128141640.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.3"><vh>@data:@auto leo_cloud_server.py</vh>
<v t="ekr.20201012142922.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20201222095250.1"><vh>script: check for duplicate settings in theme files</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20210309083845.1"><vh>script: check-files</vh></v>
<v t="ekr.20210118013157.1"><vh>script: convert-LeoFind</vh>
<v t="ekr.20210118024739.1"><vh>convert</vh></v>
<v t="ekr.20210118013807.1"><vh>main</vh></v>
<v t="ekr.20210118020530.1"><vh>new_name</vh></v>
<v t="ekr.20210118021337.1"><vh>exists</vh></v>
</v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20201208114843.1"><vh>script: diff-pr</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d7100285806000000302e31362e3071017d71025808000000616e6e6f7461746571037d7104735806000000302e31372e3071057d710668037d7107735806000000302e31392e3171087d710968037d710a735806000000302e32302e31710b7d710c68037d710d73752e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20190515070742.1"><vh>@file leoMarkup.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040236.1"><vh>@file ../commands/searchCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file ../plugins/trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file ../plugins/settings_finder.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file ../plugins/viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file ../plugins/leoflexx_js.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file ../plugins/importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file ../plugins/importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file ../plugins/importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050805162550"><vh>@@file ../plugins/rst3.py</vh>
<v t="ekr.20050805162550.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050805162550.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050806162146"><vh>&lt;&lt; to do &gt;&gt;</vh>
<v t="ekr.20050804081215"><vh>More options</vh></v>
</v>
<v t="ekr.20050805162550.4"><vh>Module level</vh>
<v t="ekr.20050805162550.5"><vh> init</vh></v>
<v t="ekr.20050805162550.6"><vh>onCreate</vh></v>
<v t="ekr.20050806101253"><vh>code_block</vh></v>
<v t="ekr.20090429055156.63"><vh>runUnitTests</vh></v>
</v>
<v t="ekr.20050805162550.39"><vh>html parser classes</vh>
<v t="ekr.20050805162550.40"><vh> &lt;&lt; class linkAnchorParserClass &gt;&gt; (subclass of HTMLParser.HTMLParser)</vh>
<v t="ekr.20050805162550.41"><vh>__init__</vh></v>
<v t="ekr.20050805162550.42"><vh>is_anchor</vh></v>
<v t="ekr.20050805162550.43"><vh>is_link</vh></v>
<v t="ekr.20050815164715"><vh>is_node_marker</vh></v>
</v>
<v t="ekr.20050805162550.44"><vh>class htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.45"><vh>__init__</vh></v>
<v t="ekr.20050805162550.46"><vh>handle_starttag</vh>
<v t="ekr.20050815164715.1"><vh>&lt;&lt; trace the unknownAttribute &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.47"><vh>handle_endtag</vh></v>
<v t="ekr.20050805162550.49"><vh>feed</vh></v>
</v>
<v t="ekr.20050805162550.50"><vh>class anchor_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.51"><vh> __init__</vh></v>
<v t="ekr.20050805162550.52"><vh>handle_starttag</vh></v>
</v>
<v t="ekr.20050805162550.53"><vh>class link_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.54"><vh>__init__</vh></v>
<v t="ekr.20050805162550.55"><vh>handle_starttag</vh></v>
<v t="ekr.20050805162550.56"><vh>get_replacements</vh></v>
</v>
</v>
<v t="ekr.20050805162550.8"><vh>class rstClass</vh>
<v t="ekr.20050805162550.9"><vh> Birth &amp; init</vh>
<v t="ekr.20050805162550.10"><vh> ctor (rstClass)</vh>
<v t="ekr.20050805162550.11"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.12"><vh>addMenu (rstClass, rst3.py) (obsolete)</vh></v>
<v t="ekr.20050813083007"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20050813085236"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20050808072943"><vh>munge</vh></v>
</v>
<v t="ekr.20050812122236"><vh>options...</vh>
<v t="ekr.20050808064245"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20050812120933"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20050814134351"><vh>getOption</vh></v>
<v t="ekr.20071015110830"><vh>initCodeBlockString</vh></v>
<v t="ekr.20050807120331.1"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20051204070141"><vh>preprocessNode</vh></v>
<v t="ekr.20050808072943.1"><vh>parseOptionLine</vh></v>
<v t="ekr.20050808070018.2"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20050811173750"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20050807120331.2"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20050808070018"><vh>scanOption</vh></v>
<v t="ekr.20050808070018.1"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20050808142313.28"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20050805162550.13"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20050810103731"><vh>handleSingleNodeOptions</vh></v>
</v>
<v t="ekr.20050811135526"><vh>setOption</vh></v>
</v>
<v t="ekr.20050809074827"><vh>write methods</vh>
<v t="ekr.20050809082854"><vh> Top-level write code</vh>
<v t="ekr.20050809075309"><vh>initWrite</vh></v>
<v t="ekr.20050809080925"><vh>writeNormalTree</vh></v>
<v t="ekr.20051121102358"><vh>processTopTree</vh></v>
<v t="ekr.20050805162550.17"><vh>processTree</vh></v>
<v t="ekr.20050805162550.21"><vh>writeSpecialTree</vh></v>
<v t="ekr.20050809082854.1"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090428082801.64"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20060525102337"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20050811154552"><vh>getDocPart</vh>
<v t="ekr.20060610104435"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811102607"><vh>skip_literal_block</vh></v>
<v t="ekr.20050811101550.1"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20050811150541"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20050811152104"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20050813155021"><vh>rstripList</vh></v>
<v t="ekr.20050813160208"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20060608094815"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20060608094815.1"><vh>isAnyDocPart</vh></v>
<v t="ekr.20050811153208"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20050811163802"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20050811105438"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20050811105438.1"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20050805162550.30"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20050805162550.26"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20060608102001"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20050810083057"><vh>writeNode</vh></v>
<v t="ekr.20071115061253"><vh>writePreformat</vh></v>
<v t="ekr.20050805162550.23"><vh>writeTree</vh></v>
</v>
<v t="ekr.20050810083314"><vh>Utils</vh>
<v t="ekr.20051202070028"><vh>computeOutputFileName</vh></v>
<v t="ekr.20050805162550.16"><vh>encode</vh></v>
<v t="ekr.20050805162550.20"><vh>report</vh></v>
<v t="ekr.20050810083856"><vh>rstComment</vh></v>
<v t="ekr.20050805162550.19"><vh>underline</vh></v>
<v t="ekr.20050809080031"><vh>write</vh></v>
</v>
<v t="ekr.20050805162550.33"><vh>Support for http plugin</vh>
<v t="ekr.20050815091008.1"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20050805162550.34"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20050805162550.36"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20050805162550.38"><vh>find_anchors</vh></v>
<v t="ekr.20050805162550.37"><vh>relocate_references</vh></v>
<v t="ekr.20050805162550.35"><vh>http_attribute_iter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20181028052650.1"><vh>@file ../plugins/leowapp.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20190805022257.1"><vh>Unused: @file ../plugins/file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init (pyzo_file_browser)</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
<v t="ekr.20190814050007.1"><vh>make_dock</vh></v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
<v t="ekr.20210223152423.1"><vh>@edit ../plugins/anki.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit ../plugins/QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file ../plugins/writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file ../plugins/writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="ekr.20210302164046.1"><vh>@edit ../../launchLeo.py</vh></v>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
<v t="ekr.20210202110241.1"><vh>@file leoclient.py</vh></v>
<v t="ekr.20210202110128.1"><vh>@file leoserver.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20180628055640.1"><vh>@file ../external/pdb_listener.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20210223151922.1"><vh>@edit ../modes/julia.py</vh></v>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt; (forth.py)</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt; (forth.py)</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt; (forth.py)</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
<v t="ekr.20210219115553.109"><vh>@edit ../modes/python.py</vh></v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
<v t="ekr.20201129023817.1"><vh>@file leoTest2.py</vh></v>
<v t="ekr.20201202144529.1"><vh>leo/unittests</vh>
<v t="ekr.20201202144422.1"><vh>@file ../unittests/commands/test_editCommands.py</vh></v>
<v t="ekr.20201203042030.1"><vh>@file ../unittests/core/test_leoNodes.py</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="EKR.20040614071102.1">def getScript(c, p,
    useSelectedText=True,
    forcePythonSentinels=True,
    useSentinels=True,
):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p: p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s, c.tab_width)
        s = g.extractExecutableString(c, p, s)
        script = g.composeScript(c, p, s,
                    forcePythonSentinels=forcePythonSentinels,
                    useSentinels=useSentinels)
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''
    return script
</t>
<t tx="ajones.20070122153625.2">def on_icondclick(tag, keywords):
    c = keywords.get("c")
    p = keywords.get("p")
    h = p.h
    if g.match_word(h,0,"@expfolder"):
        if p.hasChildren():
            result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Reread contents of folder "+h[11:]+"?")
            if result == "no":
                return
            kids = []
            for cp in p.subtree():
                if cp.isDirty() and g.match_word(cp.h, 0, "@text"):
                    kids.append(cp.copy())
            if kids != []:
                result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Save changed @text nodes?")
                if result == "yes":
                    for kid in kids:
                        savetextnode(c, kid)

            # delete children
            while p.firstChild():
                p.firstChild().doDelete()

        #changed = c.isChanged()
        dir = h[11:]
        dirs = []
        files = []
        for file in os.listdir(dir):
            path = os.path.join(dir, file)
            if os.path.isdir(path):
                dirs.append(path)
            else:
                files.append(path)

        #g.es('dirs: '+str(dirs))
        #g.es('files: '+str(files))

        dirs.sort()
        files.sort()
        for f in files:
            pn = p.insertAsNthChild(0)
            if os.path.splitext(f)[1] in textexts:
                c.setHeadString(pn, "@text "+f)
                pn.clearDirty()
            else:
                pn.h = f
        for d in dirs:
            pn = p.insertAsNthChild(0)
            c.setHeadString(pn, "@expfolder "+d)
        c.expandSubtree(p)
</t>
<t tx="ajones.20070122161942">def on_save(tag,keywords):
    c = keywords.get("c")
    if not c: return

    for p in c.all_positions():
        h = p.h
        if g.match_word(h,0,"@text") and p.isDirty():
            savetextnode(c, p)
            p.b = ""
</t>
<t tx="ajones.20070122181914.1">def readtextnode(c, p):

    name = getPath(c,p)
    try:
        file = open(name,"rU")
        g.es("..." + name)
        p.b = file.read()
        p.clearDirty()
        file.close()
    except IOError as msg:
        g.es("error reading %s: %s" % (name, msg))
        g.es("...not found: " + name)
        p.b = ''
        p.setDirty()
</t>
<t tx="bobjack.20080509080123.2">def universalCallback(self, source_c, function):
    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """

    def minibufferCallback(event, function=function):
        # Avoid a pylint complaint.
        if hasattr(self, 'theContextMenuController'):
            cm = getattr(self, 'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None
        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}
        keywords['mb_event'] = event
        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
        # For g.getDocStringForFunction
    minibufferCallback.source_c = source_c
        # For GetArgs.command_source
    return minibufferCallback

#fix bobjack's spelling error

universallCallback = universalCallback
</t>
<t tx="btheado.20111110215920.7164">def scrollDelegate(self, kind):
    """
    Scroll a QTreeWidget up or down or right or left.
    kind is in ('down-line','down-page','up-line','up-page', 'right', 'left')
    """
    c = self.c; w = self.treeWidget
    if kind in ('left', 'right'):
        hScroll = w.horizontalScrollBar()
        if kind == 'right':
            delta = hScroll.pageStep()
        else:
            delta = -hScroll.pageStep()
        hScroll.setValue(hScroll.value() + delta)
    else:
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + delta)
    c.treeWantsFocus()
</t>
<t tx="btheado.20120129145543.8180">def pageUpDown(self, op, moveMode):
    """
    The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
    and not externally accessible. Since Leo has its own keyhandling
    functionality, this code emulates the QTextEdit paging. This is a
    straight port of the C++ code found in the pageUpDown method of
    gui/widgets/qtextedit.cpp.
    """
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance &gt;= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
</t>
<t tx="danr7.20060912105041.6">def paste_as_headlines(c):
    # g.es("Starting...")
    currentPos = c.p
    clipText = g.app.gui.getTextFromClipboard()
    # Split clipboard text elements into a list
    clipList = clipText.split("\n")
    init_indent = len(clipList[0]) - len(clipList[0].lstrip())
    cur_pos = currentPos.copy()
    ancestors = [(init_indent,cur_pos)]
    for tempHead in clipList:
        indent = len(tempHead) - len(tempHead.lstrip())
        tempHead = tempHead.strip()
        # Make sure list item has some content
        if tempHead:
            if indent &gt; ancestors[-1][0]:
                ancestors.append((indent,cur_pos))
            else:
                while init_indent &lt;= indent &lt; ancestors[-1][0]:
                    ancestors.pop()
            # cur_indent = indent
            insertNode = ancestors[-1][1].insertAsLastChild()
            cur_pos = insertNode.copy()
            if len(tempHead)&gt;50:
                c.setHeadString(insertNode,tempHead[:50])
                insertNode.b = tempHead
            else:
                insertNode.h = tempHead
    currentPos.expand()
    c.redraw()
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.673"># name = tkFileDialog.askopenfilename(
    # title="Import Cisco Configuration File",
    # filetypes=[("All files", "*")]
    # )

name = g.app.gui.runOpenFileDialog (c,
    title="Import Cisco Configuration File",
    filetypes=[("All files", "*")],
    defaultextension='ini',
)

if not name:
    return

p = current.insertAsNthChild(0)
p.h = "cisco config: %s" % name
c.redraw()

try:
    fh = open(name)
    g.es("importing: %s" % name)
    linelist = fh.read().splitlines()
    fh.close()
except IOError as msg:
    g.es("error reading %s: %s" % (name, msg))
    return
</t>
<t tx="edream.110203113231.674">if customLine not in blocks:
    blocks[customLine] = []
    out.append(g.angleBrackets(customLine))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(customLine)
    children.append(child)

blocks[customLine].append(linelist[i])
</t>
<t tx="edream.110203113231.675">space = linelist[i].find(' ')
if space == -1:
    space = len(linelist[i])
key = linelist[i][:space]
if key in blocks:
    blocks[key] = []
    out.append(g.angleBrackets(key))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(key)
    children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
    while linelist[i].startswith(' '):
        value.append(linelist[i])
        i = i+1
except Exception:
    # EOF
    pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)
</t>
<t tx="edream.110203113231.676"># first print the level-0 text
outClean = []
prev = ''
for line in out:
    if line=='!' and prev=='!':
        pass # skip repeated comment lines
    else:
        outClean.append(line)
    prev = line
p.b = '\n'.join(outClean)

# scan through the created outline and add children
for child in children:
    # extract the key from the headline. Uhm... :)
    key = child.h.split('&lt;&lt;'
        )[1].split('&gt;&gt;')[0].strip()
    if key in blocks:
        # if type(blocks[key][0]) == type(''):
        if g.isString(blocks[key][0]):
            # it's a string, no sub-children, so just print the text
            child.b = '\n'.join(blocks[key])
        else:
            # it's a multi-level node
            for value in blocks[key]:
                # each value is a list containing the headline and then the text
                subchild = child.insertAsNthChild(0)
                subchild.h = value[0]
                subchild.b = '\n'.join(value)
        # child.sortChildren()
    else:
        # this should never happen
        g.es("Unknown key: %s" % key)
# p.sortChildren()
current.expand()
c.redraw()
</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="edream.110203113231.875">def sync_node_to_folder(c,parent,d):

    oldlist = {}
    newlist = []
    #get children info
    v = parent
    after_v = parent.nodeAfterTree()
    while v != after_v:
        if not v.hasChildren():
            oldlist[v.h] = v.b
        v = v.threadNext()
    #compare folder content to children
    for name in os.listdir(d):
        if name in oldlist:
            del oldlist[name]
        else:
            newlist.append(name)
    #insert newlist
    newlist.sort()
    newlist.reverse()
    for name in newlist:
        v = parent.insertAsNthChild(0)
        v.h = name
        v.setMarked()
    #warn for orphan oldlist
    if oldlist:
        g.es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="edream.110203113231.894"># Sets p's body text from the file with the given name.
# Returns True if the body text changed.
def insert_read_only_node (c,p,name):
    if name=="":
        name = g.app.gui.runOpenFileDialog(c,
            title="Open",
            filetypes=[("All files", "*")],
        )
        p.h = "@read-only %s" % name
        c.redraw()
    parse = urlparse(name)
    try:
        if parse[0] == 'ftp':
            f = FTPurl(name)  # FTP URL
        elif parse[0] == 'http':
            f = urlopen(name)  # HTTP URL
        else:
            f = open(name,"r")  # local file
        g.es("..." + name)
        new = f.read()
        f.close()
    except IOError: # as msg:
        p.b = "" # Clear the body text.
        return True # Mark the node as changed.
    else:
        ext = os.path.splitext(parse[2])[1]
        if ext.lower() in ['.htm', '.html']:
            &lt;&lt; convert HTML to text &gt;&gt;
        previous = p.b
        p.b = new
        changed = (g.toUnicode(new) != g.toUnicode(previous))
        if changed and previous != "":
            g.es("changed: %s" % name) # A real change.
        return changed
</t>
<t tx="edream.110203113231.895">fh = StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
    hyperlist = ['\n\n--Hyperlink list follows--']
    for i in range(numlinks):
        hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
    new = new + ''.join(hyperlist)
</t>
<t tx="edream.110203113231.928"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s,*args,**keys):

    body = self.frame.body
    w = body.wrapper
    if w:
        w.insert("end",s)
        body.onBodyChanged('put-to-body-text')
    # else: g.pr(s,newline=False)

# Same as frame.putnl except sends output to the end of the body text.
def newPutNl (self,s,*args,**keys):

    newPut (self,'\n')
</t>
<t tx="ekr.20031218072017.1329">def onBodyChanged(self, undoType, oldSel=None):
    """
    Update Leo after the body has been changed.
    
    This method is deprecated. New Leo commands and scripts should
    call u.before/afterChangeBody instead.
    """
    p, u, w = self.c.p, self.c.undoer, self.wrapper
    #
    # Shortcut.
    newText = w.getAllText()
    if p.b == newText:
        return
    #
    # Init data.
    newSel = w.getSelectionRange()
    newInsert = w.getInsertPoint()
    #
    # The "Before" snapshot.
    #
    # #1743: Restore oldSel for u.beforeChangeBody
    if oldSel and newSel and oldSel != newSel:
        i, j = oldSel
        w.setSelectionRange(i, j, insert=j)
    bunch = u.beforeChangeBody(p)
    #
    # #1743: Restore newSel if necessary.
    if oldSel and newSel and oldSel != newSel:
        i, j = newSel
        w.setSelectionRange(i, j, insert=newInsert)
    #
    # Careful. Don't redraw unless necessary.
    p.v.b = newText  # p.b would cause a redraw.
    #
    # "after" snapshot.
    u.afterChangeBody(p, undoType, bunch)
</t>
<t tx="ekr.20031218072017.1490">def doTyping(self, p, undo_type, oldText, newText,
    newInsert=None, oldSel=None, newSel=None, oldYview=None,
):
    """
    Save enough information to undo or redo a typing operation efficiently,
    that is, with the proper granularity.
    
    Do nothing when called from the undo/redo logic because the Undo
    and Redo commands merely reset the bead pointer.
    
    **Important**: Code should call this method *only* when the user has
    actually typed something. Commands should use u.beforeChangeBody and
    u.afterChangeBody.
    
    Only qtm.onTextChanged and ec.selfInsertCommand now call this method.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # Leo 6.4: undo_type must be 'Typing'.
    undo_type = undo_type.capitalize()
    assert undo_type == 'Typing', (repr(undo_type), g.callers())
    &lt;&lt; return if there is nothing to do &gt;&gt;
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    if 'undo' in g.app.debug and 'verbose' in g.app.debug:
        print(f"u.doTyping: {len(oldText)} =&gt; {len(newText)}")
    if u.per_node_undo:
        u.putIvarsToVnode(p)
    #
    # Finish updating the text.
    p.v.setBodyString(newText)
    u.updateAfterTyping(p, w)
        
# Compatibility

setUndoTypingParams = doTyping
</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c
old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len, new_len)
i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i
if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len - i - 1] != new_lines[new_len - i - 1]:
            break
        i += 1
    trailing = i
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading : -trailing]
    new_middle_lines = new_lines[leading : -trailing]
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1
i = len(newText) - 1; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1
</t>
<t tx="ekr.20031218072017.1492">u.oldText = None
u.newText = None
u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20031218072017.1553">def getLeoFile(self,
    theFile,
    fileName,
    readAtFileNodesFlag=True,
    silent=False,
    checkOpenFiles=True,
):
    """
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    """
    fc, c = self, self.c
    t1 = time.time()
    c.clearChanged()  # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    recoveryNode = None
    try:
        c.loading = True  # disable c.changed
        if not silent and checkOpenFiles:
            # Don't check for open file when reverting.
            g.app.checkForOpenFile(c, fileName)
        #
        # Read the .leo file and create the outline.
        if fileName.endswith('.db'):
            v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
        else:
            v = FastRead(c, self.gnxDict).readFile(theFile, fileName)
            if v:
                c.hiddenRootNode = v
        if v:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # c.redraw()
                    # Does not work.
                    # Redraw before reading the @file nodes so the screen isn't blank.
                    # This is important for big files like LeoPy.leo.
                recoveryNode = fc.readExternalFiles(fileName)
    finally:
        p = recoveryNode or c.p or c.lastTopLevel()
            # lastTopLevel is a better fallback, imo.
        c.selectPosition(p)
        c.redraw_later()
            # Delay the second redraw until idle time.
            # This causes a slight flash, but corrects a hangnail.
        c.checkOutline()
            # Must be called *after* ni.end_holding.
        c.loading = False
            # reenable c.changed
        if not isinstance(theFile, sqlite3.Connection):
            theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    fc.initReadIvars()
    t2 = time.time()
    g.es(f"read outline in {t2 - t1:2.2f} seconds")
    return v, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles(self, fileName):
    # os.access may not exist on all platforms.
    try:
        self.read_only = not os.access(fileName, os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False
    if self.read_only and not g.unitTesting:
        g.error("read only:", fileName)
</t>
<t tx="ekr.20031218072017.2377">def getSelectionLines(self):
    """
    Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)
    """
    if g.app.batchMode:
        return '', '', ''
    # At present, called only by c.getBodyLines.
    body = self
    w = body.wrapper
    s = w.getAllText()
    i, j = w.getSelectionRange()
    if i == j:
        i, j = g.getLine(s, i)
    else:
        # #1742: Move j back if it is at the start of a line.
        if j &gt; i and j &gt; 0 and s[j-1] == '\n':
            j -= 1
        i, junk = g.getLine(s, i)
        junk, j = g.getLine(s, j)
    before = g.checkUnicode(s[0:i])
    sel = g.checkUnicode(s[i:j])
    after = g.checkUnicode(s[j : len(s)])
    return before, sel, after  # 3 strings.
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2817">command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
</t>
<t tx="ekr.20031218072017.2996">@g.commander_command('goto-next-visible')
def selectVisNext(self, event=None):
    """Select the visible node following the presently selected node."""
    c, p = self, self.p
    if not p:
        return
    if c.canSelectVisNext():
        p.moveToVisNext(c)
        c.treeSelectHelper(p)
    else:
        c.endEditing()  # 2011/05/28: A special case.
</t>
<t tx="ekr.20031218072017.3029">def readAtFileNodes(self):
    
    c, p = self.c, self.c.p
    c.endEditing()
    c.atFileCommands.readAll(p, force=True)
    c.redraw()
    # Force an update of the body pane.
    c.setBodyString(p, p.b)  # Not a do-nothing!
    
</t>
<t tx="ekr.20031218072017.3053">def __init__(self, c):
    """Ctor for LeoFind class."""
    self.c = c
    self.expert_mode = False  # Set in finishCreate.
    self.ftm = None  # Created by dw.createFindTab.
    self.frame = None
    self.k = c.k
    self.re_obj = None
    #
    # The work "widget".
    self.work_s = ''  # p.b or p.c.
    self.work_sel = (0, 0, 0)  # pos, newpos, insert.
    #
    # Options ivars: set by FindTabManager.init.
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.whole_word = None
    #
    # For isearch commands...
    self.stack = []  # Entries are (p, sel)
    self.isearch_ignore_case = None
    self.isearch_forward_flag = None
    self.isearch_regexp = None
    self.findTextList = []
    self.changeTextList = []
    #
    # For find/change...
    self.find_text = ""
    self.change_text = ""
    #
    # State machine...
    self.escape_handler = None
    self.handler = None
    # "Delayed" requests for do_find_next.
    self.request_reverse = False
    self.request_pattern_match = False
    self.request_whole_word = False
    # Internal state...
    self.changeAllFlag = False
    self.findAllUniqueFlag = False
    self.find_def_data = None
    self.in_headline = False
    self.match_obj = None
    self.reverse = False
    self.root = None  # The start of the search, especially for suboutline-only.
    self.unique_matches = set()
    #
    # User settings.
    self.minibuffer_mode = None
    self.reload_settings()
</t>
<t tx="ekr.20031218072017.3055"></t>
<t tx="ekr.20031218072017.3062">@cmd('replace-then-find')
@cmd('change-then-find')
def change_then_find(self, event=None):  # pragma: no cover (cmd)
    """Handle the replace-then-find command."""
    # Settings...
    self.init_in_headline()
    settings = self.ftm.get_settings()
    self.do_change_then_find(settings)
</t>
<t tx="ekr.20031218072017.3063">@cmd('find-next')
def find_next(self, event=None):  # pragma: no cover (cmd)
    """The find-next command."""
    # Settings...
    self.reverse = False
    self.init_in_headline()  # Do this *before* creating the settings.
    settings = self.ftm.get_settings()
    # Do the command!
    self.do_find_next(settings)

@cmd('find-prev')
def find_prev(self, event=None):  # pragma: no cover (cmd)
    """Handle F2 (find-previous)"""
    # Settings...
    self.init_in_headline()  # Do this *before* creating the settings.
    settings = self.ftm.get_settings()
    # Do the command!
    self.do_find_prev(settings)
</t>
<t tx="ekr.20031218072017.3067"></t>
<t tx="ekr.20031218072017.3068">@cmd('replace')
@cmd('change')
def change(self, event=None):  # pragma: no cover (cmd)
    p = self.c.p
    if self.check_args('replace'):
        self.init_in_headline()
        self.change_selection(p)

replace = change
</t>
<t tx="ekr.20031218072017.3069">def _change_all_helper(self, settings):
    """Do the change-all command. Return the number of changes, or 0 for error."""
    # Caller has checked settings.

    c, current, u = self.c, self.c.p, self.c.undoer
    undoType = 'Replace All'
    t1 = time.process_time()
    if not self.check_args('change-all'):  # pragma: no cover
        return 0
    self.init_in_headline()
    saveData = self.save()
    self.in_headline = self.search_headline  # Search headlines first.
    # Remember the start of the search.
    p = self.root = c.p.copy()
    # Set the work widget.
    s = p.h if self.in_headline else p.b
    ins = len(s) if self.reverse else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    count = 0
    u.beforeChangeGroup(current, undoType)
    # Fix bug 338172: ReplaceAll will not replace newlines
    # indicated as \n in target string.
    if not self.find_text:  # pragma: no cover
        return 0
    if not self.search_headline and not self.search_body:  # pragma: no cover
        return 0
    self.change_text = self.replace_back_slashes(self.change_text)
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:
            return 0
    # #1428: Honor limiters in replace-all.
    if self.node_only:
        positions = [c.p]
    elif self.suboutline_only:
        positions = c.p.self_and_subtree()
    else:
        positions = c.all_unique_positions()
    count = 0
    for p in positions:
        count_h, count_b = 0, 0
        undoData = u.beforeChangeNodeContents(p)
        if self.search_headline:
            count_h, new_h = self._change_all_search_and_replace(p.h)
            if count_h:
                count += count_h
                p.h = new_h
        if self.search_body:
            count_b, new_b = self._change_all_search_and_replace(p.b)
            if count_b:
                count += count_b
                p.b = new_b
        if count_h or count_b:
            u.afterChangeNodeContents(p, 'Replace All', undoData)
    self.ftm.set_radio_button('entire-outline')
    # suboutline-only is a one-shot for batch commands.
    self.root = None
    self.node_only = self.suboutline_only = False
    p = c.p
    u.afterChangeGroup(p, undoType, reportFlag=True)
    t2 = time.process_time()
    if not g.unitTesting:  # pragma: no cover
        g.es_print(
            f"changed {count} instances{g.plural(count)} "
            f"in {t2 - t1:4.2f} sec.")
    c.recolor()
    c.redraw(p)
    self.restore(saveData)
    return count
</t>
<t tx="ekr.20031218072017.3070">def change_selection(self, p):
    """Replace selection with self.change_text."""
    c = self.c
    wrapper = c.frame.body and c.frame.body.wrapper
    gui_w = c.edit_widget(p) if self.in_headline else wrapper
    if not gui_w:  # pragma: no cover
        self.in_headline = False
        gui_w = wrapper
    if not gui_w:  # pragma: no cover
        return False
    oldSel = sel = gui_w.getSelectionRange()
    start, end = sel
    if start &gt; end:  # pragma: no cover
        start, end = end, start
    if start == end:  # pragma: no cover
        g.es("no text selected")
        return False
    start, end = oldSel
    change_text = self.change_text
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.make_regex_subs(change_text, groups)
    change_text = self.replace_back_slashes(change_text)
    # Update both the gui widget and the work "widget"
    new_ins = start if self.reverse else start + len(change_text)
    if start != end:
        gui_w.delete(start, end)
        self.work_s = self.work_s[:start] + self.work_s[start + end :]
    gui_w.insert(start, change_text)
    gui_w.setInsertPoint(new_ins)
    self.work_sel = (new_ins, new_ins, new_ins)
    # Update the selection for the next match.
    gui_w.setSelectionRange(start, start + len(change_text))
    c.widgetWantsFocus(gui_w)
    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:  # pragma: no cover
        p.setMarked()
        p.setDirty()
    if self.in_headline:  # pragma: no cover
        pass
    else:
        c.frame.body.onBodyChanged('Change', oldSel=oldSel)
    c.frame.tree.updateIcon(p)  # redraw only the icon.
    return True
</t>
<t tx="ekr.20031218072017.3073">def do_find_all(self, settings):
    """Top-level helper for find-all command."""
    c = self.c
    count = 0
    self.init_ivars_from_settings(settings)
    if not self.check_args('find-all'):  # pragma: no cover
        return count
    # Init data.
    self.init_in_headline()
    data = self.save()
    self.in_headline = self.search_headline  # Search headlines first.
    self.unique_matches = set()  # 2021/02/20.
    # Remember the start of the search.
    p = self.root = c.p.copy()
    # Set the work widget.
    s = p.h if self.in_headline else p.b
    ins = len(s) if self.reverse else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:  # pragma: no cover
            return count
    if self.suboutline_only:
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Always search the entire outline.
        p = c.rootPosition()
        after = None
    # Fix #292: Never collapse nodes during find-all commands.
    old_sparse_find = c.sparse_find
    try:
        c.sparse_find = False
        count = self._find_all_helper(after, data, p, 'Find All')
        c.contractAllHeadlines()
    finally:
        c.sparse_find = old_sparse_find
        self.root = None
    if count:
        c.redraw()
    g.es("found", count, "matches for", self.find_text)
    return count
</t>
<t tx="ekr.20031218072017.3074">def do_find_prev(self, settings):
    """Find the previous instance of self.find_text."""
    self.request_reverse = True
    return self.do_find_next(settings)

def do_find_next(self, settings):
    """
    Find the next instance of self.find_text.
    
    Return True (for vim-mode) if a match was found.
    
    """
    c, p = self.c, self.c.p
    #
    # The gui widget may not exist for headlines.
    gui_w = c.edit_widget(p) if self.in_headline else c.frame.body.wrapper
    #
    # Init the work widget, so we don't get stuck.
    s = p.h if self.in_headline else p.b
    ins = gui_w.getInsertPoint() if gui_w else 0
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    #
    # Set the settings *after* initing the search.
    self.init_ivars_from_settings(settings)
    #
    # Honor delayed requests.
    for ivar in ('reverse', 'pattern_match', 'whole_word'):
        request = 'request_' + ivar
        val = getattr(self, request)
        if val:  # Only *set* the ivar!
            setattr(self, ivar, val)  # Set the ivar.
            setattr(self, request, False)  # Clear the request!
    #
    # Leo 6.4: set/clear self.root
    if self.root:  # pragma: no cover
        if p != self.root and not self.root.isAncestorOf(p):
            # p is outside of self.root's tree.
            # Clear suboutline-only.
            self.root = None
            self.suboutline_only = False
            self.set_find_scope_every_where()  # Update find-tab &amp; status area.
    elif self.suboutline_only:
        # Start the range and set suboutline-only.
        self.root = c.p
        self.set_find_scope_suboutline_only()  # Update find-tab &amp; status area.
    #
    # Now check the args.
    tag = 'find-prev' if self.reverse else 'find-next'
    if not self.check_args(tag):  # Issues error message.
        return None, None, None
    data = self.save()
    p, pos, newpos = self.find_next_match(p)
    found = pos is not None
    if found:
        self.show_success(p, pos, newpos)
    else:
        # Restore previous position.
        self.restore(data)
    self.show_status(found)
    return p, pos, newpos
</t>
<t tx="ekr.20031218072017.3075">def find_next_match(self, p):
    """
    Resume the search where it left off.
    
    Return (p, pos, newpos).
    """
    c = self.c
    if not self.search_headline and not self.search_body:  # pragma: no cover
        return None, None, None
    if not self.find_text:  # pragma: no cover
        return None, None, None
    attempts = 0
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:
            return None, None, None
    while p:
        pos, newpos = self._fnm_search(p)
        if pos is not None:
            # Success.
            if self.mark_finds:  # pragma: no cover
                p.setMarked()
                p.setDirty()
                if not self.changeAllFlag:
                    c.frame.tree.updateIcon(p)  # redraw only the icon.
            return p, pos, newpos
        # Searching the pane failed: switch to another pane or node.
        if self._fnm_should_stay_in_node(p):
            # Switching panes is possible.  Do so.
            self.in_headline = not self.in_headline
            s = p.h if self.in_headline else p.b
            ins = len(s) if self.reverse else 0
            self.work_s = s
            self.work_sel = (ins, ins, ins)
        else:
            # Switch to the next/prev node, if possible.
            attempts += 1
            p = self._fnm_next_after_fail(p)
            if p:  # Found another node: select the proper pane.
                self.in_headline = self._fnm_first_search_pane()
                s = p.h if self.in_headline else p.b
                ins = len(s) if self.reverse else 0
                self.work_s = s
                self.work_sel = (ins, ins, ins)
    return None, None, None
</t>
<t tx="ekr.20031218072017.3077">def _fnm_search(self, p):
    """
    Search self.work_s for self.find_text with present options.
    Returns (pos, newpos) or (None, dNone).
    """
    index = self.work_sel[2]
    s = self.work_s
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:  # pragma: no cover
        return None, None
    stopindex = 0 if self.reverse else len(s)
    pos, newpos = self.inner_search_helper(s, index, stopindex, self.find_text)
    if self.in_headline and not self.search_headline:  # pragma: no cover
        return None, None
    if not self.in_headline and not self.search_body:  # pragma: no cover
        return None, None
    if pos == -1:  # pragma: no cover
        return None, None
    ins = min(pos, newpos) if self.reverse else max(pos, newpos)
    self.work_sel = (pos, newpos, ins)
    return pos, newpos
</t>
<t tx="ekr.20031218072017.3082"></t>
<t tx="ekr.20031218072017.3086">def init_in_headline(self):
    """
    Select the first pane to search for incremental searches and changes.
    This is called only at the start of each search.
    This must not alter the current insertion point or selection range.
    """
    #
    # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
    if self.search_headline and self.search_body:
        # We have no choice: we *must* search the present widget!
        self.in_headline = self.focus_in_tree()
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20031218072017.3089">def restore(self, data):
    """
    Restore Leo's gui and settings from data, a g.Bunch.
    """
    c, p = self.c, data.p
    c.frame.bringToFront()  # Needed on the Mac
    if not p or not c.positionExists(p):  # pragma: no cover
        # Better than selecting the root!
        return
    c.selectPosition(p)
    # Fix bug 1258373: https://bugs.launchpad.net/leo-editor/+bug/1258373
    if self.in_headline:
        c.treeWantsFocus()
    else:
        # Looks good and provides clear indication of failure or termination.
        w = c.frame.body.wrapper
        w.setSelectionRange(data.start, data.end, insert=data.insert)
        w.seeInsertPoint()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20031218072017.3090">def save(self):
    """Save everything needed to restore after a search fails."""
    c = self.c
    if self.in_headline:  # pragma: no cover
        # Fix bug 1258373: https://bugs.launchpad.net/leo-editor/+bug/1258373
        # Don't try to re-edit the headline.
        insert, start, end = None, None, None
    else:
        w = c.frame.body.wrapper
        insert = w.getInsertPoint()
        start, end = w.getSelectionRange()
    data = g.Bunch(
        end=end,
        in_headline=self.in_headline,
        insert=insert,
        p=c.p.copy(),
        start=start,
    )
    return data
</t>
<t tx="ekr.20031218072017.3091">def show_success(self, p, pos, newpos, showState=True):
    """Display the result of a successful find operation."""
    c = self.c
    # Set state vars.
    # Ensure progress in backwards searches.
    insert = min(pos, newpos) if self.reverse else max(pos, newpos)
    if c.sparse_find:  # pragma: no cover
        c.expandOnlyAncestorsOfNode(p=p)
    if self.in_headline:
        c.endEditing()
        selection = pos, newpos, insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        # Tricky code.  Do not change without careful thought.
        w = c.frame.body.wrapper
        # *Always* do the full selection logic.
        # This ensures that the body text is inited  and recolored.
        c.selectPosition(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        c.bodyWantsFocusNow()
        w.setSelectionRange(pos, newpos, insert=insert)
        k = g.see_more_lines(w.getAllText(), insert, 4)
        w.see(k)
            # #78: find-next match not always scrolled into view.
        c.outerUpdate()
            # Set the focus immediately.
        if c.vim_mode and c.vimCommands:  # pragma: no cover
            c.vimCommands.update_selection_after_search()
    # Support for the console gui.
    if hasattr(g.app.gui, 'show_find_success'):  # pragma: no cover
        g.app.gui.show_find_success(c, self.in_headline, insert, p)
    c.frame.bringToFront()
    return w  # Support for isearch.
    
</t>
<t tx="ekr.20031218072017.3210">def createOutline(self,
    fileName,
    parent,
    atShadow=False,  # For error messages only.
    ext=None,
    s=None,
    # force_at_others=False,  # tag:no-longer-used
):
    """
    Create an outline by importing a file, reading the file with the
    given encoding if string s is None.

    ext,        The file extension to be used, or None.
    fileName:   A string or None. The name of the file to be read.
    parent:     The parent position of the created outline.
    s:          A string or None. The file's contents.
    """
    c = self.c
    p = parent.copy()
    self.treeType = '@file'
        # Fix #352.
    fn = self.get_import_filename(fileName, parent)
    if g.is_binary_external_file(fileName):
        return self.import_binary_file(fn, parent)
    # Init ivars.
    self.setEncoding(
        p=parent,
        default=c.config.default_at_auto_file_encoding,
    )
    ext, s = self.init_import(atShadow, ext, fileName, s)
    if s is None:
        return None
    # Get the so-called scanning func.
    func = self.dispatch(ext, p)
        # Func is a callback. It must have a c argument.
    # Call the scanning function.
    if g.unitTesting:
        assert func or ext in ('.txt', '.w', '.xxx'), (repr(func), ext, p.h)
    if func and not c.config.getBool('suppress-import-parsing', default=False):
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        # func is actually a factory: it instantiates the importer class.
        func(c=c, parent=p, s=s)
            # force_at_others=force_at_others #tag:no-longer-used
    else:
        # Just copy the file to the parent node.
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        self.scanUnknownFileType(s, p, ext)
    # Fix bug 488894: unsettling dialog when saving Leo file
    # Fix bug 889175: Remember the full fileName.
    c.atFileCommands.rememberReadPath(fileName, p)
    p.contract()
    w = c.frame.body.wrapper
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context: Cmdr, gnx: Optional[str] = None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString: str = 'newHeadline'
    self._bodyString: str = ''
    # For zodb.
    self._p_changed = 0
    # Structure data...
    self.children: List["VNode"] = []
        # Ordered list of all children of this node.
    self.parents: List["VNode"] = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex: Union[str, None] = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions: List[Position] = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self) -&gt; bool:
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3395">def contract(self):
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20040205071616.4">def setHeadOK(c,v):

    v.h = OKFLAG + v.h

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp (c,v):

    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    stamp = mnOKstamp() + '\n'
    bunch = u.beforeChangeBody(p)
    ins = w.getInsertPoint()
    w.insert(ins,stamp)
    p.v.b = w.getAllText()  # p.b would cause a redraw.
    u.afterChangeBody(p, 'insert-timestamp', bunch)
</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    """Handle the Insert User command."""
    c = self
    w = c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    w.deleteTextSelection() # Works if nothing is selected.
    stamp = mnstamp()
    i = w.getInsertPoint()
    w.insert(i,stamp)
    c.frame.body.onBodyChanged('insert-user',oldSel=oldSel)
</t>
<t tx="ekr.20040305223225">def setHeadString(self, p, s):
    """
    Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.
    """
    c = self
    p.initHeadString(s)
    p.setDirty()
    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p, s)
</t>
<t tx="ekr.20040305223522">def setBodyString(self, p, s):
    """
    This is equivalent to p.b = s.
    
    Warning: This method may call c.recolor() or c.redraw().
    """
    c, v = self, p.v
    if not c or not v:
        return
    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v == current.v:
        w = c.frame.body.wrapper
        w.setAllText(s)
        v.setSelection(0,0)
        c.recolor()
    # Keep the body text in the VNode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20040315032503">def appendStringToBody(self, p, s):

    if s:
        p.b = p.b + g.toUnicode(s)
</t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return None
if undo_type is None:
    return None
if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
if oldText == newText:
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20040324061854.1">u.clearOptionalIvars()
# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20040324061854.2"># Remember the selection.
u.oldSel = oldSel
u.newSel = newSel
# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.wrapper.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@
New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:
word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c
granularity = u.granularity
old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')
&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;
# Save end selection as new "previous" selection
u.prevSel = u.newSel
if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p=p.copy(),
        kind='typing',  # lowercase.
        undoType=undo_type,  # capitalized.
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldMarked=old_p.isMarked() if old_p else p.isMarked(), # #1694
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d
bunch.leading = u.leading
bunch.trailing = u.trailing
bunch.newMarked = p.isMarked()  # #1694 
bunch.newNewlines = u.newNewlines
bunch.newMiddleLines = u.newMiddleLines
bunch.newSel = u.newSel
bunch.newText = u.newText
bunch.yview = u.yview
</t>
<t tx="ekr.20040327105706">def __init__(self, c, title, gui):
    """Ctor for the NullFrame class."""
    super().__init__(c, gui)
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.initComplete = True
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None  # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = leoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.

Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import os
from leo.core import leoGlobals as g
Tk = g.import_module('tkinter')


if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except Exception:
                            g.es("can not open " + g.shortFileName(path))
                            break

                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03

                        conflict = body != old_body and body != s

                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.error("conflict in " + g.shortFileName(path))
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog(c,"Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body

                        if update:
                            g.blue("updated from: " + g.shortFileName(path))
                            v.b = s
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.warning("not updated from: " + g.shortFileName(path))
                except Exception:
                    g.es_exception() # testing
                    pass
    def create_open_with_menu (tag,keywords):

        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):

            # Entries in the following table are the tuple
            # (commandName,shortcut,data).
            #
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl",
            # "os.spawnv" or "exec".
            #
            # Leo executes command(arg+path) where path is the full path to
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language
            # directive is in effect.

            idle_arg = "c:/python22/tools/idle/idle.py -e "

@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

            c.frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        g.registerHandler("idle", on_idle)
        g.registerHandler(("start2","menu2","command2"), create_open_with_menu)

        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331151007.1">def onPreSave(tag=None, keywords=None):

    """Before saving an @nosent file, make sure that all nodes have a blank line at the end."""

    global nosentNodes
    c = keywords.get('c')
    if c:
        for p in c.all_positions():
            if p.isAtNoSentinelsFileNode() and p.isDirty():
                nosentNodes.append(p.copy())
                for p2 in p.self_and_subtree():
                    s = p2.b
                    lastline = s.split('\n')[-1]
                    if lastline.strip():
                        p2.b = s + '\n'
</t>
<t tx="ekr.20040703054646">global lastTypesDict
typesDict = {}
for obj in gc.get_objects():
    t = type(obj)
    # pylint: disable=no-member
    if t == 'instance' and t != types.UnicodeType:  # NOQA
        try: t = obj.__class__
        except Exception: pass
    if t != types.FrameType:  # NOQA
        r = repr(t)  # was type(obj) instead of repr(t)
        n = typesDict.get(r, 0)
        typesDict[r] = n + 1
# Create the union of all the keys.
keys = {}
for key in lastTypesDict:
    if key not in typesDict:
        keys[key] = None
empty = True
for key in keys:
    n3 = lastTypesDict.get(key, 0)
    n4 = typesDict.get(key, 0)
    delta2 = n4 - n3
    if delta2 != 0:
        empty = False
        break
if not empty:
    g.pr('-' * 30)
    g.pr(f"{tag}: garbage: {n}, objects: {n2}, delta: {delta}")
    if 0:
        for key in sorted(keys):
            n1 = lastTypesDict.get(key, 0)
            n2 = typesDict.get(key, 0)
            delta2 = n2 - n1
            if delta2 != 0:
                g.pr(f"{delta2:6d} ={n2:7d} {key}")
lastTypesDict = typesDict
typesDict = {}
</t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041005105605.144">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041005105605.21">def read(self, root, importFileName=None,
    fromString=None, atShadow=False, force=False
):
    """Read an @thin or @file tree."""
    at, c = self, self.c
    fileName = at.initFileName(fromString, importFileName, root)
    if not fileName:
        at.error("Missing file name. Restoring @file tree from .leo file.")
        return False
    at.rememberReadPath(g.fullPath(c, root), root)
        # Fix bug 760531: always mark the root as read, even if there was an error.
        # Fix bug 889175: Remember the full fileName.
    at.initReadIvars(root, fileName,
        importFileName=importFileName, atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        return False
    fileName, file_s = at.openFileForReading(fromString=fromString)
    # #1798:
    if file_s is None:
        return False
    #
    # Set the time stamp.
    if fileName:
        c.setFileTimeStamp(fileName)
    elif not fileName and not fromString and not file_s:
        return False
    root.clearVisitedInTree()
    at.scanAllDirectives(root, importing=at.importing, reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **changed later** by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    gnx2vnode = c.fileCommands.gnxDict
    contents = fromString or file_s
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    root.clearDirty()
    return True
</t>
<t tx="ekr.20041005105605.22">def initFileName(self, fromString, importFileName, root):
    """Return the fileName to be used in messages."""
    # at = self
    c = self.c
    if fromString:
        fileName = "&lt;string-file&gt;"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        # #1798: It's not possible to honor the @path directive in @file nodes!
        #        @file nodes have empty bodies here, before Leo reads the outline.
        fileName = root.anyAtFileNodeName()
        # #102, #1341: expand user expression.
        fileName = c.expand_path_expression(fileName)  # #1341:
    else:
        fileName = None
    if fileName:
        fileName = g.os_path_finalize(fileName)  # #1341:
    return fileName
</t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20041119204700.1">def traverse(self):
    """Traverse the entire settings tree."""
    c = self.c
    self.settingsDict = g.TypedDict(
        name=f"settingsDict for {c.shortFileName()}",
        keyType=type('settingName'),
        valType=g.GeneralSetting)
    self.shortcutsDict = g.TypedDict(  # was TypedDictOfLists.
        name=f"shortcutsDict for {c.shortFileName()}",
        keyType=str,
        valType=g.BindingInfo)
    # This must be called after the outline has been inited.
    p = c.config.settingsRoot()
    if not p:
        # c.rootPosition() doesn't exist yet.
        # This is not an error.
        return self.shortcutsDict, self.settingsDict
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        if result == "skip":
            # g.warning('skipping settings in',p.h)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    # Return the raw dict, unmerged.
    return self.shortcutsDict, self.settingsDict
</t>
<t tx="ekr.20041120074536">def settingsRoot(self):
    """Return the position of the @settings tree."""
    c = self.c
    for p in c.all_unique_positions():
        # #1792: Allow comments after @settings.
        if g.match_word(p.h.rstrip(), 0, "@settings"):
            return p.copy()
    return None
</t>
<t tx="ekr.20041121130043"># These are the canonicalized names.
# Case is ignored, as are '_' and '-' characters.
basic_types = [
    # Headlines have the form @kind name = var
    'bool',
    'color',
    'directory',
    'int',
    'ints',
    'float',
    'path',
    'ratio',
    'string',
    'strings',
]
control_types = [
    'buttons',
    'commands',
    'data',
    'enabledplugins',
    'font',
    'ifenv',
    'ifhostname',
    'ifplatform',
    'ignore',
    'menus',
    'mode',
    'menuat',
    'openwith',
    'outlinedata',
    'popup',
    'settings',
    'shortcuts',
]
# Keys are settings names, values are (type,value) tuples.
settingsDict: Dict[str, Tuple[str, Union[g.TypedDict, g.GeneralSetting]]] = {}
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050125203937"># Fix #653: undoer problem: be wary of the ternary operator here.
old_start = old_end = new_start = new_end = 0
if oldSel is not None:
    old_start, old_end = oldSel
if newSel is not None:
    new_start, new_end = newSel
if u.prevSel is None:
    prev_start, prev_end = 0, 0
else:
    prev_start, prev_end = u.prevSel
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    # 2011/04/01: Patch by Sam Hartsfield
    old_row, old_col = g.convertPythonIndexToRowCol(
        oldText, old_start)
    new_row, new_col = g.convertPythonIndexToRowCol(
        newText, new_start)
    prev_row, prev_col = g.convertPythonIndexToRowCol(
        oldText, prev_start)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col - new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        # py-lint: disable=W0511
        # W0511:1362: TODO
        # TODO this is not true, we might as well just have entered a
        # char at the beginning of an existing line
        pass  # We have just inserted a line.
    else:
        # 2011/04/01: Patch by Sam Hartsfield
        old_s = old_lines[old_row]
        new_s = new_lines[new_row]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col - 1 &gt;= len(old_s) or new_col - 1 &gt;= len(new_s):
            newBead = True
        else:
            old_ch = old_s[old_col - 1]
            new_ch = new_s[new_col - 1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines, old_row, old_col, old_ch,
                new_lines, new_row, new_col, new_ch,
                prev_row, prev_col)
</t>
<t tx="ekr.20050125220613"># Set newBead to True if undo_type is not 'Typing' so that commands that
# get treated like typing (by onBodyChanged) don't get lumped
# with 'real' typing.
@c
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True  # We can't share the previous node.
elif granularity == 'char':
    newBead = True  # This was the old way.
elif granularity == 'node':
    newBead = False  # Always replace previous bead.
else:
    assert granularity in ('line', 'word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading', 0) != u.leading or
        old_d.get('trailing', 0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            g.error('Unexpected exception...')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20050126081529">def recognizeStartOfTypingWord(self,
    old_lines, old_row, old_col, old_ch,
    new_lines, new_row, new_col, new_ch,
    prev_row, prev_col
):
    """
    A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.doTyping calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.
    """
    # Start a word if new_ch begins whitespace + word
    new_word_started = not old_ch.isspace() and new_ch.isspace()
    # Start a word if the cursor has been moved since the last change
    moved_cursor = new_row != prev_row or new_col != prev_col + 1
    return new_word_started or moved_cursor
</t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

from leo.core import leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050315133212.2">def beforeChangeNodeContents(self, p):
    """Return data that gets passed to afterChangeNode."""
    c, u = self.c, self
    w = c.frame.body.wrapper
    bunch = u.createCommonBunch(p)
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    # #1413: Always restore yScroll if possible.
    bunch.oldYScroll = w.getYScrollPosition() if w else 0
    return bunch
</t>
<t tx="ekr.20050315134017.2">def afterChangeNodeContents(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeNode."""
    u = self
    c = self.c
    w = c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    bunch.inHead = False  # 2013/08/26
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    # Bug fix 2017/11/12: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
</t>
<t tx="ekr.20050408100042">def undoRedoTree(self, p, new_data, old_data):
    """Replace p and its subtree using old_data during undo."""
    # Same as undoReplace except uses g.Bunch.
    u = self; c = u.c
    if new_data is None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p, p.b)  # This is not a do-nothing.
    return p  # Nothing really changes.
</t>
<t tx="ekr.20050412084532">def redoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent, 0)
    else:
        u.newP._linkAsRoot()
    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                u.newP.b = bunch.body
                u.newP.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
    u.newP.setDirty()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412085112">def undoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc: cc.selectChapterByName('main')
    u.newP.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.newP)
    c.deleteOutline()
        # Bug fix: 2016/03/30.
        # This always selects the proper new position.
        # c.selectPosition(u.p)
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                u.p.b = bunch.body
                u.p.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050804081215">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3276408

Leo has great potential for smoothing some of the bumps
outside of learning the details of the markup.
Here is my wish list;

(done) - Section level handling.
  - one of the problems with using rst comes when a new
    section level is inserted into a document. Leo can
    take care of this effortlessly, providing a correct
   underline character for each section heading.

    Other than the section management, I want Leo to
    assume that I'm writing rst, and should be rendered
    as-is. If I want to include some pretty Python, I put
    it in a ..  python-code:: block (or some such)

    On top of this base could be built special case
    handling.

- Assist in viewing rendered output
  - easy access to the command to render a tree to  html.
  - I would like an option which automatically inserted
    a @url node which pointed to the rendered file, or
    some other trick to make switching between source
    and output painless.

- Assist in working with the CSS file
  - a CSS file is now required by docutils. A @setting
    could specify the file. I would like some kind of
    sugar which made it easy to edit the CSS file, maybe
    an option to create a @file node automatically,
    like the @url node above. Again, I want to be able
    to effortlessly edit the CSS and see the results.

- The third file of interest when writing rst is the config
   file which controls many behaviours of the renderer.
   Again, some intelligence which located it, made it
   convenient to edit it, maybe even linked to
   documentation for it, would be very nice.

(done) - I would like a setting which would save the file with the
  rst markup and make it easy to examine and edit.

- On the someday/maybe list would be a @publish
  feature, which configured a directory to ftp the rendered
  file to.
</t>
<t tx="ekr.20050805162550">&lt;&lt; docstring &gt;&gt;

# Original rst code by Josef Dalcolmo:
# contributed under the same licensed as Leo.py itself.
# rst3.py based on rst2.py v2.4.
# This has largely been superceded by leo.core.leoRst.

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;

bwm_file = None
if 0:
    bwm_file = open("bwm_file", "w")
controllers = {} # For use by @button rst3 code.

@others
</t>
<t tx="ekr.20050805162550.1">''' Creates output files from Leo outlines containing rST (reStructuredText)
markup. This plugin has been superseded by Leo's core rst3 command.

This is a powerful plugin with many options.  The full documentation is at:
http://leoeditor.com//rstplugin3.html

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu. This
command searches the selected outline looking for **rst root nodes** whose
headline have the form @rst &lt;filename&gt;. The plugin then creates the named file
in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically eliminates one of the most tedious
chores associated with rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

rst3 options control most aspects of this plugin's operations. You can set
options in @settings trees, in headlines and in body text. There are too many
details to discuss here. For full details see:
http://leoeditor.com//rstplugin3.html

'''
</t>
<t tx="ekr.20050805162550.10">def __init__ (self,c):

    global SilverCity
    self.c = c
    &lt;&lt; init ivars &gt;&gt;

    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
    self.addMenu()
</t>
<t tx="ekr.20050805162550.11">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.option_prefix = '@rst-option'

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.toplevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {}
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.defaultEncoding = 'utf-8'
self.leoDirectivesList = g.globalDirectiveList
self.encoding = self.defaultEncoding
self.ext = None # The file extension.
self.outputFileName = None # The name of the file being written.
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
</t>
<t tx="ekr.20050805162550.12">def addMenu (self):

    c = self.c
    editMenu = c.frame.menu.getMenu('Edit')

    def rst3PluginCallback (event=None):
        self.processTopTree(c.p)

    c.k.registerCommand('write-restructured-text', rst3PluginCallback)
    table = (
        ("-",None,None),
        # ("Write Restructed Text","",rst3PluginCallback),
        '&amp;write-restructured-text',
    )
    c.frame.menu.createMenuEntries(editMenu, table)
</t>
<t tx="ekr.20050805162550.13">def initOptionsFromSettings (self):
    '''Init all options from settings.'''
    c = self.c
    d = self.defaultOptionsDict
    for key in sorted(d.keys()):
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break
    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.error('No http_server_support: can not import mod_http plugin')
        self.setOption('http_server_support',False,tag='initOptionsFromSettings')
</t>
<t tx="ekr.20050805162550.16">def encode (self,s):

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20050805162550.17">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.toplevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.warning('No @rst nodes in selected tree')
    return None,None
</t>
<t tx="ekr.20050805162550.19">def underline (self,s,p):
    '''Return the underlining string to be used at the given level for string s.'''
    u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
    level = max(0,p.level()-self.toplevel)
    level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
    ch = u [level]
    n = max(4,len(s))
    return ch * n + '\n'
</t>
<t tx="ekr.20050805162550.2">from leo.core import leoGlobals as g

import html.parser as HTMLParser
import os
import pprint
import io
StringIO = io.StringIO
import sys

# Make sure the present directory in in sys.path.
dir,junk = os.path.split(__file__)
if dir not in sys.path: sys.path.append(dir)

try:
    from leo.plugins import mod_http
except ImportError:
    mod_http = None

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    # This message given in init.
    # g.pr('rst3 plugin: can not import docutils')
    docutils = None

try:
    import SilverCity
except ImportError:
    if '--silent' not in sys.argv and not g.unitTesting and not g.app.batchMode:
        g.pr('rst3 plugin: SilverCity not loaded')
    SilverCity = None
</t>
<t tx="ekr.20050805162550.20">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.blue('wrote: %s' % (name))
</t>
<t tx="ekr.20050805162550.21">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was ,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = g.os_path_finalize(theDir) # #1341.
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.error('did not create:',theDir)
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20050805162550.23">def writeTree(self,p):
    '''Write p's tree to self.outputFile.'''
    self.scanAllOptions(p)
    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))
    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p)
</t>
<t tx="ekr.20050805162550.26">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20050805162550.30">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20050805162550.33"></t>
<t tx="ekr.20050805162550.34"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.blue('html updated for http plugin')

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20050805162550.35">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20050805162550.36">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20050805162550.37">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file
            print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            pprint.pprint((p, attr), bwm_file)
        # http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            if bwm_file:
                print &gt;&gt; bwm_file, ( "relocate_references(3): line:",
                    line, "Column:", column, "href:", href,
                    "href_file:", href_file, "http_node_ref:", http_node_ref)
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                replacement = "%s#%s" % (http_node_ref,marker)
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,'href="%s"' % replacement)
                except Exception:
                    g.es("Skipped ", attr[line + 2])
            else:
                # filename = marker_parts [0]
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,
                        'href="%s"' % http_node_ref)
                except Exception:
                    g.es("Skipped", attr[line+2])
</t>
<t tx="ekr.20050805162550.38">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)
</t>
<t tx="ekr.20050805162550.39">@
The parser classes are used to construct the html code for nodes. The algorithm has two phases:
    1. In the first phase, the html code for each node is identified.
    2. The second phase identifies all links and checks if these links need to be modified.
The first phase of scanning is done by the anchor_hmlParserClass. The second phase of this algorithm is
done with the link_htmlParserClass.
@code

&lt;&lt; class linkAnchorParserClass &gt;&gt;

@others
</t>
<t tx="ekr.20050805162550.4"></t>
<t tx="ekr.20050805162550.40">class linkAnchorParserClass (HTMLParser.HTMLParser):

    '''
    A class to recognize anchors and links in HTML documents.
    A special marker is the "node_marker" which demarkates the border between
    node and the next.
    '''

    @others
</t>
<t tx="ekr.20050805162550.41">def __init__(self,rst):

    super().__init__()
    self.rst = rst

    # Set ivars from options.  This works only if we don't change nodes!
    self.node_begin_marker      = rst.getOption('node_begin_marker')
    self.clear_http_attributes  = rst.getOption('clear_http_attributes')
    self.current_file = rst.outputFileName
</t>
<t tx="ekr.20050805162550.42">def is_anchor(self, tag, attrs):
    """
    Check if the current tag is an anchor.
    Returns *all* anchors.
    Works with docutils 0.4
    """

    if tag == 'a':
        return True

    if self.is_node_marker(attrs):
        return True
    return tag == "span"
</t>
<t tx="ekr.20050805162550.43">def is_link(self, tag, attrs):
    '''
    Return True if tag, attrs is represents a link.
    '''

    if tag != 'a':
        return False

    result = 'href' in dict(attrs)
    return result
</t>
<t tx="ekr.20050805162550.44">class htmlParserClass (linkAnchorParserClass):

    '''
    The responsibility of the html parser is:
        1. Find out which html code belongs to which node.
        2. Keep a stack of open tags which apply to the current node.
        3. Keep a list of tags which should be included in the nodes, even
           though they might be closed.
           The &lt;style&gt; tag is one example of that.

    Later, we have to relocate inter-file links: if a reference to another location
    is in a file, we must change the link.

    '''

    @others
</t>
<t tx="ekr.20050805162550.45">def __init__ (self,rst):

    super().__init__(rst) # Init the base class.

    self.stack = None
    # The stack contains lists of the form:
        # [text1, text2, previous].
        # text1 is the opening tag
        # text2 is the closing tag
        # previous points to the previous stack element

    self.node_marker_stack = []
    # self.node_marker_stack.pop() returns True for a closing
    # tag if the opening tag identified an anchor belonging to a vnode.

    self.node_code = []
        # Accumulated html code.
        # Once the hmtl code is assigned a vnode, it is deleted here.

    self.deleted_lines = 0 # Number of lines deleted in self.node_code

    self.endpos_pending = False
    # Do not include self.node_code[0:self.endpos_pending] in the html code.

    self.last_position = None
    # Last position; we must attach html code to this node.

    self.last_marker = None
</t>
<t tx="ekr.20050805162550.46">def handle_starttag (self,tag,attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If it is an anchor, we check if this anchor marks the beginning of a new
       node
    3. If a new node begins, then we might have to store html code for the previous
       node.
    4. In any case, put the new tag on the stack.
    '''
    is_node_marker = False
    if self.is_anchor(tag,attrs) and self.is_node_marker(attrs):
        is_node_marker = self.is_node_marker(attrs)
        line, column = self.getpos()
        if self.last_position:
            lines = self.node_code [:]
            lines [0] = lines [0] [self.startpos:]
            del lines [line-self.deleted_lines-1:]
            mod_http.get_http_attribute(self.last_position).extend(lines)
            &lt;&lt; trace the unknownAttribute &gt;&gt;
        if self.deleted_lines &lt; line-1:
            del self.node_code [: line-1-self.deleted_lines]
            self.deleted_lines = line-1
            self.endpos_pending = True
    starttag = self.get_starttag_text()
    self.stack = [starttag, None, self.stack]
    self.node_marker_stack.append(is_node_marker)
</t>
<t tx="ekr.20050805162550.47">def handle_endtag(self, tag):
    '''
    1. Set the second element of the current top of stack.
    2. If this is the end tag for an anchor for a node,
       store the current stack for that node.
    '''
    self.stack[1] = "&lt;/" + tag + "&gt;"

    if self.endpos_pending:
        line, column = self.getpos()
        self.startpos = self.node_code[0].find("&gt;", column) + 1
        self.endpos_pending = False

    is_node_marker = self.node_marker_stack.pop()

    if is_node_marker and not self.clear_http_attributes:
        self.last_position = self.rst.http_map[is_node_marker]
        if is_node_marker != self.last_marker:
            if bwm_file: print &gt;&gt; bwm_file, "Handle endtag:", is_node_marker, self.stack
            mod_http.set_http_attribute(self.rst.http_map[is_node_marker], self.stack)
            self.last_marker = is_node_marker
            #bwm: last_marker is not needed?

    self.stack = self.stack[2]
</t>
<t tx="ekr.20050805162550.49">def feed(self, line):

    self.node_code.append(line)

    HTMLParser.HTMLParser.feed(self, line) # Call the base class's feed().
</t>
<t tx="ekr.20050805162550.5">def init ():
    '''Return True if the plugin has loaded successfully.'''
    ok = docutils is not None # Ok for unit testing.
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    else:
        g.error('rst3 plugin not loaded: can not load docutils')
    return ok
</t>
<t tx="ekr.20050805162550.50">class anchor_htmlParserClass (linkAnchorParserClass):

    '''
    This htmlparser does the first step of relocating: finding all the anchors within the html nodes.

    Each anchor is mapped to a tuple:
        (current_file, position).

    Filters out markers which mark the beginning of the html code for a node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.51">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
</t>
<t tx="ekr.20050805162550.52">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; (filename, p)
    '''
    if not self.is_anchor(tag, attrs):
        return

    if self.current_file not in self.anchor_map:
        self.anchor_map[self.current_file] = (self.current_file, self.p)
        simple_name = g.os_path_split(self.current_file)[1]
        self.anchor_map[simple_name] = self.anchor_map[self.current_file]
        if bwm_file: print &gt;&gt; bwm_file, (
            "anchor(1): current_file:", self.current_file,
            "position:", self.p,
            "Simple name:", simple_name,
        )
        # Not sure what to do here, exactly. Do I need to manipulate
        # the pathname?

    for name, value in attrs:
        if name == 'name' or tag == 'span' and name == 'id':
            if not value.startswith(self.node_begin_marker):
                if bwm_file: print &gt;&gt; bwm_file, "anchor(2):", value, self.p
                self.anchor_map[value] = (self.current_file, self.p.copy())
</t>
<t tx="ekr.20050805162550.53">class link_htmlparserClass (linkAnchorParserClass):

    '''This html parser does the second step of relocating links:
    1. It scans the html code for links.
    2. If there is a link which links to a previously processed file
       then this link is changed so that it now refers to the node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.54">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
    self.replacements = []
</t>
<t tx="ekr.20050805162550.55">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; p
        Update the list of replacements for the document.
    '''
    if bwm_file: print &gt;&gt; bwm_file, "Is link?", tag, attrs
    if not self.is_link(tag, attrs):
        return

    marker = self.node_begin_marker
    for name, value in attrs:
        if name == 'href':
            href = value
            href_parts = href.split("#")
            if len(href_parts) == 1:
                href_a = href_parts[0]
            else:
                href_a = href_parts[1]
            if bwm_file: print &gt;&gt; bwm_file, "link(1):", name, value, href_a
            if not href_a.startswith(marker):
                if href_a in self.anchor_map:
                    href_file, href_node = self.anchor_map[href_a]
                    http_node_ref = mod_http.node_reference(href_node)
                    line, column = self.getpos()
                    if bwm_file: print &gt;&gt; bwm_file, "link(2):", line, column, href, href_file, http_node_ref
                    self.replacements.append((line, column, href, href_file, http_node_ref))
</t>
<t tx="ekr.20050805162550.56">def get_replacements(self):

    return self.replacements
</t>
<t tx="ekr.20050805162550.6">def onCreate(tag, keywords):

    c = keywords.get('new_c') or keywords.get('c')
    if c:
        global controllers
        controllers[c] = rstClass(c)
        # Warning: Do not return anything but None here!
        # Doing so suppresses the loading of other 'new' or 'open2' hooks!
</t>
<t tx="ekr.20050805162550.8">class rstClass:

    '''A class to write rst markup in Leo outlines.'''

@ This plugin optionally stores information for the http plugin.

Each node can have one additional attribute, with the name rst_http_attributename, which is a list.

The first three elements are stack of tags, the rest is html code.

[&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure:
    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

    @others
</t>
<t tx="ekr.20050805162550.9"></t>
<t tx="ekr.20050806101253">def code_block (name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}

</t>
<t tx="ekr.20050806162146">@nocolor
@

- Specify option for the spelling of special doc parts.
    - The present code assumes to much about these commands.
- Warn if option gets set twice in same vnode.

Later or never:
    - show_context option.
    - encoding option: can override @encoding directives
    - Support docutils config files.

@c

@others
</t>
<t tx="ekr.20050807120331.1">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20050807120331.2">def scanNodeForOptions (self,p):
    '''
    Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.
    '''
    d = self.scanHeadlineForOptions(p)
    d2 = self.scanForOptionDocParts(p,p.b)
    # A fine point: body options over-ride headline options.
    d.update(d2)
    return d
</t>
<t tx="ekr.20050808064245">def createDefaultOptionsDict(self):

    # Warning: changing the names of options changes the names of the corresponding ivars.

    self.defaultOptionsDict = {
        # Http options...
        'rst3_clear_http_attributes':   False,
        'rst3_http_server_support':     False,
        'rst3_http_attributename':      'rst_http_attribute',
        'rst3_node_begin_marker':       'http-node-marker-',
        # Path options...
        'rst3_default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'rst3_stylesheet_name': 'default.css',
        'rst3_stylesheet_path': None, # Bug fix: must be None, not ''.
        'rst3_publish_argv_for_missing_stylesheets': None,
        # Global options...
        'rst3_code_block_string': '',
        'rst3_number_code_lines': True,
        'rst3_underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'rst3_verbose':True,
        'rst3_write_intermediate_file': False, # Used only if generate_rst is True.
        # Mode options...
        'rst3_code_mode': False, # True: generate rst markup from @code and @doc parts.
        'rst3_doc_only_mode': False, # True: generate only from @doc parts.
        'rst3_generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'rst3_generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'rst3_show_headlines': True,  # Can be set by @rst-no-head headlines.
        'rst3_show_organizer_nodes': True,
        'rst3_show_options_nodes': False,
        'rst3_show_sections': True,
        'rst3_strip_at_file_prefixes': True,
        'rst3_show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'rst3_show_doc_parts_as_paragraphs': False,
        'rst3_show_leo_directives': True,
        'rst3_show_markup_doc_parts': False,
        'rst3_show_options_doc_parts': False,
        # *Names* of headline commands...
        'rst3_code_prefix':             '@rst-code',     # Enter code mode.
        'rst3_doc_only_prefix':         '@rst-doc-only', # Enter doc-only mode.
        'rst3_rst_prefix':              '@rst',          # Enter rst mode.
        'rst3_ignore_headline_prefix':  '@rst-no-head',
        'rst3_ignore_headlines_prefix': '@rst-no-headlines',
        'rst3_ignore_node_prefix':      '@rst-ignore-node',
        'rst3_ignore_prefix':           '@rst-ignore',
        'rst3_ignore_tree_prefix':      '@rst-ignore-tree',
        'rst3_option_prefix':           '@rst-option',
        'rst3_options_prefix':          '@rst-options',
        'rst3_preformat_prefix':        '@rst-preformat',
        'rst3_show_headline_prefix':    '@rst-head',
    }
</t>
<t tx="ekr.20050808070018">def scanOption (self,p,s):
    '''
    Return { name:val } if s is a line of the form name=val.
    Otherwise return {}
    '''
    if not s.strip() or s.strip().startswith('..'):
        return {}
    data = self.parseOptionLine(s)
    if data:
        name,val = data
        fullName = 'rst3_' + self.munge(name)
        if fullName in self.defaultOptionsDict.keys():
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            return { self.munge(name): val }
        else:
            g.error('ignoring unknown option: %s' % (name))
            return {}
    else:
        g.trace(repr(s))
        g.error('bad rst3 option in %s: %s' % (p.h,s))
        return {}
</t>
<t tx="ekr.20050808070018.1">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20050808070018.2">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20050808072943">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = 3 if name.startswith('rst') else 0

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20050808072943.1">def parseOptionLine (self,s):
    '''
    Parse a line containing name=val and return (name,value) or None.
    If no value is found, default to True.
    '''
    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name:
        return None,'False'
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        return name,val
    else:
        return name,'True'
</t>
<t tx="ekr.20050808142313.28"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings()
        # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:]
        # Suppress inheritance of single-node options.
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        for key in d.keys():
            ivar = self.munge(key)
            if ivar not in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)
    # self.dumpSettings()
    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20050809074827"></t>
<t tx="ekr.20050809075309">def initWrite (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''
</t>
<t tx="ekr.20050809080031">def write (self,s):

    s = self.encode(s)

    self.outputFile.write(s)
</t>
<t tx="ekr.20050809080925">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20050809082854"></t>
<t tx="ekr.20050809082854.1">def writeToDocutils (self,s):
    '''
    Send s to docutils using the writer implied by self.ext and return the
    result.
    '''
    # openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    writer = None
    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.error('unknown docutils extension: %s' % (self.ext))
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n',path)
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20050810083057">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20050810083314"></t>
<t tx="ekr.20050810083856">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20050810103731">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20050811101550.1">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n')

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20050811102607">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20050811105438">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811105438.1">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811135526">def setOption (self,name,val,tag):

    ivar = self.munge(name)
    self.optionsDict [ivar] = val
</t>
<t tx="ekr.20050811150541">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
</t>
<t tx="ekr.20050811152104">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20050811153208">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
</t>
<t tx="ekr.20050811154552">def getDocPart (self,lines,n):

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20050811163802">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20050811173750">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,self.getOption('option_prefix')): # '@rst-option'
        s = h [len(self.option_prefix):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for prefix,ivar,val in (
            ('code_prefix','code_mode',True), # '@rst-code'
            ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
            ('default_path_prefix','default_prefix',''), # '@rst-default-path'
            ('rst_prefix','code_mode',False), # '@rst'
            ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
            ('show_headline_prefix','show_this_headline',True), # '@rst-head'
            ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
            ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
            ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
            ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
            ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
        ):
            prefix = self.getOption(prefix)
            if prefix and word == prefix: # Do _not_ munge this prefix!
                d = { ivar: val }
                if ivar != 'code_mode':
                    d ['code_mode'] = False # Enter rst mode.
                    d ['doc_only_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == self.getOption('rst_prefix'):
                    d ['ignore_this_headline'] = True
                return d

        if h.startswith('@rst'):
            g.trace('word',word,'rst_prefix',self.getOption('rst_prefix'))
            g.trace('unknown kind of @rst headline',p.h)

        return {}
</t>
<t tx="ekr.20050812120933">def dumpSettings (self):

    d = self.optionsDict
    keys = list(d.keys())
    keys.sort()

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20050812122236"></t>
<t tx="ekr.20050813083007">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        self.getOption('code_prefix'),
        self.getOption('doc_only_prefix'),
        self.getOption('default_path_prefix'),
        self.getOption('rst_prefix'),
        self.getOption('ignore_headline_prefix'),
        self.getOption('ignore_headlines_prefix'),
        self.getOption('ignore_node_prefix'),
        self.getOption('ignore_tree_prefix'),
        self.getOption('option_prefix'),
        self.getOption('options_prefix'),
        self.getOption('show_headline_prefix'),
        # # Suggested by Hemanth P.S.: prevent @file nodes from creating headings.
        # self.getOption('keep_at_file_prefix'),
        # self.getOption('strip_at_file_prefix'),
    ]
</t>
<t tx="ekr.20050813085236">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20050813155021">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20050813160208">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20050814134351">def getOption (self,name):

    bwm = False
    if bwm:
        g.trace("bwm: getOption self:%s, name:%s, value:%s" % (
            self, name, self.optionsDict.get(name)))

    return self.optionsDict.get(name)
</t>
<t tx="ekr.20050815091008.1">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20050815164715">def is_node_marker (self,attrs):
    '''
    Return the name of the anchor, if this is an anchor for the beginning of a node,
    False otherwise.
    '''

    d = dict(attrs)
    result = 'id' in d and d['id'].startswith(self.node_begin_marker)
    if result:
        return d['id']
    return result
</t>
<t tx="ekr.20050815164715.1">if 0:
    g.pr("rst3: unknownAttributes[self.http_attributename]")
    g.pr("For:", self.last_position)
    pprint.pprint(mod_http.get_http_attribute(self.last_position))
</t>
<t tx="ekr.20050817132814">@nocolor-node

Important: the rst3 plugin has largely been superceded by similar
commands built into Leo's core.

To activate the rst3 plugin, do the following:

1. Go to http://silvercity.sourceforge.net/.
- Follow the link 'SilverCity Releases'.
- Download the release that fits to your Python version.
- Double-klick on the downloaded file.

2. Go to http://docutils.sourceforge.net/.
- Have a look for item 'Download'
- Get, as the editor says, the latest snapshot by following the link
  'docutils-snapshot.tgz'.
- Make sure you have a application that can handle this format. 7zip is doing this great.
- Unpack it to a temporary folder.
- Open a console window, go to the temporary folder and type 'setup.py install'
  or '&lt;path_to_python.exe&gt;\python setup.py install'.

3. Start up Leo
- Check in the menu 'Edit' for item 'Write-Restructured-Text'.
</t>
<t tx="ekr.20051031040240" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">g.cls()
import os
if c.changed:
    c.save()
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
if 1:
    dir_ = os.path.join(g.app.loadDir, '..', '..')
    command = 'python -m leoserver --unittest'
elif 1:
    dir_ = os.path.join(g.app.loadDir, '..', '..')
    command = prolog + r"leo.core.leoserver leo\core\leoserver.py"
else: # Fails.
    dir = g.app.loadDir
    command = prolog + "leoserver leoserver.py"
os.chdir(dir_)
g.execute_shell_commands(command)
</t>
<t tx="ekr.20051104075904.10">def runTest(self, define_g=True):
    """Run a Leo GeneralTestCase test."""
    trace_time = False
    tm = self
    c = tm.c
    p = tm.p.copy()
    if trace_time:
        t1 = time.process_time()
    script = g.getScript(c, p).strip()
    if self.setup_script:
        script = self.setup_script + '\n' + script
    tm.assertTrue(script)
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True
    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c': c, 'g': g, 'p': p and p.copy()}
    if define_g:
        d = {'c': c, 'g': g, 'p': p and p.copy(), 'self': tm,}
    else:
        d = {'self': tm,}
    script = script + '\n'
    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        exec(compile(script, scriptFile, 'exec'), d)
    else:
        exec(script, d)
    if trace_time:
        t2 = time.process_time()
        if t2 - t1 &gt; 3.0:
            g.trace(f"\nEXCESSIVE TIME: {t2 - t1:5.2f} sec. in {self.p.h}")
</t>
<t tx="ekr.20051104075904.11">def shortDescription(self):
    s = self.p.h
    return s + '\n'
</t>
<t tx="ekr.20051104075904.5">class GeneralTestCase(unittest.TestCase):
    """Create a unit test from a snippet of code."""
    @others
</t>
<t tx="ekr.20051104075904.6">def __init__(self, c, p, setup_script=None):
    """Ctor for the GeneralTestCase class."""
    super().__init__()
    self.c = c
    self.p = p.copy()
    self.setup_script = setup_script
</t>
<t tx="ekr.20051104075904.7">def fail(self, msg=None):
    """Mark a unit test as having failed."""
    g.app.unitTestDict["fail"] = g.callers()
    raise self.failureException(msg)
        # Fix # 1002. Raise an exception, as in TestCase.fail()
</t>
<t tx="ekr.20051104075904.70">class EditBodyTestCase(unittest.TestCase):
    """Data-driven unit tests for Leo's edit body commands."""
    @others
</t>
<t tx="ekr.20051104075904.71">def __init__(self, c, parent, before, after, sel, ins, tempNode):

    super().__init__()
    self.c = c
    self.failFlag = False
    self.parent = parent.copy()
    self.before = before.copy()
    self.after = after.copy()
    self.sel = sel and sel.copy()
        # Two lines giving the selection range in tk coordinates.
    self.ins = ins and ins.copy()
        # One line giving the insert point in tk coordinate.
    self.tempNode = tempNode.copy()
</t>
<t tx="ekr.20051104075904.72">def fail(self, msg=None):
    """Mark a unit test as having failed."""
    g.app.unitTestDict["fail"] = g.callers()
    self.failFlag = True
</t>
<t tx="ekr.20051104075904.73">def editBody(self):
    c = self.c
    tm = self.c.testManager
    # Blank stops the command name.
    commandName = self.parent.h
    i = commandName.find(' ')
    if i &gt; -1:
        commandName = commandName[:i]
    # Compute the result in tempNode.b
    command = getattr(c, commandName)
    command()
    try:
        # Don't call the Undoer if we expect no change.
        if not tm.compareOutlines(
            self.before, self.after, compareHeadlines=False, report=False):
            assert tm.compareOutlines(
                self.tempNode,
                self.after,
                compareHeadlines=False), f"{commandName}: before undo1"
            c.undoer.undo()
            assert tm.compareOutlines(
                self.tempNode,
                self.before,
                compareHeadlines=False), f"{commandName}: after undo1"
            c.undoer.redo()
            assert tm.compareOutlines(
                self.tempNode,
                self.after,
                compareHeadlines=False), f"{commandName}: after redo"
            c.undoer.undo()
            assert tm.compareOutlines(
                self.tempNode,
                self.before,
                compareHeadlines=False), f"{commandName}: after undo2"
    except Exception:
        self.fail()
        raise
</t>
<t tx="ekr.20051104075904.74">def runTest(self):
    self.editBody()
</t>
<t tx="ekr.20051104075904.75">def setUp(self):
    c = self.c; tempNode = self.tempNode
    c.undoer.clearUndoState()
    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()
    text = self.before.b
    tempNode.setBodyString(text)
    c.selectPosition(self.tempNode)
    w = c.frame.body.wrapper
    if self.sel:
        s = str(self.sel.b)  # Can't be unicode.
        lines = s.split('\n')
        w.setSelectionRange(lines[0], lines[1])
    if self.ins:
        s = str(self.ins.b)  # Can't be unicode.
        lines = s.split('\n')
        g.trace(lines)
        w.setInsertPoint(lines[0])
    if not self.sel and not self.ins:  # self.sel is a **tk** index.
        w.setInsertPoint(0)
        w.setSelectionRange(0, 0)
</t>
<t tx="ekr.20051104075904.76">def tearDown(self):
    c = self.c; tempNode = self.tempNode
    c.selectPosition(tempNode)
    if not self.failFlag:
        tempNode.setBodyString("")
        # Delete all children of temp node.
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()
    tempNode.clearDirty()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20051104075904.79">class ImportExportTestCase(unittest.TestCase):
    """Data-driven unit tests for Leo's edit body commands."""
    @others
</t>
<t tx="ekr.20051104075904.8">def setUp(self):
    c = self.c
    oldChanged = c.changed
    c.selectPosition(self.p.copy())
    if not oldChanged:
        c.clearChanged()
</t>
<t tx="ekr.20051104075904.80">def __init__(self, c, p, dialog, temp_p, doImport):

    super().__init__()
    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()
    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport
    self.old_p = c.p
</t>
<t tx="ekr.20051104075904.81">def fail(self, msg=None):
    """Mark a unit test as having failed."""
    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20051104075904.82">def importExport(self):
    c = self.c; p = self.p
    g.app.unitTestDict = {'c': c, 'g': g, 'p': p and p.copy()}
    commandName = p.h
    command = getattr(c, commandName)  # Will fail if command does not exist.
    command(event=None)
    failedMethod = g.app.unitTestDict.get("fail")
    self.assertFalse(failedMethod, failedMethod)
</t>
<t tx="ekr.20051104075904.83">def runTest(self):
    # """Import Export Test Case"""
    self.importExport()
</t>
<t tx="ekr.20051104075904.84">def setUp(self):

    c = self.c; temp_p = self.temp_p
    d = self.dialog
    assert(d)
    temp_p.setBodyString('')
    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    child.h = "import/export test: " + self.p.h
    c.selectPosition(child)
    # Get the dialog name and the fileName from the dialog node.
    # This is used below to set up the dialog dict for NullGui.simulateDialog.
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]
    # Replace '\\' by os.path.sep in fileName
    fileName = fileName.replace('\\', os.path.sep)
    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir, "..", fileName)
    # Set the dict for UnitTestGui, a subclass of NullGui.
    # NullGui.simulateDialog uses this dict to return values for dialogs.
    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}
    self.oldGui = g.app.gui
    self.gui = leoGui.UnitTestGui(theDict)
</t>
<t tx="ekr.20051104075904.85">def shortDescription(self):
    try:
        return f"ImportExportTestCase: {self.p.h} {self.fileName}"
    except Exception:
        return "ImportExportTestCase"
</t>
<t tx="ekr.20051104075904.86">def tearDown(self):
    c = self.c; temp_p = self.temp_p
    if self.gui:
        self.gui.destroySelf()
        self.gui = None
    temp_p.setBodyString("")
    temp_p.clearDirty()
    if 1:  # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()
    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
</t>
<t tx="ekr.20051104075904.9">def tearDown(self):
    # Restore the outline.
    self.c.outerUpdate()
</t>
<t tx="ekr.20051121102358">def processTopTree (self,p,justOneFile=False):

    current = p.copy()
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,
                ext=None,
                toString=False,
                justOneFile=justOneFile,
            )
            break
    else:
        self.processTree(current,
            ext=None,
            toString=False,
            justOneFile=justOneFile,
        )
    g.blue('done')
</t>
<t tx="ekr.20051202070028">def computeOutputFileName (self,fileName):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')
    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fileName)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fileName)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fileName)
    else:
        path = g.os_path_finalize_join(fileName)

    return path
</t>
<t tx="ekr.20051204070141">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20060127165509"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):
    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if id(o) not in lastObjectsDict]
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)] = o
    dicts = 0; seqs = 0
    i = 0; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if isinstance(o, dict):
            dicts += 1
        elif isinstance(o, (list, tuple)):
            #g.pr(id(o),repr(o))
            seqs += 1
        #else:
        #    g.pr(o)
        i += 1
    g.pr('=' * 40)
    g.pr(f"dicts: {dicts}, sequences: {seqs}")
    g.pr(f"{tag}: {len(newObjects)} new, {len(objects)} total objects")
    g.pr('-' * 40)
</t>
<t tx="ekr.20060202161935">def printGcAll(full=False, sort_by_n=True):
    """Print a summary of all presently live objects."""
    if g.unitTesting:
        return
    t1 = time.process_time()
    objects = gc.get_objects()
    d = {}  # Keys are types, values are ints (number of instances).
    for obj in objects:
        t = type(obj)
        if hasattr(obj, '__class__'):
            d[t] = d.get(t, 0) + 1
    t2 = time.process_time()
    if full:
        if sort_by_n:  # Sort by n
            items = list(d.items())
            items.sort(key=lambda x: x[1])
            for z in reversed(items):
                print(f"{z[1]:8} {z[0]}")
        else:  # Sort by type
            g.printObj(d)
    #
    # Summarize
    print(
        f"\n"
        f"printGcAll: {len(objects):d} objects "
        f"in {t2-t1:5.2f} sec. ")
</t>
<t tx="ekr.20060525102337">def writeNodeToString (self,p=None,ext=None):
    '''
    Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.
    '''
    c = self.c
    current = p or c.p
    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20060608094815">def handleDocOnlyMode (self,p,lines):
    '''
    Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.
    '''
    # ignore            = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')
    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20060608094815.1">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20060608102001">def writeHeadlineHelper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the
    i = g.skip_id(h,0,chars='@-')
    word = h [:i]
    if word:
        # Never generate a section for @rst-option or @rst-options.
        if word in (self.getOption('option_prefix'),self.getOption('options_prefix')):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write('%s\n%s\n' % (h,self.underline(h,p)))
        else:
            self.write('\n%s\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20060610104435">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20060928062431">@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
</t>
<t tx="ekr.20061008140603">def runEditCommandTest(self, p):
    tm = self
    c = self.c
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, f"no command: {commandName}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    # pylint: disable=unbalanced-tuple-unpacking
    sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    ### g.trace(commandName, sel1[0], sel1[1])
    ### g.printObj(g.splitLines(w.getSelectedText()))
    c.k.simulateCommand(commandName)
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    if 0:  # Be more permissive.
        if sel2 != sel3:
            print(f"\n{p.h}\nexpected: {sel2_orig} = {sel2}, got: {sel3}")
    else:
        message = f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
        assert sel2 == sel3, message
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20061031131434.10">@ac_cmd('auto-complete-force')
def autoCompleteForce(self, event=None):
    """Show autocompletion, even if autocompletion is not presently enabled."""
    return self.autoComplete(event, force=True)
</t>
<t tx="ekr.20061031131434.100">def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars(self):
    """Set ivars for special keystrokes from previously-existing bindings."""
    c, k = self.c, self
    warn = c.config.getBool('warn-about-missing-settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for bi in aList:
                if bi.pane == pane:
                    setattr(k, ivar, bi.stroke)
                    found = True; break
        if not found and warn:
            g.trace(f"no setting for {commandName}")
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict(self):
    """Add bindings for all entries in c.commandsDict."""
    c, k = self.c, self
    d = c.commandsDict
    #
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bi with bi.stroke == stroke.
    d2 = g.TypedDict(  # was TypedDictOfLists.
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for bi in aList:
            # Important: bi.stroke is already canonicalized.
            stroke = bi.stroke
            bi.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add_to_list(stroke, bi)
    #
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for bi in aList2:
            commandName = bi.commandName
            command = c.commandsDict.get(commandName)
            tag = bi.kind
            pane = bi.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.108">def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) &lt; 32 or ord(ch) &gt; 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
</t>
<t tx="ekr.20061031131434.11">def auto_completer_state_handler(self, event):
    """Handle all keys while autocompleting."""
    c, k, tag = self.c, self.k, 'auto-complete'
    state = k.getState(tag)
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    is_plain = k.isPlainKey(stroke)
    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag, 1, handler=self.auto_completer_state_handler)
        else:
            self.exit()
    elif ch in ('\n', 'Return'):
        self.exit()
    elif ch == 'Escape':
        self.exit()
    elif ch in ('\t', 'Tab'):
        self.compute_completion_list()
    elif ch in ('\b', 'BackSpace'):
        self.do_backspace()
    elif ch == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif ch == '?':
        self.info()
    elif ch == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = 'ON' if self.verbose else 'OFF'
        message = f"verbose completions {kind}"
        g.es_print(message)
        # This doesn't work because compute_completion_list clears the autocomplete tab.
        # self.put('', message, tabName=self.tabName)
        # This is almost invisible: the fg='red' is not honored.
        c.frame.putStatusLine(message, fg='red')
        self.compute_completion_list()
    # elif ch == 'Down' and hasattr(self,'onDown'):
        # self.onDown()
    # elif ch == 'Up' and hasattr(self,'onUp'):
        # self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch)
    elif stroke == k.autoCompleteForceKey:
        # This is probably redundant because completions will exist.
        # However, it doesn't hurt, and it may be useful rarely.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            self.show_completion_list(common_prefix, prefix, tabList)
        else:
            g.warning('No completions')
            self.exit()
    else:
        self.abort()
        return 'do-standard-keys'
    return None
</t>
<t tx="ekr.20061031131434.111">@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state &gt; 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.119">@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '&lt;no hash&gt;'
            data.append((s1, s2, s3, s4),)
    # Print keys by type.
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
</t>
<t tx="ekr.20061031131434.12">@ac_cmd('disable-autocompleter')
def disableAutocompleter(self, event=None):
    """Disable the autocompleter."""
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

@ac_cmd('disable-calltips')
def disableCalltips(self, event=None):
    """Disable calltips."""
    self.k.enable_calltips = False
    self.showCalltipsStatus()

@ac_cmd('enable-autocompleter')
def enableAutocompleter(self, event=None):
    """Enable the autocompleter."""
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

@ac_cmd('enable-calltips')
def enableCalltips(self, event=None):
    """Enable calltips."""
    self.k.enable_calltips = True
    self.showCalltipsStatus()

@ac_cmd('toggle-autocompleter')
def toggleAutocompleter(self, event=None):
    """Toggle whether the autocompleter is enabled."""
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

@ac_cmd('toggle-calltips')
def toggleCalltips(self, event=None):
    """Toggle whether calltips are enabled."""
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
</t>
<t tx="ekr.20061031131434.121">@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
</t>
<t tx="ekr.20061031131434.123">@cmd('set-command-state')
def setCommandState(self, event):
    """Enter the 'command' editing state."""
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    """Enter the 'insert' editing state."""
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    """Enter the 'overwrite' editing state."""
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName(self, w, commandName):
    """
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    """
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), (commandName, stroke.__class__.__name__)
    shortcut = stroke.s
    shortcut = g.checkUnicode(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = f"no shortcut for {commandName}"
        if g.app.unitTesting:
            raise AttributeError(message)
        g.error(message)
</t>
<t tx="ekr.20061031131434.127">def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20061031131434.13">@ac_cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.130">@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
</t>
<t tx="ekr.20061031131434.131">def registerCommand(self, commandName, func,
    allowBinding=False,
    pane='all',
    shortcut=None,  # Must be None unless allowBindings is True.
    ** kwargs
):
    """
    Make the function available as a minibuffer command.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.
    
    Ignore the 'shortcut' arg unless 'allowBinding' is True.
    
    Only k.bindOpenWith and the mod_scripting.py plugin should set
    allowBinding.
    """
    c, k = self.c, self
    if not func:
        g.es_print('Null func passed to k.registerCommand\n', commandName)
        return
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '-&gt;', func)
    c.commandsDict[commandName] = func
    # Warn about deprecated arguments.
    if shortcut and not allowBinding:
        g.es_print('The "shortcut" keyword arg to k.registerCommand will be ignored')
        g.es_print('Called from', g.callers())
        shortcut = None
    for arg, val in kwargs.items():
        if val is not None:
            g.es_print(f'The "{arg}" keyword arg to k.registerCommand is deprecated')
            g.es_print('Called from', g.callers())
    # Make requested bindings, even if a warning has been given.
    # This maintains strict compatibility with existing plugins and scripts.
    k.registerCommandShortcut(
        commandName=commandName,
        func=func,
        pane=pane,
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.133">def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
</t>
<t tx="ekr.20061031131434.135"># def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.14">@ac_cmd('show-calltips-force')
def showCalltipsForce(self, event=None):
    """Show the calltips at the cursor, even if calltips are not presently enabled."""
    return self.showCalltips(event, force=True)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k = self.c, self
    # Setup...
    if trace:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    # Handle the character given by event *without*
    # executing any command that might be bound to it.
    c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.15">def showAutocompleterStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"autocompleter {'On' if k.enable_autocompleter else 'Off'}"
        g.red(s)

def showCalltipsStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"calltips {'On'}" if k.enable_calltips else 'Off'
        g.red(s)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
</t>
<t tx="ekr.20061031131434.158">def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode&lt;{modeName}&gt;",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
</t>
<t tx="ekr.20061031131434.16"></t>
<t tx="ekr.20061031131434.160">def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.163">def initMode(self, event, modeName):

    k = self; c = k.c
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    k.modeBindingsDict = d
    bi = d.get('*command-prompt*')
    prompt = bi.kind if bi else modeName
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for bi in aList:
            commandName = bi.commandName
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
</t>
<t tx="ekr.20061031131434.165">@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for bi in aList:
            shortcutList = k.bindingsDict.get(bi.commandName, [])
                # Bug fix: 2017/03/26.
            bi_list = k.bindingsDict.get(
                stroke, g.BindingInfo(kind='dummy', pane='all'))
                # Important: only bi.pane is required below.
            for bi in bi_list:
                pane = f"{bi.pane}:"
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[bi.commandName] = shortcutList
    return d
</t>
<t tx="ekr.20061031131434.179">def getStrokeForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke, aList in k.bindingsDict.items():
            for bi in aList:
                if bi.commandName == commandName:
                    return stroke
    return None
</t>
<t tx="ekr.20061031131434.18">def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey(self, stroke):
    """Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key."""
    if not stroke:
        return False
    if not g.isStroke(stroke):
        # Happens during unit tests.
        stroke = g.KeyStroke(stroke)
    #
    # altgr combos (Alt+Ctrl) are always plain keys
    # g.KeyStroke does not handle this, because it has no "c" ivar.
    #
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return True
    return stroke.isPlainKey()
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState(self):
    """Clear the key handler state."""
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler(self):
    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind(self):
    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
</t>
<t tx="ekr.20061031131434.199">def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.20">def calltip(self):
    """Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    """
    obj, prefix = self.get_object()
    if obj:
        self.calltip_success(prefix, obj)
    else:
        self.calltip_fail(prefix)
    self.exit()
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list(self):
    """Return the autocompleter completion list."""
    prefix = self.get_autocompleter_prefix()
    key, options = self.get_cached_options(prefix)
    if not options:
        options = self.get_completions(prefix)
    tabList, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    if not common_prefix:
        tabList, common_prefix = g.itemsMatchingPrefixInList(
            prefix, options, matchEmptyPrefix=True)
    if tabList:
        self.show_completion_list(common_prefix, prefix, tabList)
    return common_prefix, prefix, tabList
</t>
<t tx="ekr.20061031131434.29">def do_backspace(self):
    """Delete the character and recompute the completion list."""
    c, w = self.c, self.w
    c.bodyWantsFocusNow()
    i = w.getInsertPoint()
    if i &lt;= 0:
        self.exit()
        return
    w.delete(i - 1, i)
    w.setInsertPoint(i - 1)
    if i &lt;= 1:
        self.exit()
    else:
        # Update the list. Abort if there is no prefix.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if not prefix:
            self.exit()
</t>
<t tx="ekr.20061031131434.31">def insert_string(self, s, select=False):
    """
    Insert an auto-completion string s at the insertion point.
    
    Leo 6.4. This *part* of auto-completion is no longer undoable.
    """
    c, w = self.c, self.w
    if not g.isTextWrapper(w):
        return
    c.widgetWantsFocusNow(w)
    #
    # Don't make this undoable.
        # oldText = w.getAllText()
        # oldSel = w.getSelectionRange()
        # bunch = u.beforeChangeBody(p)
    i = w.getInsertPoint()
    w.insert(i, s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i, j, insert=j)
    #
    # Don't make this undoable.
        # if 0:
            # u.doTyping(p, 'Typing',
                # oldSel=oldSel,
                # oldText=oldText,
                # newText=w.getAllText(),
                # newInsert=w.getInsertPoint(), 
                # newSel=w.getSelectionRange())
        # else:
            # u.afterChangeBody(p, 'auto-complete', bunch)
    if self.use_qcompleter and self.qw:
        c.widgetWantsFocusNow(self.qw.leo_qc)
</t>
<t tx="ekr.20061031131434.38">def info(self):
    """Show the docstring for the present completion."""
    c = self.c
    obj, prefix = self.get_object()
    c.frame.log.clearTab('Info', wrap='word')
    put = lambda s: self.put('', s, tabName='Info')
    put(prefix)
    try:
        argspec = inspect.getargspec(obj)
        # uses None instead of empty list
        argn = len(argspec.args or [])
        defn = len(argspec.defaults or [])
        put("args:")
        simple_args = argspec.args[: argn - defn]
        if not simple_args:
            put('    (none)')
        else:
            put('    ' + ', '.join(' ' + i for i in simple_args))
        put("keyword args:")
        if not argspec.defaults:
            put('    (none)')
        for i in range(defn):
            arg = argspec.args[-defn + i]
            put(f"    {arg} = {repr(argspec.defaults[i])}")
        if argspec.varargs:
            put("varargs: *" + argspec.varargs)
        if argspec.keywords:
            put("keywords: **" + argspec.keywords)
        put('\n')  # separate docstring
    except TypeError:
        put('\n')  # not a callable
    doc = inspect.getdoc(obj)
    put(doc if doc else "No docstring for " + repr(prefix))
</t>
<t tx="ekr.20061031131434.39">def insert_general_char(self, ch):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    k, w = self.k, self.w
    if g.isWordChar(ch):
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) &gt; len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            if trace: g.trace('extend', repr(extend))
            w.insert(ins, extend)
        return
    if ch == '(' and k.enable_calltips:
        # This calls self.exit if the '(' is valid.
        self.calltip()
    else:
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        self.exit()
</t>
<t tx="ekr.20061031131434.4">class AutoCompleterClass:
    """A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    """
    @others
</t>
<t tx="ekr.20061031131434.46">def start(self, event):
    """Init the completer and start the state handler."""
    # We don't need to clear this now that we don't use ContextSniffer.
    c = self.c
    if c.config.getBool('use-jedi', default=True):
        self.completionsDict = {}
    if self.use_qcompleter:
        self.init_qcompleter(event)
    else:
        self.init_tabcompleter(event)
</t>
<t tx="ekr.20061031131434.5">def __init__(self, k):
    """Ctor for AutoCompleterClass class."""
    # Ivars...
    self.c = k.c
    self.k = k
    self.force = None
    self.language = None
    self.namespaces = []
        # additional namespaces to search for objects, other code
        # can append namespaces to this to extend scope of search
    self.qw = None
        # The object that supports qcompletion methods.
    self.tabName = None
        # The name of the main completion tab.
    self.verbose = False
        # True: print all members, regardless of how many there are.
    self.w = None
        # The widget that gets focus after autocomplete is done.
    self.warnings = {}
        # Keys are language names.
    # Codewise pre-computes...
    self.codewiseSelfList = []
        # The (global) completions for "self."
    self.completionsDict = {}
        # Keys are prefixes, values are completion lists.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.auto_tab = c.config.getBool('auto-tab-complete', True)
    self.forbid_invalid = c.config.getBool('forbid-invalid-completions', False)
    self.use_jedi = c.config.getBool('use-jedi', False)
    self.use_qcompleter = c.config.getBool('use-qcompleter', False)
        # True: show results in autocompleter tab.
        # False: show results in a QCompleter widget.
</t>
<t tx="ekr.20061031131434.74">class KeyHandlerClass:
    """
    A class to support emacs-style commands.
    c.k is an instance of this class.
    """
    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__(self, c):
    """Create a key handler for c."""
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.killedBindings = []
        # A list of commands whose bindings have been set to None in the local file.
    self.replace_meta_with_alt = False
        # True: (Mac only) swap Meta and Alt keys.
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.reloadSettings()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None  # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
</t>
<t tx="ekr.20061031131434.78">def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
</t>
<t tx="ekr.20061031131434.79">def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
</t>
<t tx="ekr.20061031131434.8"></t>
<t tx="ekr.20061031131434.80">def finishCreate(self):
    """
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    """
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
        # Important: This must be called this now,
        # even though LM.laod calls g.app.makeAllBindings later.
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
</t>
<t tx="ekr.20061031131434.9">@ac_cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
</t>
<t tx="ekr.20061031131434.92">def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.95">def checkBindings(self):
    """
    Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course."""
    k = self; c = k.c
    if not c.config.getBool('warn-about-missing-settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace(f"No shortcut for abbrev {name} -&gt; {abbrev} = {key}")
            else:
                g.trace(f"No shortcut for {name} = {key}")
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget(self, w):
    """Make all a master gui binding for widget w."""
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings(self):
    """Make all key bindings in all of Leo's panes."""
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass  # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
</t>
<t tx="ekr.20061031170011.10">def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel(self, event):
    """
    Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.
    """
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
</t>
<t tx="ekr.20061031170011.7">def resetLabel(self):
    """Reset the minibuffer label."""
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label=f"{state.capitalize()} State")
</t>
<t tx="ekr.20061031170011.8">def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061101071425">def oops(self):

    g.trace('Should be defined in subclass:', g.callers(4))
</t>
<t tx="ekr.20061212084717">class LeoFind:
    """The base class for Leo's Find commands."""
    @others
</t>
<t tx="ekr.20070115135502">def writeScriptFile(self, script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script-file-path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = g.os_path_finalize_join(*allParts)  # #1431
    else:
        path = g.os_path_finalize_join(g.app.homeLeoDir, 'scriptFile.py')  # #1431
    #
    # Write the file.
    try:
        with open(path, encoding='utf-8', mode='w') as f:
            f.write(script)
    except Exception:
        g.es_exception()
        g.es(f"Failed to write script to {path}")
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script-file-path'))
        path = None
    return path
</t>
<t tx="ekr.20070130115927.6">@frame_cmd('cut-text')
def cutText(self, event=None):
    """Invoked from the mini-buffer and from shortcuts."""
    f = self; c = f.c; w = event and event.widget
    if not w or not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i, j = w.getSelectionRange()
    # Update the widget and set the clipboard text.
    s = w.get(i, j)
    if i != j:
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    else:
        ins = w.getInsertPoint()
        i, j = g.getLine(oldText, ins)
        s = w.get(i, j)
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut', oldSel=oldSel)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        # 2011/11/14: Not used at present.
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070130115927.7">@frame_cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    """
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    """
    c = self.c
    w = event and event.widget
    wname = c.widget_name(w)
    if not w or not g.isTextWrapper(w):
        return
    if self.cursorStay and wname.startswith('body'):
        tCurPosition = w.getInsertPoint()
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    if middleButton and c.k.previousSelection is not None:
        start, end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = g.app.gui.getTextFromClipboard()
    s = g.checkUnicode(s)
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
    # Save the horizontal scroll position.
    if hasattr(w, 'getXScrollPosition'):
        x_pos = w.getXScrollPosition()
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    w.see(i + len(s) + 2)
    if wname.startswith('body'):
        if self.cursorStay:
            if tCurPosition == j:
                offset = len(s) - (j - i)
            else:
                offset = 0
            newCurPosition = tCurPosition + offset
            w.setSelectionRange(i=newCurPosition, j=newCurPosition)
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif singleLine:
        s = w.getAllText()
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else:
        pass
    # Never scroll horizontally.
    if hasattr(w, 'getXScrollPosition'):
        w.setXScrollPosition(x_pos)

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict(self):
    """Dump k.masterBindingsDict."""
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            bi = d2.get(key2)
            g.pr(f"{key2:20} {bi.commandName}")
</t>
<t tx="ekr.20070613133500">def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
</t>
<t tx="ekr.20070713075352">def scanUnknownFileType(self, s, p, ext):
    """Scan the text of an unknown file type."""
    body = ''
    if ext in ('.html', '.htm'): body += '@language html\n'
    elif ext in ('.txt', '.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += f"@language {language}\n"
    self.setBodyString(p, body + self.rootLine + s)
    for p in p.self_and_subtree():
        p.clearDirty()
    g.app.unitTestDict = {'result': True}
    return True
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 &amp; #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20071015110830">def initCodeBlockString(self,p):

    # New in Leo 4.4.4: do this here, not in initWrite:
    c = self.c
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None:
        language = 'python'
    else:
        language = language.lower()
    syntax = SilverCity is not None
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n' % language.title()
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n'
</t>
<t tx="ekr.20071105164407">def deleteUnvisitedNodes(self, root, redraw=True):
    """
    Delete unvisited nodes in root's subtree, not including root.

    Before Leo 5.6: Move unvisited node to be children of the 'Resurrected
    Nodes'.
    """
    at = self
    # Find the unvisited nodes.
    aList = [z for z in root.subtree() if not z.isVisited()]
    if aList:
        # new-read: Never create resurrected nodes.
            # r = at.createResurrectedNodesNode()
            # callback = at.defineResurrectedNodeCallback(r, root)
            # # Move the nodes using the callback.
            # at.c.deletePositionsInList(aList, callback)
        at.c.deletePositionsInList(aList, redraw=redraw)
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071115061253">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''
    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')
    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20071212104050">def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            bi = d2.get(key2)
            if bi.commandName == commandName:
                bi.func = func
                d2[key2] = bi
</t>
<t tx="ekr.20080408060320.790">def selectAll(self):
    """Select all the user-editable text of the minibuffer."""
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
</t>
<t tx="ekr.20080408060320.791">def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080416161551.190">def __init__(self,
    v: "VNode",
    childIndex: int = 0,
    stack: List[Tuple["VNode", int]] = None
):
    """Create a new position with the given childIndex and parent stack."""
    self._childIndex: int = childIndex
    self.v: "VNode" = v
    # Stack entries are tuples (v, childIndex).
    if stack:
        self.stack = stack[:]  # Creating a copy here is safest and best.
    else:
        self.stack = []
    g.app.positions += 1
</t>
<t tx="ekr.20080416161551.206">def moveToNthChild(self, n: int):
    p = self
    if p.v and len(p.v.children) &gt; n:
        p.stack.append((p.v, p._childIndex),)
        p.v = p.v.children[n]
        p._childIndex = n
    else:
        # mypy rightly doesn't like setting p.v to None.
        # Leo's code must use the test `if p:` as appropriate.
        p.v = None  # type: ignore
    return p
</t>
<t tx="ekr.20080416161551.207">def moveToParent(self):
    """Move a position to its parent position."""
    p = self
    if p.v and p.stack:
        p.v, p._childIndex = p.stack.pop()
    else:
        # mypy rightly doesn't like setting p.v to None.
        # Leo's code must use the test `if p:` as appropriate.
        p.v = None  # type: ignore
    return p
</t>
<t tx="ekr.20080416161551.211">def moveToVisNext(self, c: Cmdr):
    """Move a position to the position of the next visible node."""
    p = self
    limit, limitIsVisible = c.visLimit()
    while p:
        if p.hasChildren():
            if p.isExpanded():
                p.moveToFirstChild()
            else:
                p.moveToNodeAfterTree()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if limit and self.checkVisNextLimit(limit, p):
                return None
            if p.isVisible(c):
                return p
    return p
</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home',  # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',  # 2011/06/07
        'set-find-node-only',  # 2011/06/07
        'set-find-suboutline-only',  # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510153327.2">def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    k.setInputState(state)
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines &amp; its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080709062932.10">def runTest(self, define_g=True):
    """AtShadowTestCase.runTest."""
    x = self.shadowController
    x.trace = self.trace
    p = self.p.copy()
    results = x.propagate_changed_lines(
        self.new_public_lines, self.old_private_lines, self.marker, p=p)
    if results != self.expected_private_lines:
        g.pr(p.h)
        for aList, tag in (
            (results, 'results'),
            (self.expected_private_lines, 'expected_private_lines')
        ):
            g.pr(f"{tag}...")
            for i, line in enumerate(aList):
                g.pr(f"{i:3} {line!r}")
            g.pr('-' * 40)
        assert results == self.expected_private_lines
    assert self.ok
    return self.ok
</t>
<t tx="ekr.20080709062932.11">def shortDescription(self):
    """AtShadowTestCase.shortDescription."""
    return self.p.h if self.p else '@test-shadow: no self.p'
</t>
<t tx="ekr.20080709062932.19">def findNode(self, c, p, headline):
    """Return the node in p's subtree with given headline."""
    p = g.findNodeInTree(c, p, headline)
    if not p:
        g.es_print('can not find', headline)
        assert False
    return p
</t>
<t tx="ekr.20080709062932.2">class AtShadowTestCase(unittest.TestCase):
    """
    Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.
    """
    @others
</t>
<t tx="ekr.20080709062932.20">def createSentinelNode(self, root, p):
    """Write p's tree to a string, as if to a file."""
    h = p.h
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2
</t>
<t tx="ekr.20080709062932.21">def makePrivateLines(self, p):
    """Return a list of the lines of p containing sentinels."""
    at = self.c.atFileCommands
    # A hack: we want to suppress gnx's *only* in @+node sentinels,
    # but we *do* want sentinels elsewhere.
    at.at_shadow_test_hack = True
    try:
        s = at.atFileToString(p, sentinels=True)
    finally:
        at.at_shadow_test_hack = False
    return g.splitLines(s)
</t>
<t tx="ekr.20080709062932.22">def makePublicLines(self, lines):
    """Return the public lines in lines."""
    x = self.shadowController
    lines, junk = x.separate_sentinels(lines, x.marker)
    return lines
</t>
<t tx="ekr.20080709062932.23">def mungePrivateLines(self, lines, find, replace):
    """Change the 'find' the 'replace' pattern in sentinel lines."""
    x = self.shadowController
    marker = self.marker
    i, results = 0, []
    while i &lt; len(lines):
        line = lines[i]
        if marker.isSentinel(line):
            new_line = line.replace(find, replace)
            results.append(new_line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i &lt; len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
        i += 1
    return results
</t>
<t tx="ekr.20080709062932.6">def __init__(self, c, p, shadowController, delims=None, trace=False):
    """Ctor for AtShadowTestCase class."""
    super().__init__()
    self.c = c
    self.p = p.copy()
    self.shadowController = x = shadowController
    self.trace = trace
    # Hard value for now.
    if delims is None:
        delims = '#', '', ''
    self.marker = x.marker = shadowController.Marker(delims)
        # 2015/04/03: tricky: set *both* ivars.
        # This bug became apparent because unitTest.leo no longer
        # pre-loads any @shadow files.
    # For teardown...
    self.ok = True
</t>
<t tx="ekr.20080709062932.7">def fail(self, msg=None):
    """Mark an AtShadowTestCase as having failed."""
    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20080709062932.8">def setUp(self):
    """AtShadowTestCase.setup."""
    c, p = self.c, self.p
    old = self.findNode(c, p, 'old')
    new = self.findNode(c, p, 'new')
    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)
    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)
    # Change node:new to node:old in all sentinel lines.
    self.expected_private_lines = self.mungePrivateLines(
        self.new_private_lines, 'node:new', 'node:old')
</t>
<t tx="ekr.20080709062932.9">def tearDown(self):
    """AtShadowTestCase.tearDown."""
    pass
        # No change is made to the outline.
        # self.c.redraw()
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080811174246.1">def languageForExtension(self, ext):
    """Return the language corresponding to the extension ext."""
    unknown = 'unknown_language'
    if ext.startswith('.'): ext = ext[1:]
    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None, 'none', 'None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None, 'none', 'None'):
            language = unknown
    else:
        language = unknown
    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20090110073010.1">@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090122201952.4">def appendStringToBody(self, p, s):
    """Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen."""
    if s:
        p.b = p.b + g.toUnicode(s, self.encoding)

def setBodyString(self, p, s):
    """
    Similar to c.setBodyString, but does not recolor the text or
    redraw the screen.
    """
    c, v = self.c, p.v
    if not c or not p:
        return
    s = g.toUnicode(s, self.encoding)
    if c.p and p.v == c.p.v:
        w = c.frame.body.wrapper
        i = len(s)
        w.setAllText(s)
        w.setSelectionRange(i, i, insert=i)
    # Keep the body text up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
</t>
<t tx="ekr.20090128083459.74"></t>
<t tx="ekr.20090128083459.75">def __get_b(self):
    """Return the body text of a position."""
    p = self
    return p.bodyString()

def __set_b(self, val: str):
    """
    Set the body text of a position.

    **Warning: the p.b = whatever is *expensive* because it calls
    c.setBodyString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.b instead of p.b.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Warning: c.setBodyString is *expensive*.

b = property(
    __get_b, __set_b,
    doc="position body string property")
</t>
<t tx="ekr.20090128083459.76">def __get_h(self):
    p = self
    return p.headString()

def __set_h(self, val: str):
    """
    Set the headline text of a position.

    **Warning: the p.h = whatever is *expensive* because it calls
    c.setHeadString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.h instead of p.h.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setHeadString(p, val)
        # Warning: c.setHeadString is *expensive*.

h = property(
    __get_h, __set_h,
    doc="position property returning the headline string")
</t>
<t tx="ekr.20090215165030.3">def __get_gnx(self):
    p = self
    return p.v.fileIndex

gnx = property(
    __get_gnx,  # __set_gnx,
    doc="position gnx property")
</t>
<t tx="ekr.20090428082801.64">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.error('bad option: %s' % s)
            break

    return d
</t>
<t tx="ekr.20090429055156.63">def runUnitTests(c):

    rstClass(c)
    p = g.findNodeAnywhere(c,'UnitTests')
    if p:
        c.selectPosition(p)
        c.testManager.doTests(all=None, marked=None, verbosity=1)
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"&lt;node: {p.h}&gt;"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090518072506.8494">def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert isinstance(stroke, str) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090715145956.6167">def checkVisNextLimit(self, limit, p):
    """Return True is p is outside limit of visible nodes."""
    return limit != p and not limit.isAncestorOf(p)
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding(self, event):

    c, k, state = self.c, self, self.unboundKeyAction
    stroke, w = event.stroke, event.w
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    #
    # #1757: Always insert plain keys in the body.
    #        Valid because mode bindings have already been handled.
    if (
        k.isPlainKey(stroke)
        and w == c.frame.body.widget
        and state in ('insert', 'overwrite')
    ):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        bi = k.getBindingHelper(key, name, stroke, w)
        if bi:
            return bi
    return None
</t>
<t tx="ekr.20091230094319.6244">def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    #
    # #1757: Leo's default vim bindings make heavy use of modes.
    #        Retain these traces!
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        if trace: g.trace(state, 'k.handleInputShortcut', stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            if trace: g.trace(state, 'k.handleMiniBindings', stroke)
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, 'k.isPlain: getArg', stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, f"{stroke.s!r}: getArg", stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        if trace: g.trace(state, 'k.getFileName', stroke)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        if val != 'do-standard-keys':
            handler = k.state.handler and k.state.handler.__name__ or '&lt;no handler&gt;'
            if trace: g.trace(state, 'k.callStateFunction:', handler, stroke)
            return True
        return False
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            if trace: g.trace(state, 'k.generalModeHandler', stroke)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    if trace:
        handler_name = handler and handler.__name__ or '&lt;no handler&gt;'
        g.trace(state, 'handler:', handler_name, stroke)
    return True
</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20100122130101.6174">def deleteTnodeList(self, p):  # AtFile method.
    """Remove p's tnodeList."""
    v = p.v
    if hasattr(v, "tnodeList"):
        if False:  # Not an error, but a useful trace.
            g.blue("deleting tnodeList for " + repr(v))
        delattr(v, "tnodeList")
        v._p_changed = True
</t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes(self):
    fc = self; c = fc.c
    aList = [z for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts(self):
    """Create a 'Recovered Nodes' node for each entry in c.nodeConflictList."""
    c = self.c
    if not c.nodeConflictList:
        return None
    if not c.make_node_conflicts_node:
        s = f"suppressed {len(c.nodeConflictList)} node conflicts"
        g.es(s, color='red')
        g.pr('\n' + s + '\n')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = f'Recovered node "{h1}" from {g.shortFileName(fn)}'
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...',
                f"{tag} gnx: {gnx} root: {(root_v and root.v)!r}",
                f"old headline: {h1}",
                f"new headline: {h2}",
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = f"{tag} gnx: {gnx} root: {root_v and root.v!r}\nDiff...\n"
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
</t>
<t tx="ekr.20100224050618.11547">def isFileLike(self, s):
    """Return True if s has file-like sentinels."""
    at = self; tag = "@+leo"
    s = g.checkUnicode(s)
    i = s.find(tag)
    if i == -1:
        return True  # Don't use the cache.
    j, k = g.getLine(s, i)
    line = s[j:k]
    valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
    return not isThin
</t>
<t tx="ekr.20100803073751.5817">def createResurrectedNodesNode(self):
    """Create a 'Resurrected Nodes' node as the last top-level node."""
    at = self; c = at.c; tag = 'Resurrected Nodes'
    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()
    # Create the node after last if it doesn't exist.
    if last.h == tag:
        p = last
    else:
        p = last.insertAfter()
        p.setHeadString(tag)
    p.expand()
    return p
</t>
<t tx="ekr.20100803073751.5818">def defineResurrectedNodeCallback(self, r, root):
    """Define a callback that moves node p as r's last child."""

    def callback(p, r=r.copy(), root=root):
        """The resurrected nodes callback."""
        child = r.insertAsLastChild()
        child.h = f"From {root.h}"
        v = p.v
        # new code: based on vnodes.
        for parent_v in v.parents:
            assert isinstance(parent_v, leoNodes.VNode), parent_v
            if v in parent_v.children:
                childIndex = parent_v.children.index(v)
                v._cutLink(childIndex, parent_v)
                v._addLink(len(child.v.children), child.v)
            else:
                # This would be surprising.
                g.trace('**already deleted**', parent_v, v)
        if not g.unitTesting:
            g.error('resurrected node:', v.h)
            g.blue('in file:', root.h)

    return callback
</t>
<t tx="ekr.20100813041139.5914">def createDirectoryForFile(self, fn):
    """
    Create the directory for fn if
    a) it doesn't exist and
    b) the user options allow it.

    Return True if the directory existed or was made.
    """
    c, ok = self.c, False  # 1815.
    # Create the directory if it doesn't exist.
    theDir, junk = g.os_path_split(fn)
    theDir = g.os_path_finalize(theDir)  # 1341
    if g.os_path_exists(theDir):
        return True
    if c and c.config and c.config.create_nonexistent_directories:
        theDir = c.expand_path_expression(theDir)
        ok = g.makeAllNonExistentDirectories(theDir)
        if not ok:
            g.error('did not create:', theDir)
    return ok
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101101175644.5891">def put(self, *args, **keys):
    """Put s to the given tab.

    May be overridden in subclasses."""
    # print('autoCompleter.put',args,keys)
    if g.unitTesting:
        pass
    else:
        g.es(*args, **keys)
</t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20110117113521.6107">def shortDescription(self):
    try:
        return f"EditBodyTestCase: {self.parent.h}"
    except Exception:
        g.print_exception()
        return "EditBodyTestCase"
</t>
<t tx="ekr.20110202111105.15439">def showStateCursor(self, state, w):
    pass
</t>
<t tx="ekr.20110209093958.15411">def setEditingState(self):
    k = self; state = k.defaultEditingAction
    k.setInputState(state)
</t>
<t tx="ekr.20110209093958.15413">def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default-editing-state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace(f"ignoring default_editing_state: {action}")
        action = 'insert'
    self.defaultEditingAction = action
</t>
<t tx="ekr.20110314115639.14269">def is_leo_source_file(self):
    """Return True if this is one of Leo's source files."""
    c = self.c
    table = (z.lower() for z in (
        'leoDocs.leo',
        'LeoGui.leo', 'LeoGuiPluginsRef.leo',
        # 'leoPlugins.leo', 'leoPluginsRef.leo',
        'leoPy.leo', 'leoPyRef.leo',
        'myLeoSettings.leo', 'leoSettings.leo',
        'ekr.leo',
        # 'test.leo',
    ))
    return c.shortFileName().lower() in table
</t>
<t tx="ekr.20110509064011.14556">def attr_matches(self, s, namespace):
    """Compute matches when string s is of the form name.name....name.

    Evaluates s using eval(s,namespace)

    Assuming the text is of the form NAME.NAME....[NAME], and is evaluatable in
    the namespace, it will be evaluated and its attributes (as revealed by
    dir()) are used as possible completions.

    For class instances, class members are are also considered.)

    **Warning**: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    # Seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", s)
    if not m:
        return []
    expr, attr = m.group(1, 3)
    try:
        safe_expr = self.strip_brackets(expr)
        obj = eval(safe_expr, namespace)
    except Exception:
        return []
    # Build the result.
    words = dir(obj)
    n = len(attr)
    result = [f"{expr}.{w}" for w in words if w[:n] == attr]
    return result
</t>
<t tx="ekr.20110509064011.14557">def get_leo_completions(self, prefix):
    """Return completions in an environment defining c, g and p."""
    aList = []
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        aList.extend(self.attr_matches(prefix, d))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110509064011.14561">def get_autocompleter_prefix(self):
    # Only the body pane supports auto-completion.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    if not s: return ''
    i = w.getInsertPoint() - 1
    i = j = max(0, i)
    while i &gt;= 0 and (s[i].isalnum() or s[i] in '._'):
        i -= 1
    i += 1
    j += 1
    prefix = s[i:j]
    return prefix
</t>
<t tx="ekr.20110510071925.14586">def init_qcompleter(self, event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    w = self.c.frame.body.wrapper.widget
        # A LeoQTextBrowser.  May be none for unit tests.
    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110510120621.14539">def get_codewise_completions(self, prefix):
    """Use codewise to generate a list of hits."""
    c = self.c
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", prefix)
    if m:
        varname = m.group(1)
        ivar = m.group(3)
        kind, aList = self.guess_class(c, varname)
    else:
        kind, aList = 'none', []
        varname, ivar = None, None
    if aList:
        if kind == 'class':
            hits = self.lookup_methods(aList, ivar)
            hits.extend(self.codewiseSelfList)
        elif kind == 'module':
            hits = self.lookup_modules(aList, ivar)
    else:
        aList2 = prefix.split('.')
        if aList2:
            func = aList2[-1]
            hits = self.lookup_functions(func)
        else:
            hits = []
    if 1:  # A kludge: add the prefix to each hit.
        hits = [f"{varname}.{z}" for z in hits]
    return hits
</t>
<t tx="ekr.20110510120621.14540">def clean(self, hits):
    """Clean up hits, a list of ctags patterns, for use in completion lists."""
    # Just take the function name: ignore the signature &amp; file.
    aList = list(set([z[0] for z in hits]))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110510120621.14542">def guess_class(self, c, varname):
    """Return kind, class_list"""
    # if varname == 'g':
        # return 'module',['leoGlobals']
    if varname == 'p':
        return 'class', ['position']
    if varname == 'c':
        return 'class', ['Commands']
    if varname == 'self':
        # Return the nearest enclosing class.
        for p in c.p.parents():
            h = p.h
            m = re.search(r'class\s+(\w+)', h)
            if m:
                return 'class', [m.group(1)]
    if 1:
        aList = []
    else:
        # This is not needed now that we add the completions for 'self'.
        aList = ContextSniffer().get_classes(c.p.b, varname)
    return 'class', aList
</t>
<t tx="ekr.20110510120621.14543">def lookup_functions(self, prefix):
    aList = codewise.cmd_functions([prefix])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_methods(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_members([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_modules(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_functions([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)
</t>
<t tx="ekr.20110510133719.14548">def do_qcompleter_tab(self, prefix, options):
    """Return the longest common prefix of all the options."""
    matches, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    return common_prefix
</t>
<t tx="ekr.20110511133940.14552">def init_tabcompleter(self, event=None):
    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName()  # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110511133940.14561">def show_completion_list(self, common_prefix, prefix, tabList):

    c = self.c
    aList = common_prefix.split('.')
    header = '.'.join(aList[:-1])
    # "!" toggles self.verbose.
    if self.verbose or self.use_qcompleter or len(tabList) &lt; 20:
        tabList = self.clean_completion_list(header, tabList,)
    else:
        tabList = self.get_summary_list(header, tabList)
    if self.use_qcompleter:
        # Put the completions in the QListView.
        if self.qw:
            self.qw.show_completions(tabList)
    else:
        # Update the tab name, creating the tab if necessary.
        c.widgetWantsFocus(self.w)
        c.frame.log.clearTab(self.tabName)
        self.beginTabName(header + '.' if header else '')
        s = '\n'.join(tabList)
        self.put('', s, tabName=self.tabName)
</t>
<t tx="ekr.20110512090917.14466">def get_leo_namespace(self, prefix):
    """
    Return an environment in which to evaluate prefix.
    Add some common standard library modules as needed.
    """
    k = self.k
    d = {'c': k.c, 'p': k.c.p, 'g': g}
    aList = prefix.split('.')
    if len(aList) &gt; 1:
        name = aList[0]
        m = sys.modules.get(name)
        if m:
            d[name] = m
    return d
</t>
<t tx="ekr.20110512090917.14468">def calltip_fail(self, prefix):
    """Evaluation of prefix failed."""
    self.insert_string('(')
</t>
<t tx="ekr.20110512090917.14469">def calltip_success(self, prefix, obj):
    try:
        # Get the parenthesized argument list.
        s1, s2, s3, s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1, s2, s3, s4)
    except Exception:
        self.insert_string('(')
        return
    # Clean s and insert it: don't include the opening "(".
    if g.match(s, 1, 'self,'):
        s = s[6:].strip()
    elif g.match_word(s, 1, 'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()
    self.insert_string("(", select=False)
    self.insert_string(s, select=True)
</t>
<t tx="ekr.20110512170111.14471">def strip_brackets(self, s):
    """Return s with all brackets removed.

    This (mostly) ensures that eval will not execute function calls, etc.
    """
    for ch in '[]{}()':
        s = s.replace(ch, '')
    return s
</t>
<t tx="ekr.20110512170111.14472">def get_object(self):
    """Return the object corresponding to the current prefix."""
    common_prefix, prefix1, aList = self.compute_completion_list()
    if not aList:
        return None, prefix1
    if len(aList) == 1:
        prefix = aList[0]
    else:
        prefix = common_prefix
    if prefix.endswith('.') and self.use_qcompleter:
        prefix += self.qcompleter.get_selection()
    safe_prefix = self.strip_brackets(prefix)
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        try:
            obj = eval(safe_prefix, d)
            break  # only reached if none of the exceptions below occur
        except AttributeError:
            obj = None
        except NameError:
            obj = None
        except SyntaxError:
            obj = None
        except Exception:
            g.es_exception()
            obj = None
    return obj, prefix
</t>
<t tx="ekr.20110512212836.14469">def exit(self):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    if trace: g.trace('(AutoCompleterClass)')
    c, p, u = self.c, self.c.p, self.c.undoer
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    newText = w.getAllText()
    if p.b == newText:
        return
    bunch = u.beforeChangeBody(p)
    p.v.b = newText  # p.b would cause a redraw.
    u.afterChangeBody(p, 'auto-completer', bunch)

finish = exit
abort = exit
</t>
<t tx="ekr.20110512212836.14471">jedi_warning = False

def get_completions(self, prefix):
    """Return jedi or codewise completions."""
    d = self.completionsDict
    if self.use_jedi:
        try:
            import jedi
        except ImportError:
            if not self.jedi_warning:
                self.jedi_warning = False
                g.es_print('can not import jedi')
                g.es_print('ignoring @bool use_jedi = True')
        if jedi:
            aList = (
                self.get_jedi_completions(prefix) or
                    # Prefer the jedi completions.
                self.get_leo_completions(prefix))
            d[prefix] = aList
            return aList
    #
    # Not jedi. Use codewise.
    # Precompute the codewise completions for '.self'.
    if not self.codewiseSelfList:
        aList = self.get_codewise_completions('self.')
        self.codewiseSelfList = [z[5:] for z in aList]
        d['self.'] = self.codewiseSelfList
    # Use the cached list if it exists.
    aList = d.get(prefix)
    if aList:
        return aList
    aList = (
        self.get_leo_completions(prefix) or
            # Prefer the Leo completions.
        self.get_codewise_completions(prefix)
    )
    d[prefix] = aList
    return aList
</t>
<t tx="ekr.20110512232915.14481">def clean_for_display(self, hits):
    """Clean up hits, a list of ctags patterns, for display purposes."""
    aList = []
    for h in hits:
        s = h[0]
        # Display oriented: no good for completion list.
        fn = h[1].strip()
        if fn.startswith('/'):
            sig = fn[2:-4].strip()
        else:
            sig = fn
        aList.append(f"{s}: {sig}")
    aList = list(set(aList))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110513104728.14453">def clean_completion_list(self, header, tabList):
    """Return aList with header removed from the start of each list item."""
    return [
        z[len(header) + 1 :] if z.startswith(header) else z
            for z in tabList]
</t>
<t tx="ekr.20110513104728.14454">def get_summary_list(self, header, tabList):
    """Show the possible starting letters,
    but only if there are more than one.
    """
    d = {}
    for z in tabList:
        tail = z[len(header) :] if z else ''
        if tail.startswith('.'): tail = tail[1:]
        ch = tail[0] if tail else ''
        if ch:
            n = d.get(ch, 0)
            d[ch] = n + 1
    aList = [f"{ch2} {d.get(ch2)}" for ch2 in sorted(d)]
    if len(aList) &gt; 1:
        tabList = aList
    else:
        tabList = self.clean_completion_list(header, tabList)
    return tabList
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self, prefix):
    d = self.completionsDict
    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)
    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            return key, []
        options = d.get(key)
        if options:
            return key, options
    return None, []
</t>
<t tx="ekr.20110530124245.18248">def looksLikeDerivedFile(self, fn):
    """
    Return True if fn names a file that looks like an
    external file written by Leo.
    """
    # c = self
    try:
        with open(fn, 'rb') as f:  # 2020/11/14: Allow unicode characters!
            s = f.read()
            s = g.toUnicode(s)
        return s.find('@+leo-ver=') &gt; -1
    except Exception:
        g.es_exception()
        return False
</t>
<t tx="ekr.20110605040658.17005">def check_event(self, event):
    """Check an event object."""
    # c = self
    from leo.core import leoGui

    if not event:
        return
    stroke = event.stroke
    got = event.char
    if g.unitTesting:
        return
    if stroke and (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1):
        expected = event.char
            # Alas, Alt and Ctrl bindings must *retain* the char field,
            # so there is no way to know what char field to expect.
    else:
        expected = event.char
            # disable the test.
            # We will use the (weird) key value for, say, Ctrl-s,
            # if there is no binding for Ctrl-s.
    if not isinstance(event, leoGui.LeoKeyEvent):
        if g.app.gui.guiName() not in ('console', 'curses'):
            g.trace(f"not leo event: {event!r}, callers: {g.callers()}")
    if expected != got:
        g.trace(f"stroke: {stroke!r}, expected char: {expected!r}, got: {got!r}")
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17873">def full_redraw(self, p=None):
    """
    Redraw all visible nodes of the tree.
    Preserve the vertical scrolling unless scroll is True.
    """
    c = self.c
    if g.app.disable_redraw:
        return None
    if self.busy:
        return None
    # Cancel the delayed redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.currentPosition()
    elif c.hoistStack and p.h.startswith('@chapter') and p.hasChildren():
        # Make sure the current position is visible.
        # Part of fix of bug 875323: Hoist an @chapter node leaves a non-visible node selected.
        p = p.firstChild()
        c.frame.tree.select(p)
        c.setCurrentPosition(p)
    else:
        c.setCurrentPosition(p)
    assert not self.busy, g.callers()
    self.redrawCount += 1
    self.initData()
    try:
        self.busy = True
        self.drawTopTree(p)
    finally:
        self.busy = False
    self.setItemForCurrentPosition()
    return p  # Return the position, which may have changed.

# Compatibility

redraw = full_redraw
redraw_now = full_redraw
</t>
<t tx="ekr.20110605121601.17874">def drawChildren(self, p, parent_item):
    """Draw the children of p if they should be expanded."""
    if not p:
        g.trace('can not happen: no p')
        return
    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child, parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child, parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
</t>
<t tx="ekr.20110605121601.17875">def drawNode(self, p, parent_item):
    """Draw the node p."""
    c = self.c
    v = p.v
    # Allocate the QTreeWidgetItem.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy()  # was item
    self.item2vnodeDict[itemHash] = v  # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    # #1310: Add a tool tip.
    item.setToolTip(0, p.h)
    if self.use_declutter:
        icon = self.declutter_node(c, p, item)
        if icon:
            item.setIcon(0, icon)
        return item
    # Draw the icon.
    v.iconVal = v.computeIcon()
    icon = self.getCompositeIconImage(p, v.iconVal)
        # **Slow**, but allows per-vnode icons.
    if icon:
        item.setIcon(0, icon)
    return item
</t>
<t tx="ekr.20110605121601.17876">def drawTopTree(self, p):
    """Draw the tree rooted at p."""
    trace = 'drawing' in g.app.debug and not g.unitTesting
    if trace:
        t1 = time.process_time()
    c = self.c
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    if trace:
        t2 = time.process_time()
        g.trace(f"{t2 - t1:5.2f} sec.", g.callers(5))
</t>
<t tx="ekr.20110605121601.17877">def drawTree(self, p, parent_item=None):
    if g.app.gui.isNullGui:
        return
    # Draw the (visible) parent node.
    item = self.drawNode(p, parent_item)
    # Draw all the visible children.
    self.drawChildren(p, parent_item=item)
</t>
<t tx="ekr.20110605121601.17878">def initData(self):
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
</t>
<t tx="ekr.20110605121601.17911">def endEditLabel(self):
    """
    Override LeoTree.endEditLabel.

    Just end editing of the presently-selected QLineEdit!
    This will trigger the editingFinished_callback defined in createEditorForItem.
    """
    item = self.getCurrentItem()
    if not item:
        return
    e = self.getTreeEditorForItem(item)
    if not e:
        return
    # Trigger the end-editing event.
    w = self.treeWidget
    w.closeEditor(e, QtWidgets.QAbstractItemDelegate.NoHint)
    w.setCurrentItem(item)
</t>
<t tx="ekr.20110605121601.17957">if QtWidgets:


    class DemoWidget(QtWidgets.QWidget):
        count = 0
        @others
</t>
<t tx="ekr.20110605121601.17958">def __init__(self, parent=None, color=None):
    """Ctor for DemoWidget class."""
    super().__init__(parent)
    self.setLayout(QtWidgets.QVBoxLayout())
    self.layout().setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.layout().setSpacing(0)
    text = QtWidgets.QTextEdit()
    self.layout().addWidget(text)
    DemoWidget.count += 1
    text.setPlainText(f"#{DemoWidget.count:d}")
    button_layout = QtWidgets.QHBoxLayout()
    button_layout.setContentsMargins(QtCore.QMargins(5, 5, 5, 5))
    self.layout().addLayout(button_layout)
    button_layout.addWidget(QtWidgets.QPushButton("Go"))
    button_layout.addWidget(QtWidgets.QPushButton("Stop"))
    if color:
        self.setStyleSheet(f"background-color: {color};")
</t>
<t tx="ekr.20110605121601.17991">def main():
    """The main top-level function executed when this file is executed stand-alone."""
    app = Qt.QApplication(sys.argv)
    wdg = DemoWidget()
    wdg2 = DemoWidget()
    splitter = NestedSplitter()
    splitter.addWidget(wdg)
    splitter.addWidget(wdg2)


    class DemoProvider:

        def ns_provides(self):
            return [('Add demo widget', '_add_demo_widget')]

        def ns_provide(self, id_):
            if id_ == '_add_demo_widget':
                return DemoWidget()
            return None

    splitter.register_provider(DemoProvider())
    holder = QtWidgets.QWidget()
    holder.setLayout(QtWidgets.QVBoxLayout())
    holder.layout().setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    holder.layout().addWidget(splitter)
    holder.show()
    app.exec_()
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    """
    Called when user selects an item in the QListWidget.
    """
    c = self.leo_c
    p = c.p
    w = c.k.autoCompleter.w or c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.undoer.doTyping(p, 'Typing', oldText,
            newText=w.getAllText(),
            newInsert=w.getInsertPoint(),
            newSel=w.getSelectionRange(),
            oldSel=oldSel,
        )
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
</t>
<t tx="ekr.20110605121601.18058">class QLineEditWrapper(QTextMixin):
    """
    A class to wrap QLineEdit widgets.

    The QHeadlineWrapper class is a subclass that merely
    redefines the do-nothing check method here.
    """
    @others
</t>
<t tx="ekr.20110605121601.18060">def __init__(self, widget, name, c=None):
    """Ctor for QLineEditWrapper class."""
    super().__init__(c)
    self.widget = widget
    self.name = name
    self.baseClassName = 'QLineEditWrapper'

def __repr__(self):
    return f"&lt;QLineEditWrapper: widget: {self.widget}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18077">def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    """QTextEditWrapper."""
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'begin-line': tc.StartOfLine,  # Was start-line
        'down': tc.Down,
        'end': tc.End,
        'end-line': tc.EndOfLine,  # Not used.
        'exchange': True,  # Dummy.
        'home': tc.Start,
        'left': tc.Left,
        'page-down': tc.Down,
        'page-up': tc.Up,
        'right': tc.Right,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        g.trace(f"can not happen: bad kind: {kind}")
        return
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange':  # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    # #218.
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
</t>
<t tx="ekr.20110605121601.18088">def scrollDelegate(self, kind):
    """
    Scroll a QTextEdit up or down one page.
    direction is in ('down-line','down-page','up-line','up-page')
    """
    c = self.c
    w = self.widget
    vScroll = w.verticalScrollBar()
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h / lineSpacing
    n = max(2, n - 3)
    if kind == 'down-half-page': delta = n / 2
    elif kind == 'down-line': delta = 1
    elif kind == 'down-page': delta = n
    elif kind == 'up-half-page': delta = -n / 2
    elif kind == 'up-line': delta = -1
    elif kind == 'up-page': delta = -n
    else:
        delta = 0
        g.trace('bad kind:', kind)
    val = vScroll.value()
    vScroll.setValue(val + (delta * lineSpacing))
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18090">def see(self, see_i):
    """Scroll so that position see_i is visible."""
    w = self.widget
    tc = w.textCursor()
    # Put see_i in range.
    s = self.getAllText()
    see_i = max(0, min(see_i, len(s)))
    # Remember the old cursor
    old_cursor = QtGui.QTextCursor(tc)
    # Scroll so that see_i is visible.
    tc.setPosition(see_i)
    w.setTextCursor(tc)
    w.ensureCursorVisible()
    # Restore the old cursor
    w.setTextCursor(old_cursor)

def seeInsertPoint(self):
    """Make sure the insert point is visible."""
    self.widget.ensureCursorVisible()
</t>
<t tx="ekr.20110605121601.18102">def get(self, i, j=None):
    """QTextMixin"""
    # 2012/04/12: fix the following two bugs by using the vanilla code:
    # https://bugs.launchpad.net/leo-editor/+bug/979142
    # https://bugs.launchpad.net/leo-editor/+bug/971166
    s = self.getAllText()
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    return s[i:j]
</t>
<t tx="ekr.20110605121601.18112">def see(self, i):
    """Ensure insert point i is visible in a QsciScintilla widget."""
    # Ok for now.  Using SCI_SETYCARETPOLICY might be better.
    w = self.widget
    s = self.getAllText()
    i = self.toPythonIndex(i)
    row, col = g.convertPythonIndexToRowCol(s, i)
    w.ensureLineVisible(row)
</t>
<t tx="ekr.20110605121601.18116">class QHeadlineWrapper(QLineEditWrapper):
    """
    A wrapper class for QLineEdit widgets in QTreeWidget's.
    This class just redefines the check method.
    """
    @others
</t>
<t tx="ekr.20110605121601.18117">def __init__(self, c, item, name, widget):
    """The ctor for the QHeadlineWrapper class."""
    assert isinstance(widget, QtWidgets.QLineEdit), widget
    super().__init__(widget, name, c)
    # Set ivars.
    self.c = c
    self.item = item
    self.name = name
    self.permanent = False  # Warn the minibuffer that we can go away.
    self.widget = widget
    # Set the signal.
    g.app.gui.setFilter(c, self.widget, self, tag=name)

def __repr__(self):
    return f"QHeadlineWrapper: {id(self)}"
</t>
<t tx="ekr.20110605121601.18118"></t>
<t tx="ekr.20110605121601.18119">def check(self):
    """Return True if the tree item exists and it's edit widget exists."""
    tree = self.c.frame.tree
    try:
        e = tree.treeWidget.itemWidget(self.item, 0)
    except RuntimeError:
        return False
    valid = tree.isValidItem(self.item)
    result = valid and e == self.widget
    return result
</t>
<t tx="ekr.20110605121601.18120">def getAllText(self):
    """QHeadlineWrapper."""
    if self.check():
        w = self.widget
        return w.text()
    return ''
</t>
<t tx="ekr.20110605121601.18121">def getInsertPoint(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.cursorPosition()
    return 0
</t>
<t tx="ekr.20110605121601.18122">def getSelectionRange(self, sort=True):
    """QHeadlineWrapper."""
    w = self.widget
    if self.check():
        if w.hasSelectedText():
            i = w.selectionStart()
            s = w.selectedText()
            j = i + len(s)
        else:
            i = j = w.cursorPosition()
        return i, j
    return 0, 0
</t>
<t tx="ekr.20110605121601.18123">def hasSelection(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.hasSelectedText()
    return False
</t>
<t tx="ekr.20110605121601.18124">def see(self, i):
    """QHeadlineWrapper."""
    pass

def seeInsertPoint(self):
    """QHeadlineWrapper."""
    pass
</t>
<t tx="ekr.20110605121601.18125">def setAllText(self, s):
    """Set all text of a Qt headline widget."""
    if self.check():
        w = self.widget
        w.setText(s)
</t>
<t tx="ekr.20110605121601.18128">def setFocus(self):
    """QHeadlineWrapper."""
    if self.check():
        g.app.gui.set_focus(self.c, self.widget)
</t>
<t tx="ekr.20110605121601.18129">def setInsertPoint(self, i, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if s is None:
        s = w.text()
    i = self.toPythonIndex(i)
    i = max(0, min(i, len(s)))
    w.setCursorPosition(i)
</t>
<t tx="ekr.20110605121601.18130">def setSelectionRange(self, i, j, insert=None, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if i &gt; j: i, j = j, i
    if s is None:
        s = w.text()
    n = len(s)
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        insert = j
    else:
        insert = self.toPythonIndex(insert)
        insert = max(0, min(insert, n))
    if i == j:
        w.setCursorPosition(i)
    else:
        length = j - i
        # Set selection is a QLineEditMethod
        if insert &lt; j:
            w.setSelection(j, -length)
        else:
            w.setSelection(i, length)
# setSelectionRangeHelper = setSelectionRange
</t>
<t tx="ekr.20110605121601.18411">def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


</t>
<t tx="ekr.20110605121601.18412">def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ekr.20110605121601.18418">def connectEditorWidget(self, e, item):
    """
    Connect QLineEdit e to QTreeItem item.
    
    Also callback for when the editor ends.
    
    New in Leo 6.4: The callback handles all updates w/o calling onHeadChanged.
    """
    c, p, u = self.c, self.c.p, self.c.undoer
    @others  # define the callback.
    if e:
        # Hook up the widget.
        wrapper = self.getWrapper(e, item)
        e.editingFinished.connect(editingFinished_callback)
        return wrapper  # 2011/02/12
    g.trace('can not happen: no e')
    return None
</t>
<t tx="ekr.20110605121601.18433"></t>
<t tx="ekr.20110605121601.18434">def getScroll(self):
    """Return the hPos,vPos for the tree's scrollbars."""
    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    vScroll = w.verticalScrollBar()
    hPos = hScroll.sliderPosition()
    vPos = vScroll.sliderPosition()
    return hPos, vPos
</t>
<t tx="ekr.20110605121601.18435">def setHScroll(self, hPos):

    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    hScroll.setValue(hPos)

def setVScroll(self, vPos):

    w = self.treeWidget
    vScroll = w.verticalScrollBar()
    vScroll.setValue(vPos)
</t>
<t tx="ekr.20110605121601.18540">def eventFilter(self, obj, event):
    """Return False if Qt should handle the event."""
    c, k = self.c, self.c.k
    #
    # Handle non-key events first.
    if not self.c.p:
        return False  # Startup.
    #
    # Trace events.
    if 'events' in g.app.debug:
        if isinstance(event, QtGui.QKeyEvent):
            self.traceKeys(obj, event)
        else:
            self.traceEvent(obj, event)
            self.traceWidget(event)
    #
    # Let Qt handle the non-key events.
    if self.doNonKeyEvent(event, obj):
        return False
    #
    # Ignore incomplete key events.
    if self.shouldIgnoreKeyEvent(event, obj):
        return False
    #
    # Generate a g.KeyStroke for k.masterKeyHandler.
    try:
        binding, ch = self.toBinding(event)
        if not binding:
            return False  # Not the correct event type.
        #
        # Pass the KeyStroke to masterKeyHandler.
        key_event = self.createKeyEvent(event, c, self.w, ch, binding)
        k.masterKeyHandler(key_event)
        c.outerUpdate()
    except Exception:
        g.es_exception()
    return True
        # Whatever happens, suppress all other Qt key handling.
</t>
<t tx="ekr.20110605121601.18543">def toBinding(self, event):
    """
    Return (binding, actual_ch):

    binding:    A user binding, to create g.KeyStroke.
                Spelling no longer fragile.
    actual_ch:  The insertable key, or ''.
    """
    mods = self.qtMods(event)
    keynum, text, toString, ch = self.qtKey(event)
    actual_ch = text or toString
    #
    # Never allow empty chars, or chars in g.app.gui.ignoreChars
    if toString in g.app.gui.ignoreChars:
        return None, None
    ch = ch or toString or ''
    if not ch:
        return None, None
    #
    # Check for AltGr and Alt+Ctrl keys *before* creating a binding.
    actual_ch, ch, mods = self.doMacTweaks(actual_ch, ch, mods)
    mods = self.doAltTweaks(actual_ch, keynum, mods, toString)
    #
    # Use *ch* in the binding.
    # Clearer w/o f-strings.
    binding = '%s%s' % (''.join([f"{z}+" for z in mods]), ch)
    #
    # Return the tweaked *actual* char.
    binding, actual_ch = self.doLateTweaks(binding, actual_ch)
    return binding, actual_ch
</t>
<t tx="ekr.20110605121601.18544">def qtKey(self, event):
    """
    Return the components of a Qt key event.

    Modifiers are handled separately.

    Return (keynum, text, toString, ch).

    keynum: event.key()
    ch:     chr(keynum) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    """
    keynum = event.key()
    text = event.text()  # This is the unicode character!
    qt = QtCore.Qt
    d = {
        qt.Key_Alt: 'Key_Alt',
        qt.Key_AltGr: 'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta: 'Key_Meta',
            # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Shift: 'Key_Shift',
        qt.Key_NumLock: 'Num_Lock',
            # 868.
        qt.Key_Super_L: 'Key_Super_L',
        qt.Key_Super_R: 'Key_Super_R',
        qt.Key_Hyper_L: 'Key_Hyper_L',
        qt.Key_Hyper_R: 'Key_Hyper_R',
    }
    if d.get(keynum):
        if 0:  # Allow bare modifier key.
            toString = d.get(keynum)
        else:
            toString = ''
    else:
        toString = QtGui.QKeySequence(keynum).toString()
    # Fix bug 1244461: Numpad 'Enter' key does not work in minibuffer
    if toString == 'Enter':
        toString = 'Return'
    if toString == 'Esc':
        toString = 'Escape'
    try:
        ch = chr(keynum)
    except ValueError:
        ch = ''
    # g.trace(keynum, ch)
    return keynum, text, toString, ch
</t>
<t tx="ekr.20110605121601.18618">def match_mark_previous(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    """
    Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.
    """
    # This match was causing most of the syntax-color problems.
    return 0  # 2009/6/23
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    """Remain in this state until 'end' is seen."""
    self.matcher_name = 'restart:' + self.matcher_name.replace('restart:','')
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else:  # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j  # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    """
    Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.
    """
    trace = 'coloring' in g.app.debug and not g.unitTesting
        # setTag does most tracing.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    self.delegate_name = delegate
    if delegate:
        if trace:
            if len(repr(s[i:j])) &lt;= 20:
                s2 = repr(s[i:j])
            else:
                s2 = repr(s[i : i + 17 - 2] + '...')
            kind_s = f"{delegate}:{tag}"
            print(
                f"\ncolorRangeWithTag: {kind_s:25} {i:3} {j:3} "
                f"{s2:&gt;20} {self.matcher_name}\n")
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    self.matcher_name = f.__name__
                    i += n
                    break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh':  # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">tot_time = 0.0

def mainLoop(self, n, s):
    """Colorize a *single* line s, starting in state n."""
    trace = 'coloring' in g.app.debug
    t1 = time.process_time()
    f = self.restartDict.get(n)
    if trace:
        p = self.c and self.c.p
        if p and p.v != self.last_v:
            self.last_v = p.v
            f_name = f.__name__ if f else 'None'
            print('')
            g.trace(f"NEW NODE: state {n} = {f_name} {p.h}\n")
    i = f(s) if f else 0
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0:  # Success. The match has already been colored.
                self.matcher_name = f.__name__  # For traces.
                i += n
                break
            elif n &lt; 0:  # Total failure.
                i += -n
                break
            else:  # Partial failure: Do not break or change i!
                pass
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about changing state here.
    self.tot_time += time.process_time() - t1
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    """
    jEdit.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    """
    p = self.c.p
    self.recolorCount += 1
    block_n = self.currentBlockNumber()
    n = self.prevState()
    if p.v == self.old_v:
        new_language = self.n2languageDict.get(n)
        if new_language != self.language:
            self.language = new_language
            self.init(p)
    else:
        self.updateSyntaxColorer(p)  # Force a full recolor
        assert self.language
        self.init_all_state(p.v)
        self.init(p)
    if block_n == 0:
        n = self.initBlock0()
    n = self.setState(n)  # Required.
    # Always color the line, even if colorizing is disabled.
    if s:
        self.mainLoop(n, s)
</t>
<t tx="ekr.20110605121601.18641">last_v = None

def setTag(self, tag, s, i, j):
    """Set the tag in the highlighter."""
    trace = 'coloring' in g.app.debug and not g.unitTesting
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper  # A QTextEditWrapper
    if not tag.strip():
        return
    tag = tag.lower().strip()
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots') :]
    colorName = wrapper.configDict.get(tag)
        # This color name should already be valid.
    if not colorName:
        return
    #
    # New in Leo 5.8.1: allow symbolic color names here.
    # This now works because all keys in leo_color_database are normalized.
    colorName = colorName.replace(
        ' ', '').replace('-', '').replace('_', '').lower().strip()
    colorName = leo_color_database.get(colorName, colorName)
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            g.trace('unknown color name', colorName, g.callers())
            return
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    if trace:
        # A superb trace.
        ###
            # p = self.c and self.c.p
            # if p and p.v != self.last_v:
                # print(f'\nsetTag: NEW NODE: {p.h}\n')
                # self.last_v = p.v
        if len(repr(s[i:j])) &lt;= 20:
            s2 = repr(s[i:j])
        else:
            s2 = repr(s[i : i + 17 - 2] + '...')
        kind_s = f"{self.language}.{tag}"
        kind_s2 = f"{self.delegate_name}:" if self.delegate_name else ''
        print(
            f"setTag: {kind_s:25} {i:3} {j:3} {s2:&gt;20} "
            f"{self.rulesetName}:{kind_s2}{self.matcher_name}"
        )
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20110605195119.16937">def createKeyEvent(self, event, c, w, ch, binding):

    return leoGui.LeoKeyEvent(
        c=self.c,
        char=ch,
            # char = None doesn't work at present.
            # But really, the binding should suffice.
        event=event,
        binding=binding,
        w=w,
        x=getattr(event, 'x', None) or 0,
        y=getattr(event, 'y', None) or 0,
        x_root=getattr(event, 'x_root', None) or 0,
        y_root=getattr(event, 'y_root', None) or 0,
    )
</t>
<t tx="ekr.20110606004638.16929">def stroke2char(self, stroke):
    """
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    """
    if not stroke:
        return ''
    if not g.isStroke(stroke):
        # vim commands pass a plain key.
        stroke = g.KeyStroke(stroke)
    return stroke.toInsertableChar()
</t>
<t tx="ekr.20110609161752.16459">def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) &gt; 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20111005081134.15543">def createMoveMarkedNode(c):
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.h = 'Moved marked nodes'
    p.moveToRoot()
    return p
</t>
<t tx="ekr.20111015194452.15686">def onSelectItem(self, it, it_prev=None):

    c = self.c
    tgt = self.its.get(it and id(it))
    if not tgt:
        return
    # if Ctrl key is down, delete item and
    # children (based on indent) and return
    modifiers = QtWidgets.QApplication.keyboardModifiers()
    if modifiers == QtCore.Qt.ControlModifier:
        row = self.lw.row(it)
        init_indent = len(it.text()) - len(str(it.text()).lstrip())
        self.lw.blockSignals(True)
        while row &lt; self.lw.count():
            self.lw.item(row).setHidden(True)
            row += 1
            cur = self.lw.item(row)
            # #1751.
            if not cur:
                break
            s = cur.text() or ''
            indent = len(s) - len(str(s).lstrip())
            if indent &lt;= init_indent:
                break
        self.lw.setCurrentRow(row)
        self.lw.blockSignals(False)
        return
    # generic callable
    if callable(tgt):
        tgt()
    elif len(tgt) == 2:
        p, pos = tgt
        if hasattr(p,'v'): #p might be "Root"
            if not c.positionExists(p):
                g.es("Node moved or deleted.\nMaybe re-do search.",
                    color='red')
                return
            c.selectPosition(p)
            if pos is not None:
                st, en = pos
                w = c.frame.body.wrapper
                w.setSelectionRange(st,en)
                w.seeInsertPoint()
            self.lw.setFocus()
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @&lt;file&gt; node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120130074511.10227">def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
</t>
<t tx="ekr.20120130074511.10228">def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) &gt; -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
</t>
<t tx="ekr.20120204061120.10067">def __repr__(self):
    return f"&lt;KeyStroke: {repr(self.s)}&gt;"

def __str__(self):
    return repr(self.s)
</t>
<t tx="ekr.20120204061120.10084">def qtMods(self, event):
    """Return the text version of the modifiers of the key event."""
    qt = QtCore.Qt
    modifiers = event.modifiers()
    mod_table = (
        (qt.AltModifier, 'Alt'),
        (qt.ControlModifier, 'Control'),
        (qt.MetaModifier, 'Meta'),
        (qt.ShiftModifier, 'Shift'),
        (qt.KeypadModifier, 'KeyPad'),
            # #1448: Replacing this by 'Key' would make separate keypad bindings impossible.
    )
    mods = [b for a, b in mod_table if (modifiers &amp; a)]
    #
    # MacOS: optionally convert Meta (Ctrl key) to Alt.
    # 945: remove @bool swap-mac-keys and @bool replace-meta-with-alt.
    # if g.isMac:
        # c = self.c
        # if c.k.replace_meta_with_alt:
            # if 'Meta' in mods:
                # mods.remove('Meta')
                # mods.append('Alt')
        # if c.k.swap_mac_keys:
            # # Swap the Command (clover) and Control keys.
            # # That is, swap the meaning of the Control and Meta modifiers.
            # if 'Meta' in mods and 'Control' not in mods:
                # mods.remove('Meta')
                # mods.append('Control')
            # elif 'Control' in mods and 'Meta' not in mods:
                # mods.remove('Control')
                # mods.append('Meta')
    return mods
</t>
<t tx="ekr.20120208064440.10179">def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20120208064440.10190"></t>
<t tx="ekr.20120208064440.10199">def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
</t>
<t tx="ekr.20120212220616.10537">def readExternalFiles(self, fileName):
    """Read all external files."""
    c, fc = self.c, self
    c.atFileCommands.readAll(c.rootPosition(), force=False)
    recoveryNode = fc.handleNodeConflicts()
    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read
    # the @thin nodes!
    fc.restoreDescendentAttributes()
    fc.setPositionsFromVnodes()
    return recoveryNode
</t>
<t tx="ekr.20120213081706.10382">def readGlobalSettingsFiles(self):
    """
    Read leoSettings.leo and myLeoSettings.leo using a null gui.
    
    New in Leo 6.1: this sets ivars for the ActiveSettingsOutline class.
    """
    trace = 'themes' in g.app.debug
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    old_commanders = g.app.commanders()
    lm.leo_settings_path = lm.computeLeoSettingsPath()
    lm.my_settings_path = lm.computeMyLeoSettingsPath()
    lm.leo_settings_c = lm.openSettingsFile(self.leo_settings_path)
    lm.my_settings_c = lm.openSettingsFile(self.my_settings_path)
    commanders = [lm.leo_settings_c, lm.my_settings_c]
    commanders = [z for z in commanders if z]
    settings_d, bindings_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and bindings_d.
        settings_d, bindings_d = lm.computeLocalSettings(
            c, settings_d, bindings_d, localFlag=False)
    # Adjust the name.
    bindings_d.setName('lm.globalBindingsDict')
    lm.globalSettingsDict = settings_d
    lm.globalBindingsDict = bindings_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    lm.theme_path = lm.computeThemeFilePath()
    if lm.theme_path:
        lm.theme_c = lm.openSettingsFile(lm.theme_path)
        if lm.theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                lm.theme_c, settings_d, bindings_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global vars
            g.app.theme_directory = g.os_path_dirname(lm.theme_path)
                # Used by the StyleSheetManager.
            if trace: g.trace('g.app.theme_directory', g.app.theme_directory)
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
</t>
<t tx="ekr.20120214165710.10726">def createSettingsDicts(self, c, localFlag):

    from leo.core import leoConfig
    if c:
        parser = leoConfig.SettingsTreeParser(c, localFlag)
            # returns the *raw* shortcutsDict, not a *merged* shortcuts dict.
        shortcutsDict, settingsDict = parser.traverse()
        return shortcutsDict, settingsDict
    return None, None
</t>
<t tx="ekr.20120217070122.10479">def reloadSettings(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable-autocompleter-initially')
    self.enable_calltips = getBool('enable-calltips-initially')
    self.ignore_unbound_non_ascii_keys = getBool('ignore-unbound-non-ascii-keys')
    self.minibuffer_background_color = getColor(
        'minibuffer-background-color') or 'lightblue'
    self.minibuffer_foreground_color = getColor(
        'minibuffer-foreground-color') or 'black'
    self.minibuffer_warning_color = getColor(
        'minibuffer-warning-color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer-error-color') or 'red'
    self.replace_meta_with_alt = getBool('replace-meta-with-alt')
    self.warn_about_redefined_shortcuts = getBool('warn-about-redefined-shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable-alt-ctrl-bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body-text-background-color') or 'white'
    fg = c.config.getColor('body-text-foreground-color') or 'black'
    self.command_mode_bg_color = getColor('command-mode-bg-color') or bg
    self.command_mode_fg_color = getColor('command-mode-fg-color') or fg
    self.insert_mode_bg_color = getColor('insert-mode-bg-color') or bg
    self.insert_mode_fg_color = getColor('insert-mode-fg-color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite-mode-bg-color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite-mode-fg-color') or fg
    self.unselected_body_bg_color = getColor('unselected-body-bg-color') or bg
    self.unselected_body_fg_color = getColor('unselected-body-fg-color') or bg
</t>
<t tx="ekr.20120219154958.10483">def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
</t>
<t tx="ekr.20120219154958.10486">def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''abbrev,beauty,cache,coloring,drawing,events,focus,
      git,gnx,importers,ipython,keys,layouts,plugins,save,
      select,shutdown,size,startup,themes,undo,verbose,zoom'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
</t>
<t tx="ekr.20120225072226.10301">def createRecentFilesMenuItems(self, c):
    rf = self
    menu = c.frame.menu
    recentFilesMenu = menu.getMenu(self.recentFilesMenuName)
    if not recentFilesMenu:
        return
    # Delete all previous entries.
    menu.deleteRecentFilesMenuItems(recentFilesMenu)
    # Create the permanent (static) menu entries.
    table = rf.getRecentFilesTable()
    menu.createMenuEntries(recentFilesMenu, table)
    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase  # Not a unicode problem.
    i = 0
    n = len(accel_ch)
    # see if we're grouping when files occur in more than one place
    rf_group = c.config.getBool("recent-files-group")
    rf_always = c.config.getBool("recent-files-group-always")
    groupedEntries = rf_group or rf_always
    if groupedEntries:  # if so, make dict of groups
        dirCount = {}
        for fileName in rf.getRecentFiles()[:n]:
            dirName, baseName = g.os_path_split(fileName)
            if baseName not in dirCount:
                dirCount[baseName] = {'dirs': [], 'entry': None}
            dirCount[baseName]['dirs'].append(dirName)
    for name in rf.getRecentFiles()[:n]:
        # pylint: disable=cell-var-from-loop
        if name.strip() == "":
            continue  # happens with empty list/new file

        def recentFilesCallback(event=None, c=c, name=name):
            c.openRecentFile(fn=name)

        if groupedEntries:
            dirName, baseName = g.os_path_split(name)
            entry = dirCount[baseName]
            if len(entry['dirs']) &gt; 1 or rf_always:  # sub menus
                if entry['entry'] is None:
                    entry['entry'] = menu.createNewMenu(baseName, "Recent Files...")
                    # acts as a flag for the need to create the menu
                c.add_command(menu.getMenu(baseName), label=dirName,
                    command=recentFilesCallback, underline=0)
            else:  # single occurence, no submenu
                c.add_command(recentFilesMenu, label=baseName,
                    command=recentFilesCallback, underline=0)
        else:  # original behavior
            label = f"{accel_ch[i]} {g.computeWindowTitle(name)}"
            c.add_command(recentFilesMenu, label=label,
                command=recentFilesCallback, underline=0)
        i += 1
    if groupedEntries:  # store so we can delete them later
        rf.groupedMenus = [z for z in dirCount
            if dirCount[z]['entry'] is not None]
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120427064024.10064">def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
</t>
<t tx="ekr.20120427064024.10065">def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
</t>
<t tx="ekr.20120427064024.10066">def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
</t>
<t tx="ekr.20120427064024.10068"></t>
<t tx="ekr.20120520174745.9867">@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons &amp;&amp; @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
</t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130823083943.12596">class RecursiveImportController:
    """Recursively import all python files in a directory and clean the result."""
    @others
</t>
<t tx="ekr.20130823083943.12597">def import_dir(self, dir_, parent):
    """Import selected files from dir_, a directory."""
    if g.os_path_isfile(dir_):
        files = [dir_]
    else:
        g.es_print('importing directory:', dir_)
        files = os.listdir(dir_)
    dirs, files2 = [], []
    for path in files:
        try:
            # Fix #408. Catch path exceptions.
            # The idea here is to keep going on small errors.
            path = g.os_path_join(dir_, path)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(path)
                if ext in self.theTypes:
                    files2.append(path)
            elif self.recursive:
                if not self.ignore_pattern.search(path):
                    dirs.append(path)
        except OSError:
            g.es_print('Exception computing', path)
            g.es_exception()
    if files or dirs:
        assert parent and parent.v != self.root.v, g.callers()
        parent = parent.insertAsLastChild()
        parent.v.h = dir_
        if files2:
            for f in files2:
                if not self.ignore_pattern.search(f):
                    self.import_one_file(f, parent=parent)
        if dirs:
            assert self.recursive
            for dir_ in sorted(dirs):
                self.import_dir(dir_, parent)
</t>
<t tx="ekr.20130823083943.12607">def post_process(self, p, prefix):
    """
    Traverse p's tree, replacing all nodes that start with prefix
    by the smallest equivalent @path or @file node.
    """
    self.fix_back_slashes(p)
    prefix = prefix.replace('\\', '/')
    if self.kind not in ('@auto', '@edit'):
        self.remove_empty_nodes(p)
    if p.firstChild():
        self.minimize_headlines(p.firstChild(), prefix)
    self.clear_dirty_bits(p)
    self.add_class_names(p)
</t>
<t tx="ekr.20130823083943.12608">def clear_dirty_bits(self, p):
    c = self.c
    c.clearChanged()  # Clears *all* dirty bits.
    for p in p.self_and_subtree(copy=False):
        p.clearDirty()
</t>
<t tx="ekr.20130823083943.12609">def dump_headlines(self, p):
    # show all headlines.
    for p in p.self_and_subtree(copy=False):
        print(p.h)
</t>
<t tx="ekr.20130823083943.12610">def fix_back_slashes(self, p):
    """Convert backslash to slash in all headlines."""
    for p in p.self_and_subtree(copy=False):
        s = p.h.replace('\\', '/')
        if s != p.h:
            p.v.h = s
</t>
<t tx="ekr.20130823083943.12611">def minimize_headlines(self, p, prefix):
    """Create @path nodes to minimize the paths required in descendant nodes."""
    if prefix and not prefix.endswith('/'):
        prefix = prefix + '/'
    m = self.file_pattern.match(p.h)
    if m:
        # It's an @file node of some kind. Strip off the prefix.
        kind = m.group(0)
        path = p.h[len(kind) :].strip()
        stripped = self.strip_prefix(path, prefix)
        p.h = f"{kind} {stripped or path}"
        # Put the *full* @path directive in the body.
        if self.add_path and prefix:
            tail = g.os_path_dirname(stripped).rstrip('/')
            p.b = f"@path {prefix}{tail}\n{p.b}"
    else:
        # p.h is a path.
        path = p.h
        stripped = self.strip_prefix(path, prefix)
        p.h = f"@path {stripped or path}"
        for p in p.children():
            self.minimize_headlines(p, prefix + stripped)
</t>
<t tx="ekr.20130823083943.12612">def remove_empty_nodes(self, p):
    """Remove empty nodes. Not called for @auto or @edit trees."""
    c = self.c
    aList = [
        p2 for p2 in p.self_and_subtree()
            if not p2.b and not p2.hasChildren()]
    if aList:
        c.deletePositionsInList(aList, redraw=False)
</t>
<t tx="ekr.20130823083943.12613">def run(self, dir_):
    """
    Import all files whose extension matches self.theTypes in dir_.
    In fact, dir_ can be a path to a single file.
    """
    if self.kind not in ('@auto', '@clean', '@edit', '@file', '@nosent'):
        g.es('bad kind param', self.kind, color='red')
    try:
        c = self.c
        p1 = self.root = c.p
        t1 = time.time()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        # Leo 5.6: Always create a new last top-level node.
        last = c.lastTopLevel()
        parent = last.insertAfter()
        parent.v.h = 'imported files'
        # Leo 5.6: Special case for a single file.
        self.n_files = 0
        if g.os_path_isfile(dir_):
            g.es_print('\nimporting file:', dir_)
            self.import_one_file(dir_, parent)
        else:
            self.import_dir(dir_, parent)
        self.post_process(parent, dir_)
            # Fix # 1033.
        c.undoer.afterChangeTree(p1, 'recursive-import', bunch)
    except Exception:
        g.es_print('Exception in recursive import')
        g.es_exception()
    finally:
        g.app.disable_redraw = False
        for p2 in parent.self_and_subtree(copy=False):
            p2.contract()
        c.redraw(parent)
    t2 = time.time()
    n = len(list(parent.self_and_subtree()))
    g.es_print(
        f"imported {n} node{g.plural(n)} "
        f"in {self.n_files} file{g.plural(self.n_files)} "
        f"in {t2 - t1:2.2f} seconds")
</t>
<t tx="ekr.20130823083943.12615">def __init__(self, c, kind,
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    ignore_pattern=None,
):
    """Ctor for RecursiveImportController class."""
    self.c = c
    self.add_path = add_path
    self.file_pattern = re.compile(r'^(@@|@)(auto|clean|edit|file|nosent)')
    self.kind = kind  # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    self.recursive = recursive
    self.root = None
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
    self.ignore_pattern = ignore_pattern or re.compile(r'\.git|node_modules')
    # #1605:

    def set_bool(setting, val):
        if val not in (True, False):
            return
        c.config.set(None, 'bool', setting, val, warn=True)
        
    set_bool('add-context-to-headlines', add_context)
    set_bool('add-file-context-to-headlines', add_file_context)
</t>
<t tx="ekr.20130911110233.11284">def readFileToUnicode(self, fileName):
    '''
    Carefully sets at.encoding, then uses at.encoding to convert the file
    to a unicode string.

    Sets at.encoding as follows:
    1. Use the BOM, if present. This unambiguously determines the encoding.
    2. Use the -encoding= field in the @+leo header, if present and valid.
    3. Otherwise, uses existing value of at.encoding, which comes from:
        A. An @encoding directive, found by at.scanAllDirectives.
        B. The value of c.config.default_derived_file_encoding.

    Returns the string, or None on failure.
    '''
    at = self
    s = at.openFileHelper(fileName)
        # Catches all exceptions.
    # #1798.
    if s is None:
        return None
    e, s = g.stripBOM(s)
    if e:
        # The BOM determines the encoding unambiguously.
        s = g.toUnicode(s, encoding=e)
    else:
        # Get the encoding from the header, or the default encoding.
        s_temp = g.toUnicode(s, 'ascii', reportErrors=False)
        e = at.getEncodingFromHeader(fileName, s_temp)
        s = g.toUnicode(s, encoding=e)
    s = s.replace('\r\n', '\n')
    at.encoding = e
    at.initReadLine(s)
    return s
</t>
<t tx="ekr.20130911110233.11285">def openFileHelper(self, fileName):
    """Open a file, reporting all exceptions."""
    at = self
    # #1798: return None as a flag on any error.
    s = None 
    try:
        with open(fileName, 'rb') as f:
            s = f.read()
    except IOError:
        at.error(f"can not open {fileName}")
    except Exception:
        at.error(f"Exception reading {fileName}")
        g.es_exception()
    return s
</t>
<t tx="ekr.20130911110233.11287">def getEncodingFromHeader(self, fileName, s):
    """
    Return the encoding given in the @+leo sentinel, if the sentinel is
    present, or the previous value of at.encoding otherwise.
    """
    at = self
    if at.errors:
        g.trace('can not happen: at.errors &gt; 0', g.callers())
        e = at.encoding
        if g.unitTesting: assert False, g.callers()
            # This can happen when the showTree command in a unit test is left on.
            # A @file/@clean node is created which refers to a non-existent file.
            # It's surprisingly difficult to set at.error=0 safely elsewhere.
            # Otoh, I'm not sure why this test here is ever really useful.
    else:
        at.initReadLine(s)
        old_encoding = at.encoding
        assert old_encoding
        at.encoding = None
        # Execute scanHeader merely to set at.encoding.
        at.scanHeader(fileName, giveErrors=False)
        e = at.encoding or old_encoding
    assert e
    return e
</t>
<t tx="ekr.20130924035029.12741">def initOneAbbrev(self, commandName, key):
    """Enter key as an abbreviation for commandName in c.commandsDict."""
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
</t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20131016084446.16724">def setComplexCommand(self, commandName):
    """Make commandName the command to be executed by repeat-complex-command."""
    c = self
    c.k.mb_history.insert(0, commandName)
</t>
<t tx="ekr.20131017100903.16689">def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
</t>
<t tx="ekr.20131017174814.17480">def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131111105746.16544">def vim_dot(self):
    """Repeat the last command."""
    if self.in_dot:
        return
    try:
        self.in_dot = True
        # Save the dot list.
        self.old_dot_list = self.dot_list[:]
        # Copy the list so it can't change in the loop.
        for event in self.dot_list[:]:
            # Only k.masterKeyHandler can insert characters!
            #
            # #1757: Create a LeoKeyEvent.
            event = LeoKeyEvent(
                binding=g.KeyStroke(event.stroke),
                c = self.c,
                char=event.char,
                event=event,
                w=self.w,
            )
            self.k.masterKeyHandler(event)
        # For the dot list to be the old dot list, whatever happens.
        self.command_list = self.old_dot_list[:]
        self.dot_list = self.old_dot_list[:]
    finally:
        self.in_dot = False
    self.done()
</t>
<t tx="ekr.20131111140646.16544"># Similar to runEditCommandTest.

def runVimTest(self, p):
    tm = self
    c = self.c
    vc = c.vimCommands
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    s = h[6:].strip()
    # The vim command is everything up to the first blank.
    i = 0
    while i &lt; len(s) and s[i] not in ' \t\n':
        i += 1
    command = s[:i]
    assert command, 'empty vim command'
    assert command, f"no command: {command}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    if 1:
        # pylint: disable=unbalanced-tuple-unpacking
        sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    # The vim-specific part.
    status, n1, command, n2, motion = vc.scan(command)
    assert status == 'done', repr(status)
    vc.exec_(command, n1, n2, motion)
    # Check the result.
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert sel2 == sel3, f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20131117120458.16792">def set_radio_button(self, name):
    """Set the value of the radio buttons"""
    c = self.c
    find = c.findCommands
    d = {
        # Name is not an ivar. Set by find.setFindScope... commands.
        'node-only': self.radio_button_node_only,
        'entire-outline': self.radio_button_entire_outline,
        'suboutline-only': self.radio_button_suboutline_only,
    }
    w = d.get(name)
    # Most of the work will be done in the radio button callback.
    if not w.isChecked():
        w.toggle()
    if find.minibuffer_mode:
        find.show_find_options_in_status_area()
</t>
<t tx="ekr.20131117164142.16916">@cmd('find-tab-open')
def open_find_tab(self, event=None, show=True):  # pragma: no cover (cmd)
    """Open the Find tab in the log pane."""
    c = self.c
    if c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
</t>
<t tx="ekr.20131117164142.16919">@cmd('toggle-find-collapses-nodes')
def toggle_find_collapes_nodes(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Collapse Nodes' checkbox in the find tab."""
    c = self.c
    c.sparse_find = not c.sparse_find
    if not g.unitTesting:
        g.es('sparse_find', c.sparse_find)

@cmd('toggle-find-ignore-case-option')
def toggle_ignore_case_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Ignore Case' checkbox in the Find tab."""
    return self.toggle_option('ignore_case')

@cmd('toggle-find-mark-changes-option')
def toggle_mark_changes_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Mark Changes' checkbox in the Find tab."""
    return self.toggle_option('mark_changes')

@cmd('toggle-find-mark-finds-option')
def toggle_mark_finds_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Mark Finds' checkbox in the Find tab."""
    return self.toggle_option('mark_finds')

@cmd('toggle-find-regex-option')
def toggle_regex_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Regexp' checkbox in the Find tab."""
    return self.toggle_option('pattern_match')

@cmd('toggle-find-in-body-option')
def toggle_search_body_option(self, event):  # pragma: no cover (cmd)
    """Set the 'Search Body' checkbox in the Find tab."""
    return self.toggle_option('search_body')

@cmd('toggle-find-in-headline-option')
def toggle_search_headline_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Search Headline' checkbox in the Find tab."""
    return self.toggle_option('search_headline')

@cmd('toggle-find-word-option')
def toggle_whole_word_option(self, event):  # pragma: no cover (cmd)
    """Toggle the 'Whole Word' checkbox in the Find tab."""
    return self.toggle_option('whole_word')

# @cmd('toggle-find-wrap-around-option')
# def toggleWrapSearchOption(self, event):
    # """Toggle the 'Wrap Around' checkbox in the Find tab."""
    # return self.toggle_option('wrap')

def toggle_option(self, checkbox_name):  # pragma: no cover (cmd)
    c, fc = self.c, self.c.findCommands
    self.ftm.toggle_checkbox(checkbox_name)
    options = fc.compute_find_options_in_status_area()
    c.frame.statusLine.put(options)
</t>
<t tx="ekr.20131117164142.16939"></t>
<t tx="ekr.20131117164142.16941">@cmd('isearch-forward')
def isearch_forward(self, event):  # pragma: no cover (cmd)
    """
    Begin a forward incremental search.

    - Plain characters extend the search.
    - !&lt;isearch-forward&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-forward',
        forward=True, ignoreCase=False, regexp=False)
</t>
<t tx="ekr.20131117164142.16942">@cmd('isearch-backward')
def isearch_backward(self, event):  # pragma: no cover (cmd)
    """
    Begin a backward incremental search.

    - Plain characters extend the search backward.
    - !&lt;isearch-forward&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-backward',
        forward=False, ignoreCase=False, regexp=False)
</t>
<t tx="ekr.20131117164142.16943">@cmd('isearch-forward-regexp')
def isearch_forward_regexp(self, event):  # pragma: no cover (cmd)
    """
    Begin a forward incremental regexp search.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-forward-regexp',
        forward=True, ignoreCase=False, regexp=True)
</t>
<t tx="ekr.20131117164142.16944">@cmd('isearch-backward-regexp')
def isearch_backward_regexp(self, event):  # pragma: no cover (cmd)
    """
    Begin a backward incremental regexp search.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-backward-regexp',
        forward=False, ignoreCase=False, regexp=True)
</t>
<t tx="ekr.20131117164142.16945">@cmd('isearch-with-present-options')
def isearch_with_present_options(self, event):  # pragma: no cover (cmd)
    """
    Begin an incremental search using find panel options.

    - Plain characters extend the search.
    - !&lt;isearch-forward-regexp&gt;! repeats the search.
    - Esc or any non-plain key ends the search.
    - Backspace reverses the search.
    - Backspacing to an empty search pattern
      completely undoes the effect of the search.
    """
    self.start_incremental(event, 'isearch-with-present-options',
        forward=None, ignoreCase=None, regexp=None)
</t>
<t tx="ekr.20131117164142.16946"></t>
<t tx="ekr.20131117164142.16947">def abort_search(self):  # pragma: no cover (cmd)
    """Restore the original position and selection."""
    c, k = self.c, self.k
    w = c.frame.body.wrapper
    k.clearState()
    k.resetLabel()
    p, i, j, in_headline = self.stack[0]
    self.in_headline = in_headline
    c.selectPosition(p)
    c.redraw_after_select(p)
    c.bodyWantsFocus()
    w.setSelectionRange(i, j)
</t>
<t tx="ekr.20131117164142.16948">def end_search(self):  # pragma: no cover (cmd)
    c, k = self.c, self.k
    k.clearState()
    k.resetLabel()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20131117164142.16949">def iSearch_helper(self, again=False):  # pragma: no cover (cmd)
    """Handle the actual incremental search."""
    c, k, p = self.c, self.k, self.c.p
    reverse = not self.isearch_forward_flag
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        self.abort_search()
        return
    # Settings...
    self.find_text = self.ftm.get_find_text()
    self.change_text = self.ftm.get_change_text()
    # Save
    oldPattern = self.find_text
    oldRegexp = self.pattern_match
    oldWord = self.whole_word
    # Override
    self.pattern_match = self.isearch_regexp
    self.reverse = reverse
    self.find_text = pattern
    self.whole_word = False  # Word option can't be used!
    # Prepare the search.
    if len(self.stack) &lt;= 1:
        self.in_headline = False
    # Init the work widget from the gui widget.
    gui_w = self.set_widget()
    s = gui_w.getAllText()
    i, j = gui_w.getSelectionRange()
    if again:
        ins = i if reverse else j + len(pattern)
    else:
        ins = j + len(pattern) if reverse else i
    self.work_s = s
    self.work_sel = (ins, ins, ins)
    # Do the search!
    p, pos, newpos = self.find_next_match(p)
    # Restore.
    self.find_text = oldPattern
    self.pattern_match = oldRegexp
    self.reverse = False
    self.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None:  # success.
        w = self.show_success(p, pos, newpos, showState=False)
        if w:
            i, j = w.getSelectionRange(sort=False)
        if not again:
            self.push(c.p, i, j, self.in_headline)
    else:
        g.es(f"not found: {pattern}")
        if not again:
            event = g.app.gui.create_key_event(
                c, binding='BackSpace', char='\b', w=w)
            k.updateLabel(event)
</t>
<t tx="ekr.20131117164142.16950">def isearch_state_handler(self, event):  # pragma: no cover (cmd)
    """The state manager when the state is 'isearch"""
    # c = self.c
    k = self.k
    stroke = event.stroke if event else None
    s = stroke.s if stroke else ''
    # No need to recognize ctrl-z.
    if s in ('Escape', '\n', 'Return'):
        self.end_search()
    elif stroke in self.iSearchStrokes:
        self.iSearch_helper(again=True)
    elif s in ('\b', 'BackSpace'):
        k.updateLabel(event)
        self.isearch_backspace()
    elif (
        s.startswith('Ctrl+') or
        s.startswith('Alt+') or
        k.isFKey(s)  # 2011/06/13.
    ):
        # End the search.
        self.end_search()
        k.masterKeyHandler(event)
    # Fix bug 1267921: isearch-forward accepts non-alphanumeric keys as input.
    elif k.isPlainKey(stroke):
        k.updateLabel(event)
        self.iSearch_helper()
</t>
<t tx="ekr.20131117164142.16951">def isearch_backspace(self):  # pragma: no cover (cmd)

    c = self.c
    if len(self.stack) &lt;= 1:
        self.abort_search()
        return
    # Reduce the stack by net 1.
    self.pop()
    p, i, j, in_headline = self.pop()
    self.push(p, i, j, in_headline)
    if in_headline:
        # Like self.show_success.
        selection = i, j, i
        c.redrawAndEdit(p, selectAll=False,
            selection=selection,
            keepMinibuffer=True)
    else:
        c.selectPosition(p)
        w = c.frame.body.wrapper
        c.bodyWantsFocus()
        if i &gt; j: i, j = j, i
        w.setSelectionRange(i, j)
    if len(self.stack) &lt;= 1:
        self.abort_search()
</t>
<t tx="ekr.20131117164142.16952">def get_strokes(self, commandName):  # pragma: no cover (cmd)
    aList = self.inverseBindingDict.get(commandName, [])
    return [key for pane, key in aList]
</t>
<t tx="ekr.20131117164142.16953">def push(self, p, i, j, in_headline):  # pragma: no cover (cmd)
    data = p.copy(), i, j, in_headline
    self.stack.append(data)

def pop(self):  # pragma: no cover (cmd)
    data = self.stack.pop()
    p, i, j, in_headline = data
    return p, i, j, in_headline
</t>
<t tx="ekr.20131117164142.16954">def set_widget(self):  # pragma: no cover (cmd)
    c = self.c; p = c.currentPosition()
    wrapper = c.frame.body.wrapper
    if self.in_headline:
        w = c.edit_widget(p)
        if not w:
            # Selecting the minibuffer can kill the edit widget.
            selection = 0, 0, 0
            c.redrawAndEdit(p, selectAll=False,
                selection=selection, keepMinibuffer=True)
            w = c.edit_widget(p)
        if not w:  # Should never happen.
            g.trace('**** no edit widget!')
            self.in_headline = False; w = wrapper
    else:
        w = wrapper
    if w == wrapper:
        c.bodyWantsFocus()
    return w
</t>
<t tx="ekr.20131117164142.16955">def start_incremental(self, event, commandName, forward, ignoreCase, regexp):  # pragma: no cover (cmd)
    c, k = self.c, self.k
    # None is a signal to get the option from the find tab.
    self.event = event
    self.isearch_forward_flag = not self.reverse if forward is None else forward
    self.isearch_ignore_case = self.ignore_case if ignoreCase is None else ignoreCase
    self.isearch_regexp = self.pattern_match if regexp is None else regexp
    # Note: the word option can't be used with isearches!
    w = c.frame.body.wrapper
    self.p1 = c.p
    self.sel1 = w.getSelectionRange(sort=False)
    i, j = self.sel1
    self.push(c.p, i, j, self.in_headline)
    self.inverseBindingDict = k.computeInverseBindingDict()
    self.iSearchStrokes = self.get_strokes(commandName)
    k.setLabelBlue(
        "Isearch"
        f"{' Backward' if not self.isearch_forward_flag else ''}"
        f"{' Regexp' if self.isearch_regexp else ''}"
        f"{' NoCase' if self.isearch_ignore_case else ''}"
        ": "
    )
    k.setState('isearch', 1, handler=self.isearch_state_handler)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20131117164142.16989">@cmd('show-find-options')
def show_find_options(self, event=None):  # pragma: no cover (cmd)
    """
    Show the present find options in the status line.
    This is useful for commands like search-forward that do not show the Find Panel.
    """
    frame = self.c.frame
    frame.clearStatusLine()
    part1, part2 = self.compute_find_options()
    frame.putStatusLine(part1, bg='blue')
    frame.putStatusLine(part2)
</t>
<t tx="ekr.20131117164142.16992">def add_change_string_to_label(self):  # pragma: no cover (cmd)
    """Add an unprotected change string to the minibuffer label."""
    c = self.c
    s = self.ftm.get_change_text()
    c.minibufferWantsFocus()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    c.k.extendLabel(s, select=True, protect=False)
</t>
<t tx="ekr.20131117164142.16993">def add_find_string_to_label(self, protect=True):  # pragma: no cover (cmd)
    c, k = self.c, self.c.k
    ftm = c.findCommands.ftm
    s = ftm.get_find_text()
    c.minibufferWantsFocus()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    k.extendLabel(s, select=True, protect=protect)
</t>
<t tx="ekr.20131117164142.16994">@cmd('change-all')
@cmd('replace-all')
def interactive_change_all(self, event=None):  # pragma: no cover (interactive)
    """Replace all instances of the search string with the replacement string."""
    self.ftm.clear_focus()
    self.ftm.set_entry_focus()
    prompt = 'Replace Regex: ' if self.pattern_match else 'Replace: '
    self.start_state_machine(event, prompt,
        handler=self.interactive_replace_all1,
        # Allow either '\t' or '\n' to switch to the change text.
        escape_handler=self.interactive_replace_all1,
    )

def interactive_replace_all1(self, event):  # pragma: no cover (interactive)
    k = self.k
    find_pattern = k.arg
    self._sString = k.arg
    self.update_find_list(k.arg)
    regex = ' Regex' if self.pattern_match else ''
    prompt = f"Replace{regex}: {find_pattern} With: "
    k.setLabelBlue(prompt)
    self.add_change_string_to_label()
    k.getNextArg(self.interactive_replace_all2)

def interactive_replace_all2(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper

    # Update settings data.
    find_pattern = self._sString
    change_pattern = k.arg
    self.init_vim_search(find_pattern)
    self.update_change_list(change_pattern)
    # Compute settings...
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    # Do the command!
    self.do_change_all(settings)
</t>
<t tx="ekr.20131117164142.16996">@cmd('clone-find-all-flattened')
# @cmd('find-clone-all-flattened')
@cmd('cff')
def interactive_cff(
    self, event=None, preloaded=None):  # pragma: no cover (interactive)
    """
    clone-find-all-flattened (aka find-clone-all-flattened and cff).

    Create an organizer node whose direct children are clones of all nodes
    matching the search string, except @nosearch trees.

    The list is flattened: every cloned node appears as a direct child
    of the organizer node, even if the clone also is a descendant of
    another cloned node.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    if not preloaded:
        self.preload_find_pattern(w)
    self.start_state_machine(event,
        prefix='Clone Find All Flattened: ',
        handler=self.interactive_cff1)

def interactive_cff1(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    pattern = k.arg
    self.ftm.set_find_text(pattern)
    self.init_vim_search(pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    count = self.do_clone_find_all(settings)
    if count:
        c.redraw()
        c.treeWantsFocus()
    return count
</t>
<t tx="ekr.20131117164142.16998">@cmd('find-all')
def interactive_find_all(self, event=None):  # pragma: no cover (interactive)
    """
    Create a summary node containing descriptions of all matches of the
    search string.
    
    Typing tab converts this to the change-all command.
    """
    self.ftm.clear_focus()
    self.ftm.set_entry_focus()
    self.start_state_machine(event, 'Search: ',
        handler=self.interactive_find_all1,
        escape_handler=self.find_all_escape_handler,
    )

def interactive_find_all1(self, event=None):  # pragma: no cover (interactive)
    k = self.k
    # Settings.
    find_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    ##self.init_in_headline()
    settings = self.ftm.get_settings()
    self.find_text = find_pattern
    self.change_text = self.ftm.get_change_text()
    self.update_find_list(find_pattern)
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_find_all(settings)

def find_all_escape_handler(self, event):  # pragma: no cover (interactive)
    k = self.k
    prompt = 'Replace ' + ('Regex' if self.pattern_match else 'String')
    find_pattern = k.arg
    self._sString = k.arg
    self.update_find_list(k.arg)
    s = f"{prompt}: {find_pattern} With: "
    k.setLabelBlue(s)
    self.add_change_string_to_label()
    k.getNextArg(self.find_all_escape_handler2)

def find_all_escape_handler2(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    find_pattern = self._sString
    change_pattern = k.arg
    self.update_change_list(change_pattern)
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_change_all(settings)
</t>
<t tx="ekr.20131117164142.17003">@cmd('re-search')
@cmd('re-search-forward')
def interactive_re_search_forward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, with regex."""
    # Set flag for show_find_options.
    self.pattern_match = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_pattern_match = True
    # Go.
    self.start_state_machine(event,
        prefix='Regexp Search: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17004">@cmd('search-backward')
def interactive_search_backward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, but in reverse."""
    # Set flag for show_find_options.
    self.reverse = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_reverse = True
    # Go.
    self.start_state_machine(event,
        prefix='Search Backward: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17007">def start_state_machine(self, event, prefix, handler, escape_handler=None):  # pragma: no cover (cmd)
    """
    Initialize and start the state machine used to get user arguments.
    """
    c, k = self.c, self.k
    w = c.frame.body.wrapper
    if not w:
        return
    # Gui...
    k.setLabelBlue(prefix)
    # New in Leo 5.2: minibuffer modes shows options in status area.
    if self.minibuffer_mode:
        self.show_find_options_in_status_area()
    elif c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
    self.add_find_string_to_label(protect=False)
    k.getArgEscapes = ['\t'] if escape_handler else []
    self.handler = handler
    self.escape_handler = escape_handler
    # Start the state maching!
    k.get1Arg(event, handler=self.state0, tabList=self.findTextList, completion=True)

def state0(self, event):  # pragma: no cover (cmd)
    """Dispatch the next handler."""
    k = self.k
    if k.getArgEscapeFlag:
        k.getArgEscapeFlag = False
        self.escape_handler(event)
    else:
        self.handler(event)
</t>
<t tx="ekr.20131117164142.17008">def update_change_list(self, s):  # pragma: no cover (cmd)
    if s not in self.changeTextList:
        self.changeTextList.append(s)

def update_find_list(self, s):  # pragma: no cover (cmd)
    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20131117164142.17009">@cmd('word-search-backward')
def word_search_backward(self, event):  # pragma: no cover (interactive)
    # Set flags for show_find_options.
    self.reverse = True
    self.whole_world = True
    self.show_find_options()
    # Set flags for do_find_next().
    self.request_reverse = True
    self.request_whole_world = True
    # Go
    self.start_state_machine(event,
        prefix='Word Search Backward: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20131117164142.17011">@cmd('clone-find-all')
@cmd('find-clone-all')
@cmd('cfa')
def interactive_clone_find_all(
    self, event=None, preloaded=None):  # pragma: no cover (interactive)
    """
    clone-find-all ( aka find-clone-all and cfa).

    Create an organizer node whose descendants contain clones of all nodes
    matching the search string, except @nosearch trees.

    The list is *not* flattened: clones appear only once in the
    descendants of the organizer node.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    if not preloaded:
        self.preload_find_pattern(w)
    self.start_state_machine(event,
        prefix='Clone Find All: ',
        handler=self.interactive_clone_find_all1)

def interactive_clone_find_all1(self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    pattern = k.arg
    self.ftm.set_find_text(pattern)
    self.init_vim_search(pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    count = self.do_clone_find_all(settings)
    if count:
        c.redraw()
        c.treeWantsFocus()
    return count
</t>
<t tx="ekr.20131117164142.17013"></t>
<t tx="ekr.20131117164142.17015">@cmd('find-tab-hide')
def hide_find_tab(self, event=None):  # pragma: no cover (cmd)
    """Hide the Find tab."""
    c = self.c
    if self.minibuffer_mode:
        c.k.keyboardQuit()
    else:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20131117164142.17016">def do_change_all(self, settings):
    c = self.c
    # Settings...
    self.init_ivars_from_settings(settings)
    if not self.check_args('change-all'):
        return 0
    n = self._change_all_helper(settings)
    #
    # Bugs #947, #880 and #722:
    # Set ancestor @&lt;file&gt; nodes by brute force.
    for p in c.all_positions():  # pragma: no cover
        if (
            p.anyAtFileNodeName()
            and not p.v.isDirty()
            and any([p2.v.isDirty() for p2 in p.subtree()])
        ):
            p.setDirty()
    c.redraw()
    return n
</t>
<t tx="ekr.20131117164142.17019">@cmd('set-find-everywhere')
def set_find_scope_every_where(self, event=None):  # pragma: no cover (cmd)
    """Set the 'Entire Outline' radio button in the Find tab."""
    return self.set_find_scope('entire-outline')

@cmd('set-find-node-only')
def set_find_scope_node_only(self, event=None):  # pragma: no cover (cmd)
    """Set the 'Node Only' radio button in the Find tab."""
    return self.set_find_scope('node-only')

@cmd('set-find-suboutline-only')
def set_find_scope_suboutline_only(self, event=None):
    """Set the 'Suboutline Only' radio button in the Find tab."""
    return self.set_find_scope('suboutline-only')

def set_find_scope(self, where):
    """Set the radio buttons to the given scope"""
    c, fc = self.c, self.c.findCommands
    self.ftm.set_radio_button(where)
    options = fc.compute_find_options_in_status_area()
    c.frame.statusLine.put(options)
</t>
<t tx="ekr.20131117164142.17021"></t>
<t tx="ekr.20131117164142.17022">def finishCreate(self):
    # New in 4.11.1.
    # Must be called when config settings are valid.
    c = self.c
    self.reload_settings()
    # now that configuration settings are valid,
    # we can finish creating the Find pane.
    dw = c.frame.top
    if dw: dw.finishCreateLogPane()
</t>
<t tx="ekr.20131119060731.22452">@cmd('start-search')
@cmd('search-forward')  # Compatibility.
def start_search(self, event):  # pragma: no cover (interactive)
    """
    The default binding of Ctrl-F.
    
    Also contains default state-machine entries for find/change commands.
    """
    w = self.c.frame.body.wrapper
    if not w:
        return
    self.preload_find_pattern(w)
    if self.minibuffer_mode:
        # Set up the state machine.
        self.ftm.clear_focus()
        self.changeAllFlag = False
        self.findAllUniqueFlag = False
        self.ftm.set_entry_focus()
        self.start_state_machine(event,
            prefix='Search: ',
            handler=self.start_search1,
            escape_handler=self.start_search_escape1,
        )
    else:
        self.open_find_tab(event)
        self.ftm.init_focus()
        return

startSearch = start_search  # Compatibility. Do not delete.
</t>
<t tx="ekr.20131119204029.16479">def help_for_find_commands(self, event=None):  # pragma: no cover (cmd)
    """Called from Find panel.  Redirect."""
    self.c.helpCommands.help_for_find_commands(event)
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131123071505.16465">def _fail_outside_range(self, p):  # pragma: no cover
    """
    Return True if the search is about to go outside its range, assuming
    both the headline and body text of the present node have been searched.
    """
    c = self.c
    if not p:
        return True
    if self.node_only:
        return True
    if self.suboutline_only:
        if self.root and p != self.root and not self.root.isAncestorOf(p):
            return True
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.trace('outside hoist', p.h)
            g.warning('found match outside of hoisted outline')
            return True
    return False  # Within range.
</t>
<t tx="ekr.20131123071505.16467">def precompile_pattern(self):
    """Precompile the regexp pattern if necessary."""
    try:  # Precompile the regexp.
        # pylint: disable=no-member
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        # Escape the search text.
        # Ignore the whole_word option.
        s = self.find_text
        # A bad idea: insert \b automatically.
            # b, s = '\\b', self.find_text
            # if self.whole_word:
                # if not s.startswith(b): s = b + s
                # if not s.endswith(b): s = s + b
        self.re_obj = re.compile(s, flags)
        return True
    except Exception:
        if not g.unitTesting:
            g.warning('invalid regular expression:', self.find_text)
        return False
</t>
<t tx="ekr.20131123132043.16476">def _fnm_next_after_fail(self, p):
    """Return the next node after a failed search or None."""
    # Move to the next position.
    p = p.threadBack() if self.reverse else p.threadNext()
    # Check it.
    if p and self._fail_outside_range(p):  # pragma: no cover
        return None
    if not p:  # pragma: no cover
        return None
    return p
</t>
<t tx="ekr.20131124060912.16472">def _fnm_should_stay_in_node(self, p):
    """Return True if the find should simply switch panes."""
    # Errors here cause the find command to fail badly.
    # Switch only if:
    #   a) searching both panes and,
    #   b) this is the first pane of the pair.
    # There is *no way* this can ever change.
    # So simple in retrospect, so difficult to see.
    return (
        self.search_headline and self.search_body and (
        (self.reverse and not self.in_headline) or
        (not self.reverse and self.in_headline)))
</t>
<t tx="ekr.20131124060912.16473">def _fnm_first_search_pane(self):
    """
    Set return the value of self.in_headline
    indicating which pane to search first.
    """
    if self.search_headline and self.search_body:
        # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
        if self.reverse:
            return False  # Search the body pane first.
        return True  # Search the headline pane first.
    if self.search_headline or self.search_body:
        # Search the only enabled pane.
        return self.search_headline
    g.trace('can not happen: no search enabled')
    return False  # pragma: no cover (now search the body)
</t>
<t tx="ekr.20131126085250.16651">def focus_in_tree(self):
    """
    Return True is the focus widget w is anywhere in the tree pane.

    Note: the focus may be in the find pane.
    """
    c = self.c
    ftm = self.ftm
    w = ftm and ftm.entry_focus or g.app.gui.get_focus(raw=True)
    if ftm:
        ftm.entry_focus = None  # Only use this focus widget once!
    w_name = c.widget_name(w)
    if w == c.frame.body.wrapper:
        val = False
    elif w == c.frame.tree.treeWidget:  # pragma: no cover
        val = True
    else:
        val = w_name.startswith('head')  # pragma: no cover
    return val
</t>
<t tx="ekr.20131222112420.16371">def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self) -&gt; bool:
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140203082618.15486">def __get_script(self):
    p = self
    return g.getScript(p.v.context, p,
        useSelectedText=False,  # Always return the entire expansion.
        forcePythonSentinels=True,
        useSentinels=False)

script = property(
    __get_script,  # __set_script,
    doc="position property returning the script formed by p and its descendants")
</t>
<t tx="ekr.20140218040104.16761">def __get_nosentinels(self):
    p = self
    return ''.join([z for z in g.splitLines(p.b) if not g.isDirective(z)])

nosentinels = property(
    __get_nosentinels,  # __set_nosentinels
    doc="position property returning the body text without sentinels")
</t>
<t tx="ekr.20140221085636.16685">def do_key(self, event):
    """
    Handle the next key in vim mode:
    - Set event, w, stroke and ch ivars for *all* handlers.
    - Call handler().
    Return True if k.masterKeyHandler should handle this key.
    """
    try:
        self.init_scanner_vars(event)
        self.do_trace(blank_line=True)
        self.return_value = None
        if not self.handle_specials():
            self.handler()
        if self.return_value not in (True, False):
            # It looks like no acceptance method has been called.
            self.oops(
                f"bad return_value: {repr(self.return_value)} "
                f"{self.state} {self.next_func}")
            self.done()  # Sets self.return_value to True.
    except Exception:
        g.es_exception()
        self.quit()
    return self.return_value
</t>
<t tx="ekr.20140613141207.17673">def deletenodes_rclick_cb():

    if len(pl) == 1:
        # sometimes this may leave the selected node in a more
        # convenient place than the generalized case below
        c.deleteOutline()  # handles undo, redraw, etc.
        return
    c.endEditing()
    cull = []
    # try and find the best node to select when this is done
    nextviz = []
    tmp = pl[0].copy().moveToVisBack(c)
    if tmp:
        nextviz.append(tmp.v)
    tmp = pl[-1].copy().moveToVisNext(c)
    if tmp:
        nextviz.append(tmp.v)
    for nd in pl:
        cull.append((nd.v, nd.parent().v or None))
    u.beforeChangeGroup(current,undoType)
    for v, vp in cull:
        for pos in c.vnode2allPositions(v):
            if c.positionExists(pos) and pos.parent().v == vp:
                bunch = u.beforeDeleteNode(pos)
                pos.doDelete()
                u.afterDeleteNode(pos,undoType,bunch)
                c.setChanged()
                break
    u.afterChangeGroup(current,undoType)
    # move to a node that still exists
    for v in nextviz:
        pos = c.vnode2position(v)
        if c.positionExists(pos):
            c.selectPosition(pos)
            break
    else:
        # c.selectPosition(c.allNodes_iter().next())
        c.selectPosition(c.rootPosition())
    c.redraw()
</t>
<t tx="ekr.20140630110633.16726"># Tangle code.
j = g.skip_blank_lines(s, i)
i, code, new_delims, reflist = self.skip_code(s, j, delims)
part = self.st_enter_section_name(section_name, code, doc, delims, new_delims)
delims = new_delims
# Untangle code
if not self.tangling:
    # part may be zero if there was an empty code section (doc part only)
    # In untangle stage1 such code produces no reference list,
    #    thus nothing to do.
    # In untangle stage2, such code cannot be updated because it
    # was either not emitted to the external file or emitted as a doc part only
    #     in either case, there is no code section to update, and we don't
    #     update doc parts.
    if part &gt; 0:
        if self.untangle_stage1:
            section = self.st_lookup(section_name)
            section.parts[part - 1].reflist(refs=reflist)
        else:
            head = s[: j]; tail = s[i:]
            s, i, changed = self.update_def(section_name, part, head, code, tail)
            if changed: anyChanged = True
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140724064952.18038">def dispatch(self, ext, p):
    """Return the correct scanner function for p, an @auto node."""
    # Match the @auto type first, then the file extension.
    c = self.c
    return g.app.scanner_for_at_auto(c, p) or g.app.scanner_for_ext(c, ext)
</t>
<t tx="ekr.20140724073946.18050">def get_import_filename(self, fileName, parent):
    """Return the absolute path of the file and set .default_directory."""
    c = self.c
    self.default_directory = g.setDefaultDirectory(c, parent, importing=False)
    fileName = g.os_path_finalize_join(self.default_directory, fileName)  # 1341
    fileName = fileName.replace('\\', '/')  # 2011/11/25
    return fileName
</t>
<t tx="ekr.20140724175458.18052">def init_import(self, atShadow, ext, fileName, s):
    """
    Init ivars imports and read the file into s.
    Return ext, s.
    """
    junk, self.fileName = g.os_path_split(fileName)
    self.methodName, self.fileType = g.os_path_splitext(self.fileName)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        # Set the kind for error messages in readFileIntoString.
        s, e = g.readFileIntoString(
            fileName,
            encoding=self.encoding,
            kind='@shadow ' if atShadow else '@auto ',
        )
            # Kind is used only for messages.
        if s is None:
            return None, None
        if e: self.encoding = e
    if self.treeType == '@root':
        self.rootLine = "@root-code " + self.fileName + '\n'
    else:
        self.rootLine = ''
    return ext, s
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins contain the write code for all kinds of special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140802120757.18001">def save_body(self):
    """Undoably preserve any changes to body text."""
    c = self.c
    w = self.command_w or self.w
    name = c.widget_name(w)
    if w and name.startswith('body'):
        # Similar to selfInsertCommand.
        oldSel = self.old_sel or w.getSelectionRange()
        newText = w.getAllText()
        if c.p.b != newText:
            # To do: set undoType to the command spelling?
            # undoType = ''.join(self.command_list) or 'Typing'
            c.frame.body.onBodyChanged(undoType='vc-save-body', oldSel=oldSel)
</t>
<t tx="ekr.20140802120757.18003">def init_scanner_vars(self, event):
    """Init all ivars used by the scanner."""
    assert event
    self.event = event
    stroke = event.stroke
    self.ch = event.char  # Required for f,F,t,T.
    self.stroke = stroke.s if g.isStroke(stroke) else stroke
    self.w = event and event.w
    if not self.in_command:
        self.in_command = True  # May be cleared later.
        if self.is_text_wrapper(self.w):
            self.old_sel = self.w.getSelectionRange()
</t>
<t tx="ekr.20140802225657.18021">def handle_specials(self):
    """Return True self.stroke is an Escape or a Return in the outline pane."""
    if self.stroke == 'Escape':
        # k.masterKeyHandler handles Ctrl-G.
        # Escape will end insert mode.
        self.vim_esc()
        return True
    if self.stroke == '\n' and self.in_headline(self.w):
        # End headline editing and enter normal mode.
        self.c.endEditing()
        self.done()
        return True
    return False
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140813052702.18203">def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
</t>
<t tx="ekr.20140816165728.18968"># New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    &lt;&lt; docstring for k.get1arg &gt;&gt;
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
</t>
<t tx="ekr.20140822051549.18298">def setStatusLabel(self, s):
    """
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    """
    k = self
    k.setLabel(s, protect=False)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140901062324.18604">if 0:  # Not yet.

    def scrollDelegate(self, kind):
        """
        Scroll a QTextEdit up or down one page.
        direction is in ('down-line','down-page','up-line','up-page')
        """
        c = self.c
        w = self.widget
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        n = max(2, n - 3)
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + (delta * lineSpacing))
        c.bodyWantsFocus()
</t>
<t tx="ekr.20140901062324.18698">def setFocus(self):
    """QTextMixin"""
    if 'focus' in g.app.debug:
        print('BaseQTextWrapper.setFocus', self.widget)
    # Call the base class
    assert isinstance(self.widget, (
        QtWidgets.QTextBrowser,
        QtWidgets.QLineEdit,
        QtWidgets.QTextEdit,
        Qsci and Qsci.QsciScintilla,
    )), self.widget
    QtWidgets.QTextBrowser.setFocus(self.widget)
</t>
<t tx="ekr.20140901062324.18703">def appendText(self, s):
    """QTextMixin"""
    s2 = self.getAllText()
    self.setAllText(s2 + s)
    self.setInsertPoint(len(s2))
</t>
<t tx="ekr.20140901062324.18704">def getLastPosition(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)

def getLength(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)
</t>
<t tx="ekr.20140901062324.18705">def getSelectedText(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    if i == j:
        return ''
    s = self.getAllText()
    return s[i:j]
</t>
<t tx="ekr.20140901062324.18712">def tag_configure(self, *args, **keys):

    if len(args) == 1:
        key = args[0]
        self.tags[key] = keys
        val = keys.get('foreground')
        underline = keys.get('underline')
        if val:
            self.configDict[key] = val
        if underline:
            self.configUnderlineDict[key] = True
    else:
        g.trace('oops', args, keys)

tag_config = tag_configure
</t>
<t tx="ekr.20140901062324.18714">def onTextChanged(self):
    """
    Update Leo after the body has been changed.

    tree.tree_select_lockout is True during the entire selection process.
    """
    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    w = self
    c = self.c; p = c.p
    tree = c.frame.tree
    if w.changingText:
        return
    if tree.tree_select_lockout:
        g.trace('*** LOCKOUT', g.callers())
        return
    if not p:
        return
    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText()  # Converts to unicode.
    # Get the previous values from the VNode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.error('*** unexpected non-change')
        return
    i, j = p.v.selectionStart, p.v.selectionLength
    oldSel = (i, i + j)
    c.undoer.doTyping(p, 'Typing', oldText, newText,
        oldSel=oldSel, oldYview=None, newInsert=newInsert, newSel=newSel)
</t>
<t tx="ekr.20140901062324.18716">def onCursorPositionChanged(self, event=None):
    
    c = self.c
    name = c.widget_name(self)
    # Apparently, this does not cause problems
    # because it generates no events in the body pane.
    if not name.startswith('body'):
        return
    if hasattr(c.frame, 'statusLine'):
        c.frame.statusLine.update()
</t>
<t tx="ekr.20140901062324.18717"></t>
<t tx="ekr.20140901062324.18719">class QTextMixin:
    """A minimal mixin class for QTextEditWrapper and QScintillaWrapper classes."""
    @others
</t>
<t tx="ekr.20140901062324.18721">def injectIvars(self, name='1', parentFrame=None):
    """Inject standard leo ivars into the QTextEdit or QsciScintilla widget."""
    w = self
    p = self.c.currentPosition()
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    w.leo_frame = None
    w.leo_name = name
    w.leo_label = None
    return w
</t>
<t tx="ekr.20140901062324.18729">def rememberSelectionAndScroll(self):

    w = self
    v = self.c.p.v  # Always accurate.
    v.insertSpot = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if i &gt; j: i, j = j, i
    assert(i &lt;= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.getYScrollPosition()
</t>
<t tx="ekr.20140901062324.18732">def __init__(self, c=None):
    """Ctor for QTextMixin class"""
    self.c = c
    self.changingText = False  # A lockout for onTextChanged.
    self.enabled = True
    self.supportsHighLevelInterface = True
        # A flag for k.masterKeyHandler and isTextWrapper.
    self.tags = {}
    self.permanent = True  # False if selecting the minibuffer will make the widget go away.
    self.configDict = {}  # Keys are tags, values are colors (names or values).
    self.configUnderlineDict = {}  # Keys are tags, values are True
    # self.formatDict = {} # Keys are tags, values are actual QTextFormat objects.
    self.useScintilla = False  # This is used!
    self.virtualInsertPoint = None
    if c:
        self.injectIvars(c)
</t>
<t tx="ekr.20140901062324.18825">def getName(self):
    return self.name  # Essential.
</t>
<t tx="ekr.20140901062324.18827">def deleteTextSelection(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    self.delete(i, j)
</t>
<t tx="ekr.20140901122110.18733"># These are independent of the kind of Qt widget.
</t>
<t tx="ekr.20140901122110.18734"># These call only wrapper methods.
</t>
<t tx="ekr.20140901141402.18702">def insert(self, i, s):
    """QTextMixin"""
    s2 = self.getAllText()
    i = self.toPythonIndex(i)
    self.setAllText(s2[:i] + s + s2[i:])
    self.setInsertPoint(i + len(s))
    return i
</t>
<t tx="ekr.20140901141402.18704">def toPythonIndexRowCol(self, index):
    """QTextMixin"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
</t>
<t tx="ekr.20140901141402.18706">def delete(self, i, j=None):
    """QTextMixin"""
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i &gt; j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
</t>
<t tx="ekr.20140901141402.18710">def toPythonIndex(self, index, s=None):
    """QTextMixin"""
    if s is None:
        s = self.getAllText()
    i = g.toPythonIndex(s, index)
    return i
</t>
<t tx="ekr.20140901191541.18599">def check(self):
    """
    QLineEditWrapper.
    """
    return True
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902084950.18634">def seeInsertPoint(self):
    """Ensure the insert point is visible."""
    self.see(self.getInsertPoint())
        # getInsertPoint defined in client classes.
</t>
<t tx="ekr.20140902135648.18668">def selectAllText(self, s=None):
    """QTextMixin."""
    self.setSelectionRange(0, self.getLength(s))
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140902181058.18644">def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)

def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')
</t>
<t tx="ekr.20140902181058.18645">def disable(self):
    self.enabled = False

def enable(self, enabled=True):
    self.enabled = enabled
</t>
<t tx="ekr.20140903025053.18631">class WrapperAPI:
    """A class specifying the wrapper api used throughout Leo's core."""

    def __init__(self, c): pass

    def appendText(self, s): pass

    def clipboard_append(self, s): pass

    def clipboard_clear(self): pass

    def delete(self, i, j=None): pass

    def deleteTextSelection(self): pass

    def disable(self): pass

    def enable(self, enabled=True): pass

    def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

    def get(self, i, j): return ''

    def getAllText(self): return ''

    def getInsertPoint(self): return 0

    def getSelectedText(self): return ''

    def getSelectionRange(self): return (0, 0)

    def getXScrollPosition(self): return 0

    def getYScrollPosition(self): return 0

    def hasSelection(self): return False

    def insert(self, i, s): pass

    def see(self, i): pass

    def seeInsertPoint(self): pass

    def selectAllText(self, insert=None): pass

    def setAllText(self, s): pass

    def setFocus(self): pass  # Required: sets the focus to wrapper.widget.

    def setInsertPoint(self, pos, s=None): pass

    def setSelectionRange(self, i, j, insert=None): pass

    def setXScrollPosition(self, i): pass

    def setYScrollPosition(self, i): pass

    def tag_configure(self, colorName, **keys): pass

    def toPythonIndex(self, index): return 0

    def toPythonIndexRowCol(self, index): return (0, 0, 0)
</t>
<t tx="ekr.20140903172510.18579"># For StringTextWrapper.

def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

def getXScrollPosition(self): return 0

def getYScrollPosition(self): return 0

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setStyleClass(self, name): pass

def setXScrollPosition(self, i): pass

def setYScrollPosition(self, i): pass

def tag_configure(self, colorName, **keys): pass
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20141113094129.6">@cmd('focus-to-find')
def focus_to_find(self, event=None):  # pragma: no cover (cmd)
    c = self.c
    if c.config.getBool('use-find-dialog', default=True):
        g.app.gui.openFindDialog(c)
    else:
        c.frame.log.selectTab('Find')
</t>
<t tx="ekr.20150107090324.62">def redraw(self, p=None, scroll=True, forceDraw=False):
    self.text_draw_tree()
    
redraw_now = redraw

# def redraw_now(self, p=None, scroll=True, forceDraw=False):
    # if forceDraw:
        # self.redraw()
</t>
<t tx="ekr.20150204165040.5">def readOneAtCleanNode(self, root):
    '''Update the @clean/@nosent node at root.'''
    at, c, x = self, self.c, self.c.shadowController
    fileName = g.fullPath(c, root)
    if not g.os_path_exists(fileName):
        g.es_print(
            f"not found: {fileName}",
            color='red',
            nodeLink=root.get_UNL(with_proto=True))
        return False
    at.rememberReadPath(fileName, root)
    at.initReadIvars(root, fileName)
        # Must be called before at.scanAllDirectives.
    at.scanAllDirectives(root)
        # Sets at.startSentinelComment/endSentinelComment.
    new_public_lines = at.read_at_clean_lines(fileName)
    old_private_lines = self.write_at_clean_sentinels(root)
    marker = x.markerFromFileLines(old_private_lines, fileName)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    if old_public_lines:
        new_private_lines = x.propagate_changed_lines(
            new_public_lines, old_private_lines, marker, p=root)
    else:
        new_private_lines = []
        root.b = ''.join(new_public_lines)
        return True
    if new_private_lines == old_private_lines:
        return True
    if not g.unitTesting:
        g.es("updating:", root.h)
    root.clearVisitedInTree()
    gnx2vnode = at.fileCommands.gnxDict
    contents = ''.join(new_private_lines)
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    return True  # Errors not detected.
</t>
<t tx="ekr.20150204165040.7">def dump(self, lines, tag):
    """Dump all lines."""
    print(f"***** {tag} lines...\n")
    for s in lines:
        print(s.rstrip())
</t>
<t tx="ekr.20150204165040.8">def read_at_clean_lines(self, fn):
    '''Return all lines of the @clean/@nosent file at fn.'''
    at = self
    s = at.openFileHelper(fn)
        # Use the standard helper. Better error reporting.
        # Important: uses 'rb' to open the file.
    # #1798.
    if s is None:
        s = ''
    else:
        s = g.toUnicode(s, encoding=at.encoding)
        s = s.replace('\r\n', '\n')
            # Suppress meaningless "node changed" messages.
    return g.splitLines(s)
</t>
<t tx="ekr.20150204165040.9">def write_at_clean_sentinels(self, root):
    '''
    Return all lines of the @clean tree as if it were
    written as an @file node.
    '''
    at = self.c.atFileCommands
    result = at.atFileToString(root, sentinels=True)
    s = g.toUnicode(result, encoding=at.encoding)
    return g.splitLines(s)
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
</t>
<t tx="ekr.20150207044400.9">"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
from leo.core import leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()

</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    """
    Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule.
    """
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)

</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    """Create an entry in d for a string keyword."""
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return None
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)  # Don't require ending word.

    return forth_string_word_rule

</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList

</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    # #1821.
    def forth_rule20(colorer, s, i):
        return 0
        # return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            # at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.

properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {}  # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}


class extendForth:
    """A helper class to extend the mode tables from @data forth-x settings."""

</t>
<t tx="ekr.20150326145530.4">    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None  # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = []  # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False  # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    """Set our ivars from settings."""
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for (ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for (ivar, setting) in table2:
        self.splitList(ivar, setting)

</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    """Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2."""
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)

</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True)  # Require word.

    return forth_bracket_rule

</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2",  # defining word
            word=word,
            kind2="keyword3",  # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule

</t>
<t tx="ekr.20150330033306.1">on_idle_count = 0

def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    #
    # #1240: Note: The "asking" dialog prevents idle time.
    #
    if not g.app or g.app.killed or g.app.restarting:  # #1240.
        return
    self.on_idle_count += 1
    # New in Leo 5.7: always handle delayed requests.
    if g.app.windowList:
        c = g.app.log and g.app.log.c
        if c:
            c.outerUpdate()
    # Fix #262: Improve performance when @bool check-for-changed-external-files is True.
    if self.unchecked_files:
        # Check all external files.
        for ef in self.unchecked_files:
            self.idle_check_open_with_file(ef)
        self.unchecked_files = []
    elif self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in g.app.commanders() if self.is_enabled(z)
        ]
        self.unchecked_files = [z for z in self.files if z.exists()]
</t>
<t tx="ekr.20150402111403.1"></t>
<t tx="ekr.20150402111413.1">def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
</t>
<t tx="ekr.20150402111935.1">def sortCommandHistory(self):
    """Sort the command history."""
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
</t>
<t tx="ekr.20150402165918.1">def commandHistoryFwd(self):
    """
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) - 1:
            # fall off the bottom
            i = None
        elif i is not None:
            # move to next down in list
            i += 1
            commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150402171131.1">def commandHistoryBackwd(self):
    """
    Return the previous entry in the Command History - stay at the top
    if we are there
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i is None:
            # first time in - set to last entry
            i = len(h) - 1
        elif i &gt; 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150403044823.1">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    path = g.fullPath(c, p)
    if not self.has_changed(path):
        return
    if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        # Fix #1081: issue a warning.
        self.warn(c, path, p=p)
    elif self.ask(c, path, p=p):
        c.redraw(p=p)
        c.refreshFromDisk(p)
        c.redraw()
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
</t>
<t tx="ekr.20150403150655.1">def fullPath(c, p, simulate=False):
    """
    Return the full path (including fileName) in effect at p. Neither the
    path nor the fileName will be created if it does not exist.
    """
    # Search p and p's parents.
    for p in p.self_and_parents(copy=False):
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.h if simulate else p.anyAtFileNodeName()
            # Use p.h for unit tests.
        if fn:
            # Fix #102: expand path expressions.
            fn = c.expand_path_expression(fn)  # #1341.
            return g.os_path_finalize_join(path, fn)  # #1341.
    return ''
</t>
<t tx="ekr.20150404045115.1">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1240: Check the .leo file itself.
    self.idle_check_leo_file(c)
    #
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)
</t>
<t tx="ekr.20150405200212.1">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    is_leo = path.endswith(('.leo', '.db'))
    is_external_file = not is_leo
    #
    # Create the message.
    message1 = f"{g.splitLongFileName(path)} has changed outside Leo.\n"
    if is_leo:
        message2 = 'Restart Leo?'
    elif p:
        message2 = f"Reload {p.h}?"
    else:
        for ef in self.files:
            if ef.path == path:
                message2 = f"Reload {ef.p.h}?"
                break
        else:
            message2 = f"Reload {path}?"
    #
    # #1240: Note: This dialog prevents idle time.
    result = g.app.gui.runAskYesNoDialog(c,
        'Overwrite the version in Leo?',
        message1 + message2,
        yes_all=is_external_file,
        no_all=is_external_file,
    )
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
</t>
<t tx="ekr.20150407124259.1">def idle_check_open_with_file(self, ef):
    '''Update the open-with node given by ef.'''
    assert isinstance(ef, ExternalFile), ef
    if ef.path and os.path.exists(ef.path):
        time = self.get_mtime(ef.path)
        if time and time != ef.time:
            ef.time = time  # inhibit endless dialog loop.
            self.update_open_with_node(ef)
</t>
<t tx="ekr.20150407205631.1">def update_open_with_node(self, ef):
    '''Update the body text of ef.p to the contents of ef.path.'''
    assert isinstance(ef, ExternalFile), ef
    c, p = ef.c, ef.p.copy()
    # Ask the user how to resolve the conflict.
    if self.ask(c, ef.path, p=p):
        g.blue(f"updated {p.h}")
        s, e = g.readFileIntoString(ef.path)
        p.b = s
        if c.config.getBool('open-with-goto-node-on-update'):
            c.selectPosition(p)
        if c.config.getBool('open-with-save-on-update'):
            c.save()
        else:
            p.setDirty()
            c.setChanged()
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425143043.1">def initCommandHistory(self):
    """Init command history from @data command-history nodes."""
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    """ reset the command history index to indicate that
        we are pointing 'past' the last entry
    """
    self.commandIndex = None
    #
</t>
<t tx="ekr.20150425145248.1">pylint
cov
moz
backup</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043714.3"></t>
<t tx="ekr.20150514043714.4">def beginCommand(self, w, undoType='Typing'):
    """Do the common processing at the start of each command."""
    c, p, u = self.c, self.c.p, self.c.undoer
    name = c.widget_name(w)
    if name.startswith('body'):
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch = ''
        b.name = name
        b.oldSel = w.getSelectionRange()
        b.oldText = p.b
        b.w = w
        b.undoType = undoType
        b.undoer_bunch = u.beforeChangeBody(p)  # #1733.
    else:
        self.undoData = None
    return w
</t>
<t tx="ekr.20150514043714.6">def endCommand(self, label=None, changed=True, setLabel=True):
    """
    Do the common processing at the end of each command.
    Handles undo only if we are in the body pane.
    """
    k, p, u= self.c.k, self.c.p, self.c.undoer
    w = self.editWidget(event=None)
    b = self.undoData
    if b and b.name.startswith('body') and changed:
        newText = w.getAllText()
        if b.undoType.capitalize() == 'Typing':
            u.doTyping(p, 'Typing', oldText=b.oldText, newText=newText, oldSel=b.oldSel)
        else:
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, b.undoType, b.undoer_bunch)
            
    self.undoData = None
    k.clearState()
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20150514043850.14">def find_place_holder(self, p, do_placeholder):
    """
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    """
    c = self.c
    # Do #438: Search for placeholder in headline.
    s = p.h
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is not None:
            p.h = new_s
            c.redraw(p)
            c.editHeadline()
            w = c.edit_widget(p)
            w.setSelectionRange(i, j, insert=j)
            return True
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='find-place-holder', oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        c.bodyWantsFocusNow()
        return True
    # #453: do nothing here.
        # c.frame.body.forceFullRecolor()
        # c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20150514043850.15">def make_script_substitutions(self, i, j, val):
    """Make scripting substitutions in node p."""
    c = self.c
    if not c.abbrev_subst_start:
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False
    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
        except Exception:
            g.es_print('exception evaluating', content)
            g.es_exception()
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None: x = ''
        val = f"{prefix}{x}{rest}"
        # Save the selection range.
        w = c.frame.body.wrapper
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        oldSel = i, j
        c.frame.body.onBodyChanged(undoType='make-script-substitution', oldSel=oldSel)
    return val, do_placeholder
</t>
<t tx="ekr.20150514043850.18">def replace_selection(self, w, i, j, s):
    """Replace w[i:j] by s."""
    w_name = g.app.gui.widget_name(w)
    c = self.c
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    if w_name.startswith('head'):
        pass  # Don't set p.h here!
    else:
        # Fix part of #438. Don't leave the headline.
        oldSel = j, j
        c.frame.body.onBodyChanged('Abbreviation', oldSel=oldSel)
    # Adjust self.save_sel &amp; self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
</t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150514045829.12">def renameBuffer(self, event):
    """Rename a buffer, i.e., change a node's headline."""
    g.es('rename-buffer not ready yet')
    if 0:
        self.c.k.setLabelBlue('Rename buffer from: ')
        self.getBufferName(event, self.renameBufferFinisher1)

def renameBufferFinisher1(self, name):
    self.fromName = name
    self.c.k.setLabelBlue(f"Rename buffer from: {name} to: ")
    event = None
    self.getBufferName(event, self.renameBufferFinisher2)

def renameBufferFinisher2(self, name):
    c = self.c
    p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        p.h = name
        c.redraw(p)
</t>
<t tx="ekr.20150514063305.108">def freeTreeWidgets(self, event=None):
    """Free all widgets used in Leo's outline pane."""
    c = self.c
    c.frame.tree.destroyWidgets()
    c.redraw()
</t>
<t tx="ekr.20150514063305.112">def printStats(self, event=None):
    """Print statistics about the objects that Leo is using."""
    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
</t>
<t tx="ekr.20150514063305.244">@cmd('indent-relative')
def indentRelative(self, event):
    """
    The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.
    """
    c = self.c
    undoType = 'indent-relative'
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    # Find the previous non-blank line
    i, j = g.getLine(s, ins)
    while 1:
        if i &lt;= 0: return
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(w, undoType=undoType)
    try:
        k = g.skip_ws(s, i)
        ws = s[i:k]
        i2, j2 = g.getLine(s, ins)
        k = g.skip_ws(s, i2)
        line = ws + s[k:j2]
        w.delete(i2, j2)
        w.insert(i2, line)
        w.setInsertPoint(i2 + len(ws))
        c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
    finally:
        self.endCommand(changed=True, setLabel=True)
</t>
<t tx="ekr.20150514063305.253">@cmd('backward-delete-char')
def backwardDeleteCharacter(self, event=None):
    """Delete the character to the left of the cursor."""
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if wname.startswith('body'):
        self.beginCommand(w, undoType='Typing')
        try:
            tab_width = c.getTabWidth(c.p)
            changed = True
            if i != j:
                w.delete(i, j)
                w.setSelectionRange(i, i, insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins - 1)
                w.setSelectionRange(ins - 1, ins - 1, insert=ins - 1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=changed, setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        s = w.getAllText()
        # Delete something if we can.
        if i != j:
            j = max(i, min(j, len(s)))
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins - 1)
            ins = ins - 1
            w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.254">s = prev = w.getAllText()
ins = w.getInsertPoint()
i, j = g.getLine(s, ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)
# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n, n2)
count = 0
while n2 &gt; 0:
    n2 -= 1
    ch = prev[n - count - 1]
    if ch != ' ': break
    else: count += 1
# Make sure we actually delete something.
i = ins - (max(1, count))
w.delete(i, ins)
w.setSelectionRange(i, i, insert=i)
</t>
<t tx="ekr.20150514063305.259">@cmd('delete-char')
def deleteNextChar(self, event):
    """Delete the character to the right of the cursor."""
    c, w = self.c, self.editWidget(event)
    if not w:
        return
    wname = c.widget_name(w)
    if wname.startswith('body'):
        s = w.getAllText()
        i, j = w.getSelectionRange()
        self.beginCommand(w, undoType='delete-char')
        changed = True
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
        else:
            changed = False
        self.endCommand(changed=changed, setLabel=False)
    else:
        # No undo in this widget.
        s = w.getAllText()
        i, j = w.getSelectionRange()
        # Delete something if we can.
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
</t>
<t tx="ekr.20150514063305.262">@cmd('insert-newline')
def insertNewLine(self, event):
    """Insert a newline at the cursor."""
    self.insertNewlineBase(event)

insertNewline = insertNewLine

def insertNewlineBase(self, event):
    """A helper that can be monkey-patched by tables.py plugin."""
    # Note: insertNewlineHelper already exists.
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if not g.isTextWrapper(w):
        return  # pragma: no cover (defensive)
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    oldSel = w.getSelectionRange()
    self.beginCommand(w, undoType='newline')
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand()
</t>
<t tx="ekr.20150514063305.263">@cmd('newline-and-indent')
def insertNewLineAndTab(self, event):
    """Insert a newline and tab at the cursor."""
    trace = 'keys' in g.app.debug
    c, k = self.c, self.c.k
    p = c.p
    w = self.editWidget(event)
    if not w:
        return
    if not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    if trace: g.trace('(newline-and-indent)')
    self.beginCommand(w, undoType='insert-newline-and-indent')
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    self.updateTab(event, p, w, smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand(changed=True, setLabel=False)
</t>
<t tx="ekr.20150514063305.266">@cmd('remove-blank-lines')
def removeBlankLines(self, event):
    """
    Remove lines containing nothing but whitespace.

    Select all lines if there is no existing selection.
    """
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    oldYview = w.getYScrollPosition()
    lines = g.splitLines(w.getAllText())
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    if not changed:
        return  # pragma: no cover (defensive)
    #
    # Set p.b and w's text first.
    result = ''.join(result)
    p.b = result
    w.setAllText(result)
    i, j = 0, max(0, len(result) - 1)
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    c.undoer.afterChangeBody(p, 'remove-blank-lines', bunch)
</t>
<t tx="ekr.20150514063305.268"># @cmd('self-insert-command')

def selfInsertCommand(self, event, action='insert'):
    """
    Insert a character in the body pane.

    This is the default binding for all keys in the body pane.
    It handles undo, bodykey events, tabs, back-spaces and bracket matching.
    """
    trace = 'keys' in g.app.debug
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    undoType = 'Typing'
    if not w:
        return  # pragma: no cover (defensive)
    &lt;&lt; set local vars &gt;&gt;
    if not ch:
        return
    if trace: g.trace('ch', repr(ch)) # and ch in '\n\r\t'
    assert g.isStrokeOrNone(stroke)
    if g.doHook("bodykey1", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType):
        return
    if ch == '\t':
        self.updateTab(event, p, w, smartTab=True)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key.
        self.backwardDeleteCharacter(event)
    elif ch in ('\r', '\n'):
        ch = '\n'
        self.insertNewlineHelper(w, oldSel, undoType)
    elif ch in '\'"' and c.config.getBool('smart-quotes'):
        self.doSmartQuote(action, ch, oldSel, w)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p, w, ch, oldSel)
    elif ch:
        # Null chars must not delete the selection.
        self.doPlainChar(action, ch, event, inBrackets, oldSel, stroke, w)
    #
    # Common processing.
    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w, spot)
    #
    # Update the text and handle undo.
    newText = w.getAllText()
    if newText != oldText:
        # Call u.doTyping to honor the user's undo granularity.
        newSel = w.getSelectionRange()
        newInsert = w.getInsertPoint()
        newSel = w.getSelectionRange()
        newText = w.getAllText()  # Converts to unicode.
        u.doTyping(p, 'Typing', oldText, newText,
            oldSel=oldSel, oldYview=oldYview, newInsert=newInsert, newSel=newSel)
    g.doHook("bodykey2", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType)
</t>
<t tx="ekr.20150514063305.269">stroke = event.stroke if event else None
ch = event.char if event else ''
if ch == 'Return':
    ch = '\n'  # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel = w.getSelectionRange() if name.startswith('body') else (None, None)
oldText = p.b if name.startswith('body') else ''
oldYview = w.getYScrollPosition()
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.checkUnicode(ch) in brackets
</t>
<t tx="ekr.20150514063305.270">def doPlainTab(self, s, i, tab_width, w):
    """
    A helper for selfInsertCommand, called from updateTab.
    
    Insert spaces equivalent to one tab.
    """
    trace = 'keys' in g.app.debug
    start, end = g.getLine(s, i)
    s2 = s[start:i]
    width = g.computeWidth(s2, tab_width)
    if trace: g.trace('width', width)
    if tab_width &gt; 0:
        w.insert(i, '\t')
        ins = i + 1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i, ' ' * n)
        ins = i + n
    w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.271">def flashCharacter(self, w, i):
    """Flash the character at position i of widget w."""
    bg = self.bracketsFlashBg or 'DodgerBlue1'
    fg = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay = self.bracketsFlashDelay or 75
    w.flashCharacter(i, bg, fg, flashes, delay)
</t>
<t tx="ekr.20150514063305.272">def flashMatchingBracketsHelper(self, c, ch, i, p, w):
    """Flash matching brackets at char ch at position i at widget w."""
    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d[self.openBracketsList[z]] = self.closeBracketsList[z]
        # reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d[self.closeBracketsList[z]] = self.openBracketsList[z]
        # reverse = True # Search backward
    s = w.getAllText()
    # A partial fix for bug 127: Bracket matching is buggy.
    language = g.getLanguageAtPosition(c, p)
    if language == 'perl':
        return
    j = g.MatchBrackets(c, p, language).find_matching_bracket(ch, s, i)
    if j is not None:
        self.flashCharacter(w, j)
</t>
<t tx="ekr.20150514063305.273">def initBracketMatcher(self, c):
    """Init the bracket matching code."""
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList = '([{'
        self.closeBracketsList = ')]}'
</t>
<t tx="ekr.20150514063305.274">def insertNewlineHelper(self, w, oldSel, undoType):

    c, p = self.c, self.c.p
    i, j = oldSel
    ch = '\n'
    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i, j)
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
    else:
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
        if (c.autoindent_in_nocolor or
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p, w)
    w.seeInsertPoint()
</t>
<t tx="ekr.20150514063305.275">def updateAutoIndent(self, p, w):
    """Handle auto indentation."""
    c = self.c
    tab_width = c.getTabWidth(p)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s, ins)
    i, j = g.getLine(s, i - 1)
    s = s[i : j - 1]
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s, 0, tab_width)
    if s and s[-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c, p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width]
        tabex = 0
        for i, ch in enumerate(s):
            if ch == '\t':
                tabex += tab_width - 1
            if ch in '([{':
                bracketWidths.append(i + tabex + 1)
            elif ch in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width, tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i, ws)
        w.setInsertPoint(i + len(ws))
        w.seeInsertPoint()
            # 2011/10/02: Fix cursor-movement bug.
</t>
<t tx="ekr.20150514063305.276">def updateAutomatchBracket(self, p, w, ch, oldSel):

    c = self.c
    d = c.scanAllDirectives(p)
    i, j = oldSel
    language = d.get('language')
    s = w.getAllText()
    if ch in ('(', '[', '{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(': ')', '[': ']', '{': '}'}.get(ch)
        if i != j: w.delete(i, j)
        w.insert(i, ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins - 1)
    else:
        ins = w.getInsertPoint()
        ch2 = s[ins] if ins &lt; len(s) else ''
        if ch2 in (')', ']', '}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins + 1)
        else:
            if i != j: w.delete(i, j)
            w.insert(i, ch)
            w.setInsertPoint(i + 1)
</t>
<t tx="ekr.20150514063305.277">def updateTab(self, event, p, w, smartTab=True):
    """
    A helper for selfInsertCommand.

    Add spaces equivalent to a tab.
    """
    c = self.c
    i, j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.
    if i != j:
        c.indentBody(event)
        return
    tab_width = c.getTabWidth(p)
    # Get the preceeding characters.
    s = w.getAllText()
    start, end = g.getLine(s, i)
    after = s[i:end]
    if after.endswith('\n'):
        after = after[:-1]
    # Only do smart tab at the start of a blank line.
    doSmartTab = (smartTab and c.smart_tab and i == start)
        # Truly at the start of the line.
        # and not after # Nothing *at all* after the cursor.
    if doSmartTab:
        self.updateAutoIndent(p, w)
        # Add a tab if otherwise nothing would happen.
        if s == w.getAllText():
            self.doPlainTab(s, i, tab_width, w)
    else:
        self.doPlainTab(s, i, tab_width, w)
</t>
<t tx="ekr.20150514063305.278">@cmd('insert-file-name')
def insertFileName(self, event=None):
    """
    Prompt for a file name, then insert it at the cursor position.
    This operation is undoable if done in the body pane.

    The initial path is made by concatenating path_for_p() and the selected
    text, if there is any, or any path like text immediately preceding the
    cursor.
    """
    c, u, w = self.c, self.c.undoer, self.editWidget(event)
    if not w:
        return

    def callback(arg, w=w):
        i = w.getSelectionRange()[0]
        p = c.p
        w.deleteTextSelection()
        w.insert(i, arg)
        newText = w.getAllText()
        if g.app.gui.widget_name(w) == 'body' and p.b != newText:
            bunch = u.beforeChangeBody(p)
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, 'insert-file-name', bunch)

    # see if the widget already contains the start of a path

    start_text = w.getSelectedText()
    if not start_text:  # look at text preceeding insert point
        start_text = w.getAllText()[: w.getInsertPoint()]
        if start_text:
            # make non-path characters whitespace
            start_text = ''.join(i if i not in '\'"`()[]{}&lt;&gt;!|*,@#$&amp;' else ' '
                                 for i in start_text)
            if start_text[-1].isspace():  # use node path if nothing typed
                start_text = ''
            else:
                start_text = start_text.rsplit(None, 1)[-1]
                # set selection range so w.deleteTextSelection() works in the callback
                w.setSelectionRange(
                    w.getInsertPoint() - len(start_text), w.getInsertPoint())

    c.k.functionTail = g.os_path_finalize_join(
        self.path_for_p(c, c.p), start_text or '')
    c.k.getFileName(event, callback=callback)
</t>
<t tx="ekr.20150514063305.285"></t>
<t tx="ekr.20150514063305.286"></t>
<t tx="ekr.20150514063305.287">def extendHelper(self, w, extend, spot, upOrDown=False):
    """
    Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    """
    c, p = self.c, self.c.p
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        self.setMoveCol(w, ins if extend else spot)  # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            self.setMoveCol(w, ins)  # sets self.moveSpot.
        elif self.moveSpot in (i, j) and self.moveSpot != ins:
            # The bug fix, part 1.
            pass
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            self.setMoveCol(w, k)  # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2, j2 = g.getLine(s, spot)
            line = s[i2:j2]
            row, col = g.convertPythonIndexToRowCol(s, spot)
            if True:  # was j2 &lt; len(s)-1:
                n = min(self.moveCol, max(0, len(line) - 1))
            else:
                n = min(self.moveCol, max(0, len(line)))  # A tricky boundary.
            spot = g.convertRowColToPythonIndex(s, row, n)
        else:  # Plain move forward or back.
            self.setMoveCol(w, spot)  # sets self.moveSpot.
    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot, self.moveSpot, insert=spot)
        else:
            w.setSelectionRange(self.moveSpot, spot, insert=spot)
    else:
        w.setSelectionRange(spot, spot, insert=spot)
    w.seeInsertPoint()
    c.frame.updateStatusLine()
</t>
<t tx="ekr.20150514063305.288">def moveToHelper(self, event, spot, extend):
    """
    Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.
    """
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w: return
    c.widgetWantsFocusNow(w)
    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i, j = k.getEditableTextRange()
        if spot &lt; i: spot = i
        elif spot &gt; j: spot = j
    self.extendHelper(w, extend, spot, upOrDown=False)
</t>
<t tx="ekr.20150514063305.289">def setMoveCol(self, w, spot):
    """Set the column to which an up or down arrow will attempt to move."""
    p = self.c.p
    i, row, col = w.toPythonIndexRowCol(spot)
    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v
</t>
<t tx="ekr.20150514063305.290">@cmd('back-to-home')
def backToHome(self, event, extend=False):
    """
    Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.
    """
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if s:
        i, j = g.getLine(s, ins)
        i1 = i
        while i &lt; j and s[i] in (' \t'):
            i += 1
        if i == ins:
            i = i1
        self.moveToHelper(event, i, extend=extend)

@cmd('back-to-home-extend-selection')
def backToHomeExtendSelection(self, event):
    self.backToHome(event, extend=True)
</t>
<t tx="ekr.20150514063305.291">@cmd('back-to-indentation')
def backToIndentation(self, event):
    """Position the point at the first non-blank character on the line."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1
    self.moveToHelper(event, i, extend=False)
</t>
<t tx="ekr.20150514063305.292">@cmd('next-line')
def nextLine(self, event):
    """Move the cursor down, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'down', extend=False)

@cmd('next-line-extend-selection')
def nextLineExtendSelection(self, event):
    """Extend the selection by moving the cursor down."""
    self.moveUpOrDownHelper(event, 'down', extend=True)

@cmd('previous-line')
def prevLine(self, event):
    """Move the cursor up, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'up', extend=False)

@cmd('previous-line-extend-selection')
def prevLineExtendSelection(self, event):
    """Extend the selection by moving the cursor up."""
    self.moveUpOrDownHelper(event, 'up', extend=True)
</t>
<t tx="ekr.20150514063305.293">def moveUpOrDownHelper(self, event, direction, extend):

    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction, extend=extend)
    else:
        # Find the start of the next/prev line.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        if direction == 'down':
            i2, j2 = g.getLine(s, j)
        else:
            i2, j2 = g.getLine(s, i - 1)
        # The spot is the start of the line plus the column index.
        n = max(0, j2 - i2 - 1)  # The length of the new line.
        col2 = min(col, n)
        spot = i2 + col2
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.294">@cmd('beginning-of-buffer')
def beginningOfBuffer(self, event):
    """Move the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=False)

@cmd('beginning-of-buffer-extend-selection')
def beginningOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=True)

@cmd('end-of-buffer')
def endOfBuffer(self, event):
    """Move the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=False)

@cmd('end-of-buffer-extend-selection')
def endOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=True)
</t>
<t tx="ekr.20150514063305.295">def moveToBufferHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        if spot == 'home':
            self.moveToHelper(event, 0, extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event, len(s), extend=extend)
        else:
            g.trace('can not happen: bad spot', spot)  # pragma: no cover (defensive)
</t>
<t tx="ekr.20150514063305.296">@cmd('back-char')
def backCharacter(self, event):
    """Move the cursor back one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'left', extend=False)

@cmd('back-char-extend-selection')
def backCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor back one character."""
    self.moveToCharacterHelper(event, 'left', extend=True)

@cmd('forward-char')
def forwardCharacter(self, event):
    """Move the cursor forward one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'right', extend=False)

@cmd('forward-char-extend-selection')
def forwardCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one character."""
    self.moveToCharacterHelper(event, 'right', extend=True)
</t>
<t tx="ekr.20150514063305.297">def moveToCharacterHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i = max(0, i - 1)
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'right':
            i = min(i + 1, len(w.getAllText()))
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.298">@cmd('clear-extend-mode')
def clearExtendMode(self, event):
    """Turn off extend mode: cursor movement commands do not extend the selection."""
    self.extendModeHelper(event, False)

@cmd('set-extend-mode')
def setExtendMode(self, event):
    """Turn on extend mode: cursor movement commands do extend the selection."""
    self.extendModeHelper(event, True)

@cmd('toggle-extend-mode')
def toggleExtendMode(self, event):
    """Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections."""
    self.extendModeHelper(event, not self.extendMode)

def extendModeHelper(self, event, val):
    c = self.c
    w = self.editWidget(event)
    if w:
        self.extendMode = val
        if not g.unitTesting:
            # g.red('extend mode','on' if val else 'off'))
            c.k.showStateAndMode()
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20150514063305.299">@cmd('exchange-point-mark')
def exchangePointMark(self, event):
    """
    Exchange the point (insert point) with the mark (the other end of the
    selected text).
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange', extend=False)
    else:
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange(sort=False)
        if i == j: return
        ins = w.getInsertPoint()
        ins = j if ins == i else i
        w.setInsertPoint(ins)
        w.setSelectionRange(i, j, insert=None)
</t>
<t tx="ekr.20150514063305.300">@cmd('extend-to-line')
def extendToLine(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1
    i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1
    w.setSelectionRange(i1, i)
</t>
<t tx="ekr.20150514063305.301">@cmd('extend-to-sentence')
def extendToSentence(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    i2 = 1 + s.find('.', i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.', 0, i2 - 1)
    w.setSelectionRange(i1, i2)
</t>
<t tx="ekr.20150514063305.302">@cmd('extend-to-word')
def extendToWord(self, event, select=True, w=None):
    """Compute the word at the cursor. Select it if select arg is True."""
    if not w:
        w = self.editWidget(event)
    if not w:
        return 0, 0  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = i1 = w.getInsertPoint()
    # Find a word char on the present line if one isn't at the cursor.
    if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
        # First, look forward
        while i &lt; n and not g.isWordChar(s[i]) and s[i] != '\n':
            i += 1
        # Next, look backward.
        if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
            i = i1 - 1 if (i &gt;= n or s[i] == '\n') else i1
            while i &gt;= 0 and not g.isWordChar(s[i]) and s[i] != '\n':
                i -= 1
    # Make sure s[i] is a word char.
    if 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        # Find the start of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
        i1 = i
        # Find the end of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i += 1
        if select:
            w.setSelectionRange(i1, i)
        return i1, i
    return 0, 0
</t>
<t tx="ekr.20150514063305.303">@cmd('move-past-close')
def movePastClose(self, event):
    """Move the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=False)

@cmd('move-past-close-extend-selection')
def movePastCloseExtendSelection(self, event):
    """Extend the selection by moving the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.304">def movePastCloseHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return
    self.moveToHelper(event, i2 + 1, extend)
</t>
<t tx="ekr.20150514063305.305">def moveWithinLineHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    spots = ('end-line', 'finish-line', 'start-line')
    if hasattr(w, 'leoMoveCursorHelper') and spot not in spots:
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if spot == 'begin-line':  # was 'start-line'
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s, j - 1, '\n') and i != j: j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'finish-line':
            if not line.isspace():
                if g.match(s, j - 1, '\n'): j -= 1
                while j &gt;= 0 and s[j].isspace():
                    j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'start-line':  # new
            if not line.isspace():
                while i &lt; j and s[i].isspace():
                    i += 1
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.306">@cmd('back-page')
def backPage(self, event):
    """Move the cursor back one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='back', extend=False)

@cmd('back-page-extend-selection')
def backPageExtendSelection(self, event):
    """Extend the selection by moving the cursor back one page."""
    self.movePageHelper(event, kind='back', extend=True)

@cmd('forward-page')
def forwardPage(self, event):
    """Move the cursor forward one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='forward', extend=False)

@cmd('forward-page-extend-selection')
def forwardPageExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one page."""
    self.movePageHelper(event, kind='forward', extend=True)
</t>
<t tx="ekr.20150514063305.307">def movePageHelper(self, event, kind, extend):  # kind in back/forward.
    """Move the cursor up/down one page, possibly extending the selection."""
    w = self.editWidget(event)
    if not w:
        return
    linesPerPage = 15  # To do.
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind='page-down' if kind == 'forward' else 'page-up',
            extend=extend, linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row, col = g.convertPythonIndexToRowCol(s, ins)
        if kind == 'back':
            row2 = max(0, row - linesPerPage)
        else:
            row2 = min(row + linesPerPage, len(lines) - 1)
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s, row2, col, lines=lines)
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.308">@cmd('back-paragraph')
def backwardParagraph(self, event):
    """Move the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=False)

@cmd('back-paragraph-extend-selection')
def backwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=True)

@cmd('forward-paragraph')
def forwardParagraph(self, event):
    """Move the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=False)

@cmd('forward-paragraph-extend-selection')
def forwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.309">def backwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    i, j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i, j = g.getLine(s, j)
    line = s[i:j]
    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i, j = g.getLine(s, i - 1)
            line = s[i:j]
            if not line.strip(): break
    # Find the end of the previous paragraph.
    while i &gt; 0:
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip():
            i = j - 1
            break
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.310">def forwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    line = s[i:j]
    if line.strip():  # Skip past the present paragraph.
        self.selectParagraphHelper(w, i)
        i, j = w.getSelectionRange()
        j += 1
    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i, j = g.getLine(s, j)
        line = s[i:j]
        if line.strip(): break
    w.setInsertPoint(ins)  # Restore the original insert point.
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.311">@cmd('select-all')
def selectAllText(self, event):
    """Select all text."""
    k = self.c.k
    w = self.editWidget(event)
    if not w: return
    # Bug fix 2013/12/13: Special case the minibuffer.
    if w == k.w:
        k.selectAll()
    elif w and g.isTextWrapper(w):
        w.selectAllText()
</t>
<t tx="ekr.20150514063305.312">@cmd('back-sentence')
def backSentence(self, event):
    """Move the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=False)

@cmd('back-sentence-extend-selection')
def backSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=True)

@cmd('forward-sentence')
def forwardSentence(self, event):
    """Move the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=False)

@cmd('forward-sentence-extend-selection')
def forwardSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.313">def backSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Find the starting point of the scan.
    i = ins
    i -= 1  # Ensure some progress.
    if i &lt; 0:
        return
    # Tricky.
    if s[i] == '.':
        i -= 1
    while i &gt;= 0 and s[i] in ' \n':
        i -= 1
    if i &gt;= ins:
        i -= 1
    if i &gt;= len(s):
        i -= 1
    if i &lt;= 0:
        return
    if s[i] == '.':
        i -= 1
    # Scan backwards to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &gt;= 0:
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if i &gt; 0 and s[i - 1].isalnum() and s[i + 1].isalnum():
                i -= 1
            else:
                i += 1
                while i &lt; len(s) and s[i] in ' \n':
                    i += 1
                i -= 1
                break
        elif s[i] == '\n':
            j = i - 1
            while j &gt;= 0:
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j -= 1
                else:
                    i -= 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i -= 1
        else:
            i -= 1
        assert end or progress &gt; i
    i += 1
    if i &lt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.314">def forwardSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins &gt;= len(s):
        return
    # Find the starting point of the scan.
    i = ins
    if i + 1 &lt; len(s) and s[i + 1] == '.':
        i += 1
    if s[i] == '.':
        i += 1
    else:
        while i &lt; len(s) and s[i] in ' \n':
            i += 1
        i -= 1
    if i &lt;= ins:
        i += 1
    if i &gt;= len(s):
        return
    # Scan forward to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &lt; len(s):
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if 0 &lt; i &lt; len(s) and s[i - 1].isalnum() and s[i + 1].isalnum():
                i += 1
            else:
                i += 1
                break  # Include the paragraph.
        elif s[i] == '\n':
            j = i + 1
            while j &lt; len(s):
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j += 1
                else:
                    i += 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i += 1
        else:
            i += 1
        assert end or progress &lt; i
    i = min(i, len(s))
    if i &gt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.316">@cmd('back-word')
def backwardWord(self, event):
    """Move the cursor to the previous word."""
    self.moveWordHelper(event, extend=False, forward=False)

@cmd('back-word-extend-selection')
def backwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous word."""
    self.moveWordHelper(event, extend=True, forward=False)

@cmd('back-word-smart')
def backwardWordSmart(self, event):
    """Move the cursor to the beginning of the current or the end of the previous word."""
    self.moveWordHelper(event, extend=False, forward=False, smart=True)

@cmd('back-word-smart-extend-selection')
def backwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word."""
    self.moveWordHelper(event, extend=True, forward=False, smart=True)
</t>
<t tx="ekr.20150514063305.317">def moveWordHelper(self, event, extend, forward, end=False, smart=False):
    """
    Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    alphanumeric_re = re.compile(r"\w")
    whitespace_re = re.compile(r"\s")
    simple_whitespace_re = re.compile(r"[ \t]")
    @others
    if smart:
        if forward:
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_end(i)
                    i = seek_simple_whitespace_end(i)
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_end(i)
                elif is_special(s[i]):
                    i = seek_special_end(i)
                    i = seek_simple_whitespace_end(i)
                else:
                    i += 1  # e.g. for newlines
        else:
            i -= 1  # Shift cursor temporarily by -1 to get easy read access to the prev. char
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_start(i)
                    # Do not seek further whitespace here
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_start(i)
                elif is_special(s[i]):
                    i = seek_special_start(i)
                    # Do not seek further whitespace here
                else:
                    i -= 1  # e.g. for newlines
            i += 1
    else:
        if forward:
            # Unlike backward-word moves, there are two options...
            if end:
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
            else:
                #1653. Scan for non-words *first*.
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
        else:
            i -= 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i -= 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i -= 1
            i += 1  # 2015/04/30
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.318">def is_alphanumeric(c):
    return alphanumeric_re.match(c) is not None

def is_whitespace(c):
    return whitespace_re.match(c) is not None

def is_simple_whitespace(c):
    return simple_whitespace_re.match(c) is not None

def is_line_break(c):
    return is_whitespace(c) and not is_simple_whitespace(c)

def is_special(c):
    return not is_alphanumeric(c) and not is_whitespace(c)

def seek_until_changed(i, match_function, step):
    while 0 &lt;= i &lt; n and match_function(s[i]):
        i += step
    return i

def seek_word_end(i):
    return seek_until_changed(i, is_alphanumeric, 1)

def seek_word_start(i):
    return seek_until_changed(i, is_alphanumeric, -1)

def seek_simple_whitespace_end(i):
    return seek_until_changed(i, is_simple_whitespace, 1)

def seek_simple_whitespace_start(i):
    return seek_until_changed(i, is_simple_whitespace, -1)

def seek_special_end(i):
    return seek_until_changed(i, is_special, 1)

def seek_special_start(i):
    return seek_until_changed(i, is_special, -1)
</t>
<t tx="ekr.20150514063305.336">def scrollHelper(self, event, direction, distance):
    """
    Scroll the present pane up or down one page
    kind is in ('up/down-half-page/line/page)
    """
    w = event and event.w
    if w and hasattr(w, 'scrollDelegate'):
        kind = direction + '-' + distance
        w.scrollDelegate(kind)
</t>
<t tx="ekr.20150514063305.337">@cmd('scroll-outline-down-line')
def scrollOutlineDownLine(self, event=None):
    """Scroll the outline pane down one line."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('down-line')
    elif hasattr(tree.canvas, 'leo_treeBar'):
        a, b = tree.canvas.leo_treeBar.get()
        if b &lt; 1.0: tree.canvas.yview_scroll(1, "unit")

@cmd('scroll-outline-down-page')
def scrollOutlineDownPage(self, event=None):
    """Scroll the outline pane down one page."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('down-page')
    elif hasattr(tree.canvas, 'leo_treeBar'):
        a, b = tree.canvas.leo_treeBar.get()
        if b &lt; 1.0: tree.canvas.yview_scroll(1, "page")

@cmd('scroll-outline-up-line')
def scrollOutlineUpLine(self, event=None):
    """Scroll the outline pane up one line."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('up-line')
    elif hasattr(tree.canvas, 'leo_treeBar'):
        a, b = tree.canvas.leo_treeBar.get()
        if a &gt; 0.0: tree.canvas.yview_scroll(-1, "unit")

@cmd('scroll-outline-up-page')
def scrollOutlineUpPage(self, event=None):
    """Scroll the outline pane up one page."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('up-page')
    elif hasattr(tree.canvas, 'leo_treeBar'):
        a, b = tree.canvas.leo_treeBar.get()
        if a &gt; 0.0: tree.canvas.yview_scroll(-1, "page")
</t>
<t tx="ekr.20150514063305.338">@cmd('scroll-outline-left')
def scrollOutlineLeft(self, event=None):
    """Scroll the outline left."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('left')
    elif hasattr(tree.canvas, 'xview_scroll'):
        tree.canvas.xview_scroll(1, "unit")

@cmd('scroll-outline-right')
def scrollOutlineRight(self, event=None):
    """Scroll the outline left."""
    tree = self.c.frame.tree
    if hasattr(tree, 'scrollDelegate'):
        tree.scrollDelegate('right')
    elif hasattr(tree.canvas, 'xview_scroll'):
        tree.canvas.xview_scroll(-1, "unit")
</t>
<t tx="ekr.20150514063305.504">def change(self, event=None):
    """Make the selected change to the text"""
    if not self.loaded:
        return False
    c = self.c
    w = c.frame.body.wrapper
    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        i = getattr(self.tab, 'change_i', None)
        j = getattr(self.tab, 'change_j', None)
        if i is not None:
            start, end = i, j
            oldSel = start, end
        else:
            start, end = oldSel = w.getSelectionRange()
        if start is not None:
            if start &gt; end: start, end = end, start
            w.delete(start, end)
            w.insert(start, selection)
            w.setSelectionRange(start, start + len(selection))
            c.frame.body.onBodyChanged("Change", oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True
    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
</t>
<t tx="ekr.20150514063305.505">def find(self, event=None):
    """Find the next unknown word."""
    if not self.loaded:
        return
    c, n, p = self.c, 0, self.c.p
    sc = self.spellController
    w = c.frame.body.wrapper
    c.selectPosition(p)
    s = w.getAllText().rstrip()
    ins = w.getInsertPoint()
    # New in Leo 5.3: use regex to find words.
    last_p = p.copy()
    while True:
        for m in self.re_word.finditer(s[ins:]):
            start, word = m.start(0), m.group(0)
            if word in self.seen:
                continue
            n += 1
            # Ignore the word if numbers precede or follow it.
            # Seems difficult to do this in the regex itself.
            k1 = ins + start - 1
            if k1 &gt;= 0 and s[k1].isdigit():
                continue
            k2 = ins + start + len(word)
            if k2 &lt; len(s) and s[k2].isdigit():
                continue
            alts = sc.process_word(word)
            if alts:
                self.currentWord = word
                i = ins + start
                j = i + len(word)
                self.showMisspelled(p)
                self.tab.fillbox(alts, word)
                c.invalidateFocus()
                c.bodyWantsFocus()
                w.setSelectionRange(i, j, insert=j)
                k = g.see_more_lines(s, j, 4)
                w.see(k)
                return
            self.seen.add(word)
        # No more misspellings in p
        p.moveToThreadNext()
        if p:
            ins = 0
            s = p.b
        else:
            g.es("no more misspellings")
            c.selectPosition(last_p)
            self.tab.fillbox([])
            c.invalidateFocus()
            c.bodyWantsFocus()
            return
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150615174549.1">def show_find_options_in_status_area(self):  # pragma: no cover (cmd)
    """Show find options in the status area."""
    c = self.c
    s = self.compute_find_options_in_status_area()
    c.frame.putStatusLine(s)
</t>
<t tx="ekr.20150619070602.1">def show_status(self, found):
    """Show the find status the Find dialog, if present, and the status line."""
    c = self.c
    status = 'found' if found else 'not found'
    options = self.compute_result_status()
    s = f"{status}:{options} {self.find_text}"
    # Set colors.
    found_bg = c.config.getColor('find-found-bg') or 'blue'
    not_found_bg = c.config.getColor('find-not-found-bg') or 'red'
    found_fg = c.config.getColor('find-found-fg') or 'white'
    not_found_fg = c.config.getColor('find-not-found-fg') or 'white'
    bg = found_bg if found else not_found_bg
    fg = found_fg if found else not_found_fg
    if c.config.getBool("show-find-result-in-status") is not False:
        c.frame.putStatusLine(s, bg=bg, fg=fg)
</t>
<t tx="ekr.20150621062355.1">def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
</t>
<t tx="ekr.20150629072547.1">def preload_find_pattern(self, w):  # pragma: no cover (cmd)
    """Preload the find pattern from the selected text of widget w."""
    c, ftm = self.c, self.ftm
    if not c.config.getBool('preload-find-pattern', default=False):
        # Make *sure* we don't preload the find pattern if it is not wanted.
        return
    if not w:
        return
    #
    # #1436: Don't create a selection if there isn't one.
    #        Leave the search pattern alone!
    #
        # if not w.hasSelection():
        #     c.editCommands.extendToWord(event=None, select=True, w=w)
    #
    # #177:  Use selected text as the find string.
    # #1436: Make make sure there is a significant search pattern.
    s = w.getSelectedText()
    if s.strip():
        ftm.set_find_text(s)
        ftm.init_focus()
</t>
<t tx="ekr.20150629084204.1">@cmd('find-def')
def find_def(self, event=None, strict=False):  # pragma: no cover (cmd)
    """Find the def or class under the cursor."""
    ftm, p = self.ftm, self.c.p
    # Check.
    word = self._compute_find_def_word(event)
    if not word:
        return
    # Settings...
    prefix = 'class' if word[0].isupper() else 'def'
    find_pattern = prefix + ' ' + word
    ftm.set_find_text(find_pattern)
    self._save_before_find_def(p)  # Save previous settings.
    self.init_vim_search(find_pattern)
    self.update_change_list(self.change_text)  # Optional. An edge case.
    # Do the command!
    settings = self._compute_find_def_settings(find_pattern)
    self.do_find_def(settings, word, strict)

def find_def_strict(self, event=None):  #pragma: no cover (cmd)
    """Same as find_def, but don't call _switch_style."""
    self.find_def(event=event, strict=True)

def do_find_def(self, settings, word, strict):
    """A standalone helper for unit tests."""
    return self._fd_helper(settings, word, def_flag=True, strict=strict)

</t>
<t tx="ekr.20150629084611.1">def _compute_find_def_word(self, event):  # pragma: no cover (cmd)
    """Init the find-def command. Return the word to find or None."""
    c = self.c
    w = c.frame.body.wrapper
    # First get the word.
    c.bodyWantsFocusNow()
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    if keyword.iskeyword(word):
        return None
    # Return word, stripped of preceding class or def.
    for tag in ('class ', 'def '):
        found = word.startswith(tag) and len(word) &gt; len(tag)
        if found:
            return word[len(tag) :].strip()
    return word
</t>
<t tx="ekr.20150629095511.1">def _restore_after_find_def(self):
    """Restore find settings in effect before a find-def command."""
    b = self.find_def_data  # A g.Bunch
    if b:
        self.ignore_case = b.ignore_case
        self.pattern_match = b.pattern_match
        self.search_body = b.search_body
        self.search_headline = b.search_headline
        self.whole_word = b.whole_word
        self.find_def_data = None
</t>
<t tx="ekr.20150629095633.1">def _save_before_find_def(self, p):
    """Save the find settings in effect before a find-def command."""
    if not self.find_def_data:
        self.find_def_data = g.Bunch(
            ignore_case=self.ignore_case,
            p=p.copy(),
            pattern_match=self.pattern_match,
            search_body=self.search_body,
            search_headline=self.search_headline,
            whole_word=self.whole_word,
        )
</t>
<t tx="ekr.20150629125733.1">def _fd_helper(self, settings, word, def_flag, strict):
    """
    Find the definition of the class, def or var under the cursor.
    
    return p, pos, newpos for unit tests.
    """
    c, find, ftm = self.c, self, self.ftm
    #
    # Recompute find_text for unit tests.
    if def_flag:
        prefix = 'class' if word[0].isupper() else 'def'
        self.find_text = settings.find_text = prefix + ' ' + word
    else:
        self.find_text = settings.find_text = word + ' ='
    # g.printObj(settings, tag='_fd_helper: settings')
    #
    # Just search body text.
    self.search_headline = False
    self.search_body = True
    w = c.frame.body.wrapper
    # Check.
    if not w:  # pragma: no cover
        return None, None, None
    save_sel = w.getSelectionRange()
    ins = w.getInsertPoint()
    # Always start in the root position.
    old_p = c.p
    p = c.rootPosition()
    # Required.
    c.selectPosition(p)
    c.redraw()
    c.bodyWantsFocusNow()
    # #1592.  Ignore hits under control of @nosearch
    while True:
        p, pos, newpos = self.find_next_match(p)
        found = pos is not None
        if not found or not g.inAtNosearch(c.p):
            break
    if not found and def_flag and not strict:
        # Leo 5.7.3: Look for an alternative defintion of function/methods.
        word2 = self._switch_style(word)
        p = c.rootPosition()  # Bug fix.
        if word2:
            find_pattern = prefix + ' ' + word2
            find.find_text = find_pattern
            ftm.set_find_text(find_pattern)
            # #1592.  Ignore hits under control of @nosearch
            while True:
                p, pos, newpos = self.find_next_match(p)
                found = pos is not None
                if not found or not g.inAtNosearch(p):
                    break
    if found:
        c.redraw(p)
        w.setSelectionRange(pos, newpos, insert=newpos)
        c.bodyWantsFocusNow()
        return p, pos, newpos
    self._restore_after_find_def()  # Avoid massive confusion!
    i, j = save_sel
    c.redraw(old_p)
    w.setSelectionRange(i, j, insert=ins)
    c.bodyWantsFocusNow()
    return None, None, None
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20150717105329.1">def _create_find_all_node(self, result):
    """Create a "Found All" node as the last node of the outline."""
    c = self.c
    found = c.lastTopLevel().insertAfter()
    assert found
    found.h = f"Found All:{self.find_text}"
    status = self.compute_result_status(find_all_flag=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    found.b = f"# {status}\n{''.join(result)}"
    return found
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160129073222.1">def __get_u(self):
    p = self
    return p.v.u

def __set_u(self, val: Dict):
    p = self
    p.v.u = val

u = property(
    __get_u, __set_u,
    doc="p.u property")
</t>
<t tx="ekr.20160409035115.1">def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) &gt; -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) &gt; -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
</t>
<t tx="ekr.20160415033936.1">def showMisspelled(self, p):
    """Show the position p, contracting the tree as needed."""
    c = self.c
    redraw = not p.isVisible(c)
    # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
    if c.sparse_spell and not c.p.isAncestorOf(p):
        for p2 in c.p.self_and_parents(copy=False):
            p2.contract()
            redraw = True
    for p2 in p.parents(copy=False):
        if not p2.isExpanded():
            p2.expand()
            redraw = True
    if redraw:
        c.redraw(p)
    else:
        c.selectPosition(p)
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160422073500.1">def _find_all_helper(self, after, data, p, undoType):
    """Handle the find-all command from p to after."""
    c, u = self.c, self.c.undoer
    both = self.search_body and self.search_headline
    count, found, result = 0, None, []
    while 1:
        p, pos, newpos = self.find_next_match(p)
        if pos is None: break
        count += 1
        s = self.work_s
        i, j = g.getLine(s, pos)
        line = s[i:j]
        if self.findAllUniqueFlag:
            m = self.match_obj
            if m:
                self.unique_matches.add(m.group(0).strip())
        elif both:
            result.append('%s%s\n%s%s\n' % (
                '-' * 20, p.h,
                "head: " if self.in_headline else "body: ",
                line.rstrip() + '\n'))
        elif p.isVisited():
            result.append(line.rstrip() + '\n')
        else:
            result.append('%s%s\n%s' % ('-' * 20, p.h, line.rstrip() + '\n'))
            p.setVisited()
    if result or self.unique_matches:
        undoData = u.beforeInsertNode(c.p)
        if self.findAllUniqueFlag:
            found = self._create_find_unique_node()
            count = len(list(self.unique_matches))
        else:
            found = self._create_find_all_node(result)
        u.afterInsertNode(found, undoType, undoData)
        c.selectPosition(found)
        c.setChanged()
    else:
        self.restore(data)
    return count
</t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160920110324.1">@cmd('clone-find-tag')
@cmd('find-clone-tag')
@cmd('cft')
def interactive_clone_find_tag(self, event=None):  # pragma: no cover (interactive)
    """
    clone-find-tag (aka find-clone-tag and cft).

    Create an organizer node whose descendants contain clones of all
    nodes matching the given tag, except @nosearch trees.

    The list is *always* flattened: every cloned node appears as a
    direct child of the organizer node, even if the clone also is a
    descendant of another cloned node.
    """
    w = self.c.frame.body.wrapper
    if w:
        self.start_state_machine(event,
            prefix='Clone Find Tag: ',
            handler=self.interactive_clone_find_tag1)

def interactive_clone_find_tag1(self, event):  # pragma: no cover (interactive)
    c, k = self.c, self.k
    # Settings...
    self.find_text = tag = k.arg
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_clone_find_tag(tag)
    c.treeWantsFocus()
</t>
<t tx="ekr.20160920164418.2">@cmd('tag-children')
def interactive_tag_children(self, event=None):  # pragma: no cover (interactive)
    """tag-children: prompt for a tag and add it to all children of c.p."""
    w = self.c.frame.body.wrapper
    if not w:
        return
    self.start_state_machine(event,
        prefix='Tag Children: ',
        handler=self.interactive_tag_children1)

def interactive_tag_children1(self, event):  # pragma: no cover (interactive)
    c, k, p = self.c, self.k, self.c.p
    # Settings...
    tag = k.arg
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    self.do_tag_children(p, tag)
    c.treeWantsFocus()
</t>
<t tx="ekr.20160920164418.4">def do_tag_children(self, p, tag):
    """Handle the tag-children command."""
    c = self.c
    tc = getattr(c, 'theTagController', None)
    if not tc:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print('nodetags not active')
        return
    for p in p.children():
        tc.add_tag(p, tag)
    if not g.unitTesting:  # pragma: no cover (skip)
        g.es_print(f"Added {tag} tag to {len(list(c.p.children()))} nodes")

</t>
<t tx="ekr.20160920221324.1">def convert_to_html(self, s):
    '''Convert s to html using docutils.'''
    c, p = self.c, self.c.p
    # Update the current path.
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    try:
        if self.title:
            s = self.underline(self.title) + s
            self.title = None
        # Call docutils to get the string.
        s = publish_string(s, writer_name='html')
        s = g.toUnicode(s)
    except SystemMessage as sm:
        msg = sm.args[0]
        if 'SEVERE' in msg or 'FATAL' in msg:
            s = 'RST error:\n%s\n\n%s' % (msg, s)
    return s

def update_plantuml(self, s, keywords):
    pc = self
    w = pc.ensure_text_widget()
    path = self.c.p.h[9:].strip()
    print("Plantuml output file name: ", path)
    with open("temp.plantuml", "w") as f:
        f.write(s)
    pth_plantuml_jar = "~/.leo"
    os.system("cat temp.plantuml | java -jar %s/plantuml.jar -pipe &gt; %s" % (pth_plantuml_jar, path))
    template = image_template % (path)
    # Only works in Python 3.x.
    template = g.adjustTripleString(template, pc.c.tab_width).strip()
    pc.show()
    w.setReadOnly(False)
    w.setHtml(template)
    w.setReadOnly(True)

def update_jinja(self, s, keywords):
    pc = self
    h = self.c.p.h
    p = self.c.p
    c = self.c
    oldp = None

    #print "try act"
    if not h.startswith('@jinja'):
        #print("Not a @jinja node")
        return

    def find_root(p):
        for newp in p.parents():
            if newp.h.strip() == '@jinja':
                oldp, p = p, newp
                #print("Found @jinja node")
                return oldp, p
        return None, None

    def find_inputs(p):
        for newp in p.parents():
            if newp.h.strip() == '@jinja inputs':
                oldp, p = p, newp
                _, p = find_root(p) 
                return oldp, p
        return None, None
        
    # if on jinja node's children, find the parent
    if h.strip() == '@jinja template' or h.strip() == '@jinja inputs':
        # not at @jinja, find from parents
        oldp, p = find_root(p)

    elif h.startswith('@jinja variable'):
        # not at @jinja, first find @jinja inputs, then @jinja
        oldp, p = find_inputs(p) 

    def untangle(c,p):
    
        return g.getScript(c,p,
            useSelectedText=False,
            useSentinels=False)

    template_data = {}
    for child in p.children():
        if child.h == '@jinja template':
            template_path = g.os_path_finalize_join(c.getNodePath(p), untangle(c, child).strip())
            #print("template_path: ", template_path)
        elif child.h == '@jinja inputs':
            for template_var_node in child.children():
                template_data[template_var_node.h.replace('@jinja variable', '').strip()] = untangle(c, template_var_node).strip()
            #print("template_data: ", template_data)

    if not template_path:
        g.es("No template_path given. Your @jinja node should contain a child node 'template' with the path to the template (relative or absolute)")
        return

    #print "act"
    tmpl = Template(Path(template_path).read_text())
    out = tmpl.render(template_data)
    w = pc.ensure_text_widget()
    pc.show()
    w.setPlainText(out)
    p.b = out
    c.redraw(p)
    
    # focus back on entry node
    if oldp:
        c.redraw(oldp)
    
</t>
<t tx="ekr.20160924135613.1">def doPlainChar(self, action, ch, event, inBrackets, oldSel, stroke, w):
    c, p = self.c, self.c.p
    isPlain = stroke.find('Alt') == -1 and stroke.find('Ctrl') == -1
    i, j = oldSel
    if i &gt; j: i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j: w.delete(i, j)
    elif action == 'overwrite': w.delete(i)
    if isPlain:
        ins = w.getInsertPoint()
        if self.autojustify &gt; 0 and not inBrackets:
            # Support #14: auto-justify body text.
            s = w.getAllText()
            i = g.skip_to_start_of_line(s, ins)
            i, j = g.getLine(s, i)
            # Only insert a newline at the end of a line.
            if j - i &gt;= self.autojustify and (ins &gt;= len(s) or s[ins] == '\n'):
                # Find the start of the word.
                n = 0
                ins -= 1
                while ins - 1 &gt; 0 and g.isWordChar(s[ins - 1]):
                    n += 1
                    ins -= 1
                sins = ins  # start of insert, to collect trailing whitespace
                while sins &gt; 0 and s[sins - 1] in (' \t'):
                    sins -= 1
                oldSel = (sins, ins)
                self.insertNewlineHelper(w, oldSel, undoType=None)
                ins = w.getInsertPoint()
                ins += (n + 1)
        w.insert(ins, ch)
        w.setInsertPoint(ins + 1)
    else:
        g.app.gui.insertKeyEvent(event, i)
    if inBrackets and self.flashMatchingBrackets:
        self.flashMatchingBracketsHelper(c, ch, i, p, w)
</t>
<t tx="ekr.20161020031633.1">"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    &lt;Return&gt; or (sometimes) &lt;tab&gt;.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        from leo.commands import checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20161028040054.1">self.already_open_files = []
    # A list of file names that *might* be open in another
    # copy of Leo.
self.dragging = False
    # True: dragging.
self.inBridge = False
    # True: running from leoBridge module.
self.inScript = False
    # True: executing a script.
self.initing = True
    # True: we are initiing the app.
self.initComplete = False
    # True: late bindings are not allowed.
self.killed = False
    # True: we are about to destroy the root window.
self.openingSettingsFile = False
    # True, opening a settings file.
self.preReadFlag = False
    # True: we are pre-reading a settings file.
self.quitting = False
    # True: quitting.  Locks out some events.
self.restarting = False
    # True: restarting all of Leo. #1240.
self.reverting = False
    # True: executing the revert command.
self.syntax_error_files = []
</t>
<t tx="ekr.20161028095553.1">def put_log(self, s):
    """
    Put a string to the originating log.
    This is not what g.es_print does!
    
    Create clickable links s matches self.data.link_pattern.
    See p.get_UNL.
    
    New in Leo 6.4: get the filename from link_pattern if link_root is None.
    """
    #
    # Warning: don't use g.es or g.es_print here!
    s = s and s.rstrip()
    if not s:
        return
    data = self.data
    if not data:
        return
    c = data.c
    if not c or not c.exists:
        return
    log = c.frame.log
    link_pattern, link_root = data.link_pattern, data.link_root
    #
    # Always print the message.
    print(s)
    #
    # Put the plain message if the link is not valid.
    if not link_pattern:
        log.put(s + '\n')
        return
    try:
        m = link_pattern.match(s)
    except Exception:
        m = None
    if not m:
        log.put(s + '\n')
        return
    #
    # Find the line number, and possibly the filename.
    if link_root:
        # m.group(1) should be the line number.
        try:
            line = int(m.group(1))
        except Exception:
            # g.es_exception()
            log.put(s + '\n')
            return
    else:
        # m.group(1) should be the path to the file.
        path = m.group(1)
        # m.group(2) should be the line number.
        try:
            line = int(m.group(2))
        except Exception:
            # g.es_exception()
            log.put(s + '\n')
            return
        # Look for the @&lt;file&gt; node.
        link_root = g.findNodeByPath(c, path)
        if not link_root:
            g.trace(f"no @&lt;file&gt; node found for : {path}")
            log.put(s + '\n')
            return
    #
    # Put a clickable link.
    unl = link_root.get_UNL(with_proto=True, with_count=True)
    nodeLink = f"{unl},{-line}"
    log.put(s + '\n', nodeLink=nodeLink)
</t>
<t tx="ekr.20161029103615.1">class Py_Importer(Importer):
    '''A class to store and update scanning state.'''

    def __init__(self, importCommands, language='python', **kwargs):
        '''Py_Importer.ctor.'''
        super().__init__(
            importCommands,
            language=language,
            state_class = Python_ScanState,
            strict=True,
        )
        self.put_decorators = self.c.config.getBool('put-python-decorators-in-imported-headlines')

    @others
</t>
<t tx="ekr.20161108131153.10">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():
        return None
    self.root = root = parent.copy()
    self.file_s = s
    # Init the error/status info.
    self.errors = 0
    self.parse_body = parse_body
    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    ws_ok = self.check_blanks_and_tabs(s) # Only issues warnings.
    # Regularize leading whitespace
    if not ws_ok:
        s = self.regularize_whitespace(s)
    # Generate the nodes, including directives and section references.
    # Completely generate all nodes.
    self.generate_nodes(s, parent)
    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    if parse_body:
        ok = self.errors == 0 # Work around problems with directives.
    else:
        ok = self.errors == 0 and self.check(s, parent)
    g.app.unitTestDict['result'] = ok
    # Insert an @ignore directive if there were any serious problems.
    if not ok:
        self.insert_ignore_directive(parent)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return ok
</t>
<t tx="ekr.20161108131153.11">def check_blanks_and_tabs(self, lines):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in g.splitLines(lines):
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            self.report(message)
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20161108131153.12">def insert_ignore_directive(self, parent):
    c = self.c
    parent.v.b = parent.v.b.rstrip() + '\n@ignore\n'
        # Do *not* update the screen by setting p.b.
    if g.unitTesting:
        g.app.unitTestDict['fail'] = g.callers()
    elif parent.isAnyAtFileNode() and not parent.isAtAutoNode():
        g.warning('inserting @ignore')
        c.import_error_nodes.append(parent.h)
</t>
<t tx="ekr.20161108131153.13">def post_pass(self, parent):
    '''
    Optional Stage 2 of the importer pipeline, consisting of zero or more
    substages. Each substage alters nodes in various ways.

    Subclasses may freely override this method, **provided** that all
    substages use the API for setting body text. Changing p.b directly will
    cause asserts to fail later in i.finish().
    '''
    self.clean_all_headlines(parent)
    if self.add_context:
        self.add_class_names(parent)
    self.clean_all_nodes(parent)
    self.unindent_all_nodes(parent)
    #
    # This sub-pass must follow unindent_all_nodes.
    self.promote_trailing_underindented_lines(parent)
    self.promote_last_lines(parent)
    #
    # This probably should be the last sub-pass.
    self.delete_all_empty_nodes(parent)
</t>
<t tx="ekr.20161108131153.14">def regularize_whitespace(self, s):
    '''
    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    '''
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    lines = g.splitLines(s)
    count, result, tab_width = 0, [], self.tab_width
    self.ws_error = False # 2016/11/23
    if tab_width &lt; 0: # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
                # Use negative width.
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for n, line in enumerate(lines):
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
                # Use positive width.
            if s != line:
                count += 1
            result.append(s)
    if count:
        self.ws_error = True # A flag to check.
        if not g.unitTesting:
            # g.es_print('Warning: Intermixed tabs and blanks in', fn)
            # g.es_print('Perfect import test will ignoring leading whitespace.')
            g.es('changed leading %s to %s in %s line%s in %s' % (
                kind2, kind, count, g.plural(count), fn))
        if g.unitTesting: # Sets flag for unit tests.
            self.report('changed %s lines' % count)
    return ''.join(result)
</t>
<t tx="ekr.20161108131153.15"></t>
<t tx="ekr.20161108131153.17">def get_str_lws(self, s):
    '''Return the characters of the lws of s.'''
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20161108131153.18">def error(self, s):
    '''Issue an error and cause a unit test to fail.'''
    self.errors += 1
    self.importCommands.errors += 1

def report(self, message):
    if self.strict:
        self.error(message)
    else:
        self.warning(message)

def warning(self, s):
    if not g.unitTesting:
        g.warning('Warning:', s)
</t>
<t tx="ekr.20161108131153.19">def undent(self, p):
    '''Remove maximal leading whitespace from the start of all lines.'''
    if self.is_rst:
        return p.b # Never unindent rst code.
    lines = self.get_lines(p)
    ws = self.common_lws(lines)
    result = []
    for s in lines:
        if s.startswith(ws):
            result.append(s[len(ws):])
        elif s.isspace():
            # Never change blank lines.
            result.append(s)
        else:
            # Indicate that the line is underindented.
            result.append("%s%s.%s" % (
                self.c.atFileCommands.underindentEscapeString,
                g.computeWidth(ws, self.tab_width),
                s.lstrip()))
    return result
</t>
<t tx="ekr.20161108131153.20">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    if not lines:
        return ''
    lws = self.get_str_lws(lines[0])
    for s in lines:
        if not self.is_ws_line(s):
            lws2 = self.get_str_lws(s)
            if lws2.startswith(lws):
                pass
            elif lws.startswith(lws2):
                lws = lws2
            else:
                lws = '' # Nothing in common.
                break
    return lws
</t>
<t tx="ekr.20161108131153.21">def underindented_comment(self, line):
    if self.at_auto_warns_about_leading_whitespace:
        self.warning(
            'underindented python comments.\n' +
            'Extra leading whitespace will be added\n' + line)

def underindented_line(self, line):
    if self.warn_about_underindented_lines:
        self.error(
            'underindented line.\n'
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20161108131153.3">def check(self, unused_s, parent):
    '''True if perfect import checks pass.'''
    if g.app.suppressImportChecks:
        g.app.suppressImportChecks = False
        return True
    c = self.c
    sfn = g.shortFileName(self.root.h)
    s1 = g.toUnicode(self.file_s, self.encoding)
    s2 = self.trial_write()
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    if 0: # An excellent trace for debugging.
        g.trace(c.shortFileName())
        g.printObj(lines1, tag='lines1')
        g.printObj(lines2, tag='lines2')
    if self.strict:
        # Ignore blank lines only.
        # Adding nodes may add blank lines.
        lines1 = self.strip_blank_lines(lines1)
        lines2 = self.strip_blank_lines(lines2)
    else:
        # Ignore blank lines and leading whitespace.
        # Importing may regularize whitespace, and that's good.
        lines1 = self.strip_all(lines1)
        lines2 = self.strip_all(lines2)
    # Forgive trailing whitespace problems in the last line.
    # This is not the same as clean_last_lines.
    if lines1 and lines2 and lines1 != lines2:
        lines1[-1] = lines1[-1].rstrip()+'\n'
        lines2[-1] = lines2[-1].rstrip()+'\n'
    # self.trace_lines(lines1, lines2, parent)
    ok = lines1 == lines2
    if not ok and not self.strict:
        # Issue an error only if something *other than* lws is amiss.
        lines1, lines2 = self.strip_lws(lines1), self.strip_lws(lines2)
        ok = lines1 == lines2
        if ok and not g.unitTesting:
            print('warning: leading whitespace changed in:', self.root.h)
    if not ok:
        self.show_failure(lines1, lines2, sfn)
        # self.trace_lines(lines1, lines2, parent)
    # Ensure that the unit tests fail when they should.
    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        d['result'] = ok
        if not ok:
            d['fail'] = g.callers()
            # Used in a unit test.
            c.importCommands.errors += 1
    return ok
</t>
<t tx="ekr.20161108131153.4">def clean_blank_lines(self, lines):
    '''Remove all blanks and tabs in all blank lines.'''
    return [self.lstrip_line(z) if z.isspace() else z for z in lines]
</t>
<t tx="ekr.20161108131153.5">def lstrip_line(self, s):
    '''Delete leading whitespace, *without* deleting the trailing newline!'''
    # This fixes a major bug in strip_lws.
    assert s, g.callers()
    return '\n' if s.isspace() else s.lstrip()

def strip_all(self, lines):
    '''Strip blank lines and leading whitespace from all lines of s.'''
    return self.strip_lws(self.strip_blank_lines(lines))

def strip_blank_lines(self, lines):
    '''Strip all blank lines from s.'''
    return [z for z in lines if not z.isspace()]

def strip_lws(self, lines):
    '''Strip leading whitespace from all lines.'''
    return [self.lstrip_line(z) for z in lines]
    # This also works, but I prefer the "extra" call to lstrip().
    # return ['\n' if z.isspace() else z.lstrip() for z in lines].


</t>
<t tx="ekr.20161108131153.6">def trial_write(self):
    '''Return the trial write for self.root.'''
    at = self.c.atFileCommands
    # Leo 5.6: Allow apparent section refs for *all* languages.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        result = at.atAutoToString(self.root)
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
    return g.toUnicode(result, self.encoding)
</t>
<t tx="ekr.20161108131153.7"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161108131153.8">def adjust_parent(self, parent, headline):
    '''Return the effective parent.

    This is overridden by the RstScanner class.'''
    return parent
</t>
<t tx="ekr.20161108131153.9">def clean_headline(self, s, p=None):
    '''
    Return the cleaned version headline s.
    Will typically be overridden in subclasses.
    '''
    return s.strip()
</t>
<t tx="ekr.20161108155143.3">def get_int_lws(self, s):
    '''Return the the lws (a number) of line s.'''
    # Important: use self.tab_width, *not* c.tab_width.
    return g.computeLeadingWhitespaceWidth(s, self.tab_width)
</t>
<t tx="ekr.20161108155143.4">def match(self, s, i, pattern):
    '''Return True if the pattern matches at s[i:]'''
    return s[i:i+len(pattern)] == pattern
</t>
<t tx="ekr.20161108155730.1">class Importer:
    '''
    The new, unified, simplified, interface to Leo's importer code.

    Eventually, all importers will create use this class.
    '''

    @others
</t>
<t tx="ekr.20161108155925.1">def __init__(self,
    importCommands,
    gen_refs=False, # True: generate section references,
    language=None, # For @language directive.
    name=None, # The kind of importer, usually the same as language
    state_class=None, # For i.scan_line
    strict=False,
    **kwargs
):
    '''
    Importer.__init__: New in Leo 6.1.1: ic and c may be None for unit tests.
    '''
    # Copies of args...
    self.importCommands = ic = importCommands
    self.c = c = ic and ic.c
    self.encoding = ic and ic.encoding or 'utf-8'
    self.gen_refs = gen_refs
    self.language = language or name
        # For the @language directive.
    self.name = name or language
    language = self.language
    name = self.name
    assert language and name
    assert self.language and self.name
    self.state_class = state_class
    self.strict = strict
        # True: leading whitespace is significant.
    #
    # Set from ivars...
    self.has_decls = name not in ('xml', 'org-mode', 'vimoutliner')
    self.is_rst = name in ('rst',)
    self.tree_type = ic.treeType if c else None # '@root', '@file', etc.
    #
    # Constants...
    if ic:
        data = g.set_delims_from_language(self.name)
        self.single_comment, self.block1, self.block2 = data
    else:
        self.single_comment, self.block1, self.block2 = '//', '/*', '*/' # Javascript.
    if ic:
        self.escape = c.atFileCommands.underindentEscapeString
        self.escape_string = r'%s([0-9]+)\.' % re.escape(self.escape)
        # m.group(1) is the unindent value.
        self.escape_pattern = re.compile(self.escape_string)
    self.ScanState = ScanState
        # Must be set by subclasses that use general_scan_line.
    self.tab_width = 0 # Must be set in run, using self.root.
    self.ws_pattern = re.compile(r'^\s*$|^\s*%s' % (self.single_comment or ''))
    #
    # Settings...
    self.reloadSettings()
    #
    # State vars.
    self.errors = 0
    if ic:
        ic.errors = 0 # Required.
    self.parse_body = False
    self.refs_dict = {}
        # Keys are headlines. Values are disambiguating number.
    self.skip = 0 # A skip count for x.gen_lines &amp; its helpers.
    self.ws_error = False
    self.root = None

def reloadSettings(self):
    c = self.c
    if not c:
        return
    getBool = c.config.getBool
    c.registerReloadSettings(self)
    # self.at_auto_separate_non_def_nodes = False
    self.add_context = getBool("add-context-to-headlines")
    self.add_file_context = getBool("add-file-context-to-headlines")
    self.at_auto_warns_about_leading_whitespace = getBool('at_auto_warns_about_leading_whitespace')
    self.warn_about_underindented_lines = True
   
</t>
<t tx="ekr.20161108160409.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    trace = 'importers' in g.app.debug
    tail_p = None
    prev_state = self.state_class()
    target = Target(parent, prev_state)
    stack = [target, target]
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        # g.trace(new_state.level(), f"{new_state.level() &lt; top.state.level():1}", repr(line))
        if trace:
            g.trace('%d %d %s' % (
                self.starts_block(i, lines, new_state, prev_state),
                self.ends_block(line, new_state, prev_state, stack),
                line.rstrip()))
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.is_ws_line(line):
            p = tail_p or top.p
            self.add_line(p, line)
        elif self.starts_block(i, lines, new_state, prev_state):
            tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif self.ends_block(line, new_state, prev_state, stack):
            tail_p = self.end_block(line, new_state, stack)
        else:
            p = tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
</t>
<t tx="ekr.20161108160409.3">def end_block(self, line, new_state, stack):
    # The block is ending. Add tail lines until the start of the next block.
    p = stack[-1].p
    self.add_line(p, line)
    self.cut_stack(new_state, stack)
    tail_p = None if self.gen_refs else p
    return tail_p
</t>
<t tx="ekr.20161108160409.5">def add_root_directives(self, parent):
    '''Return the proper directives for the root node p.'''
    table = [
        '@language %s\n' % self.language,
        '@tabwidth %d\n' % self.tab_width,
    ]
    if self.parse_body:
        pass
    elif self.has_lines(parent):
        # Make sure the last line ends with a newline.
        lines = self.get_lines(parent)
        if lines:
            last_line = lines.pop()
            last_line = last_line.rstrip() + '\n'
            self.add_line(parent, last_line)
        self.extend_lines(parent, table)
    else:
        self.set_lines(parent, table)
</t>
<t tx="ekr.20161108160409.6">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    if hasattr(new_state, 'in_context'):
        assert not new_state.in_context(), ('start_new_block', new_state)
    line = lines[i]
    target=stack[-1]
    # Insert the reference in *this* node.
    h = self.gen_ref(line, target.p, target)
    # Create a new child and associated target.
    child = self.create_child_node(target.p, line, h)
    stack.append(Target(child, new_state))
</t>
<t tx="ekr.20161108160409.7">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline.strip()
    return child
</t>
<t tx="ekr.20161108160409.8">def gen_ref(self, line, parent, target):
    '''
    Generate the ref line. Return the headline.
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if self.gen_refs:
        # Fix #441: Make sure all section refs are unique.
        d = self.refs_dict
        n = d.get(h, 0)
        d [h] = n + 1
        if n &gt; 0:
            h = '%s: %s' % (n, h)
        headline = g.angleBrackets(' %s ' % h)
        ref = '%s%s\n' % (
            indent_ws,
            g.angleBrackets(' %s ' % h))
    else:
        if target.ref_flag:
            ref = None
        else:
            ref = '%s@others\n' % indent_ws
            target.at_others_flag = True
        target.ref_flag = True
            # Don't generate another @others in this target.
        headline = h
    if ref:
        self.add_line(parent,ref)
    return headline
</t>
<t tx="ekr.20161108165530.1"></t>
<t tx="ekr.20161108170435.1">def scan_line(self, s, prev_state):
    '''
    A generalized scan-line method.

    SCAN STATE PROTOCOL:

    The Importer class should have a state_class ivar that references a
    **state class**. This class probably should *not* be subclass of the
    ScanState class, but it should observe the following protocol:

    1. The state class's ctor must have the following signature:

        def __init__(self, d)

    2. The state class must have an update method.
    '''
    # This dict allows new data to be added without changing ScanState signatures.
    d = {
        'indent': self.get_int_lws(s),
        'is_ws_line': self.is_ws_line(s),
        'prev':prev_state,
        's':s,
    }
    new_state = self.state_class(d)
    i = 0
    while i &lt; len(s):
        progress = i
        context = new_state.context
        table = self.get_table(context)
        data = self.scan_dict(context, i, s, table)
        i = new_state.update(data)
        assert progress &lt; i
    return new_state
</t>
<t tx="ekr.20161108180655.2">def undent_by(self, s, undent_val):
    '''
    Remove leading whitespace equivalent to undent_val from each line.

    Strict languages: prepend the underindent escape for underindented lines.
    '''
    if self.is_rst:
        return s # Never unindent rst code.
    result = []
    for line in g.splitlines(s):
        lws_s = self.get_str_lws(line)
        lws = g.computeWidth(lws_s, self.tab_width)
        # Add underindentEscapeString only for strict languages.
        if self.strict and not line.isspace() and lws &lt; undent_val:
            # End the underindent count with a period to
            # protect against lines that start with a digit!
            result.append("%s%s.%s" % (
                self.escape, undent_val-lws, line.lstrip()))
        else:
            s = g.removeLeadingWhitespace(line, undent_val, self.tab_width)
            result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20161109045312.1"></t>
<t tx="ekr.20161109045619.1">def print_lines(self, lines):
    '''Print lines for debugging.'''
    print('[')
    for line in lines:
        print(repr(line))
    print(']')

print_list = print_lines
</t>
<t tx="ekr.20161109052011.1">def is_ws_line(self, s):
    '''Return True if s is nothing but whitespace and single-line comments.'''
    return bool(self.ws_pattern.match(s))
</t>
<t tx="ekr.20161109053143.1">def get_leading_indent(self, lines, i, ignoreComments=True):
    '''
    Return the leading whitespace (an int) of the first significant line.
    Ignore blank and comment lines if ignoreComments is True
    '''
    if ignoreComments:
        while i &lt; len(lines):
            if self.is_ws_line(lines[i]):
                i += 1
            else:
                break
    return self.get_int_lws(lines[i]) if i &lt; len(lines) else 0
</t>
<t tx="ekr.20161109072221.1">def undent_body_lines(self, lines, ignoreComments=True):
    '''
    Remove the first line's leading indentation from all lines.
    Return the resulting string.
    '''
    s = ''.join(lines)
    if self.is_rst:
        return s # Never unindent rst code.
    # Calculate the amount to be removed from each line.
    undent_val = self.get_leading_indent(lines, 0, ignoreComments=ignoreComments)
    if undent_val == 0:
        return s
    result = self.undent_by(s, undent_val)
    return result
</t>
<t tx="ekr.20161110042020.1">def finalize_ivars(self, parent):
    '''
    Update the body text of all nodes in parent's tree using the injected
    v._import_lines lists.
    '''
    for p in parent.self_and_subtree():
        v = p.v
        # Make sure that no code in x.post_pass has mistakenly set p.b.
        assert not v._bodyString, repr(v._bodyString)
        lines = v._import_lines
        if lines:
            if not lines[-1].endswith('\n'):
                lines[-1] += '\n'
        v._bodyString = g.toUnicode(''.join(lines), reportErrors=True)
            # Bug fix: 2017/01/24: must convert to unicode!
            # This was the source of the internal error in the p.b getter.
        delattr(v, '_import_lines')
</t>
<t tx="ekr.20161110042512.1"># All code in passes 1 and 2 *must* use this API to change body text.

def add_line(self, p, s):
    '''Append the line s to p.v._import_lines.'''
    assert s and isinstance(s, str), (repr(s), g.callers())
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (repr(s), g.callers())
    p.v._import_lines.append(s)

def clear_lines(self, p):
    p.v._import_lines = []

def extend_lines(self, p, lines):
    p.v._import_lines.extend(list(lines))

def get_lines(self, p):
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (p and p.h, g.callers())
    return p.v._import_lines

def has_lines(self, p):
    return hasattr(p.v, '_import_lines')

def inject_lines_ivar(self, p):
    '''Inject _import_lines into p.v.'''
    # *Never* change p unexpectedly!
    assert not p.v._bodyString, (p and p.h, g.callers(10))
    p.v._import_lines = []

def prepend_lines(self, p, lines):
    p.v._import_lines = list(lines) + p.v._import_lines

def set_lines(self, p, lines):
    p.v._import_lines = list(lines)
</t>
<t tx="ekr.20161110073751.1">def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    if p: # Called from clean_all_headlines:
        return self.get_decorator(p) + p.h
    # Handle defs.
    m = re.match(r'\s*def\s+(\w+)', s)
    if m:
        return m.group(1)
    # Handle classes.
    #913: Show base classes in python importer.
    #978: Better regex handles class C(bar.Bar)
    m = re.match(r'\s*class\s+(\w+)\s*(\([\w.]+\))?', s)
    if m:
        return 'class %s%s' % (m.group(1), m.group(2) or '')
    return s.strip()

def get_decorator(self, p):
    if g.unitTesting or self.put_decorators:
        for s in self.get_lines(p):
            if not s.isspace():
                m = re.match(r'\s*@\s*([\w\.]+)', s)
                if m:
                    s = s.strip()
                    if s.endswith('('):
                        s = s[:-1].strip()
                    return s + ' '
                return ''
    return ''
</t>
<t tx="ekr.20161110125940.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Note: i.gen_ref calls clean_headline without knowing p.
        # As a result, the first argument is required.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
    
</t>
<t tx="ekr.20161110130157.1">def clean_all_nodes(self, parent):
    '''Clean the nodes in parent's tree, in a language-dependent way.'''
    # i.clean_nodes does nothing.
    # Subclasses may override as desired.
    # See perl_i.clean_nodes for an example.
    self.clean_nodes(parent)
</t>
<t tx="ekr.20161110130337.1">def unindent_all_nodes(self, parent):
    '''Unindent all nodes in parent's tree.'''
    for p in parent.subtree():
        lines = self.get_lines(p)
        if all([z.isspace() for z in lines]):
            # Somewhat dubious, but i.check covers for us.
            self.clear_lines(p)
        else:
            self.set_lines(p, self.undent(p))
</t>
<t tx="ekr.20161110130709.1">def delete_all_empty_nodes(self, parent):
    '''
    Delete nodes consisting of nothing but whitespace.
    Move the whitespace to the preceding node.
    '''
    c = self.c
    aList = []
    for p in parent.subtree():
        back = p.threadBack()
        if back and back.v != parent.v and back.v != self.root.v and not p.isCloned():
            lines = self.get_lines(p)
            # Move the whitespace from p to back.
            if all([z.isspace() for z in lines]):
                self.extend_lines(back, lines)
                # New in Leo 5.7: empty nodes may have children.
                if p.hasChildren():
                    # Don't delete p.
                    p.h = 'organizer'
                    self.clear_lines(p)
                else:
                    # Do delete p.
                    aList.append(p.copy())
    if aList:
        c.deletePositionsInList(aList, redraw=False)
            # Suppress redraw.
</t>
<t tx="ekr.20161110131509.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.subtree():
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    g.trace(line)
                    # Fix #652 by restoring the line.
                    new_line = line[len(m.group(0)):].lstrip()
                    lines.append(new_line)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            if parent.parent() == self.root:
                parent = parent.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161110173058.1">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161111023249.1">def finish(self, parent):
    '''
    Stage 3 (the last) stage of the importer pipeline.

    Subclasses should never need to override this method.
    '''
    # Put directives at the end, so as not to interfere with shebang lines, etc.
    self.add_root_directives(parent)
    #
    # Finally, remove all v._import_list temporaries.
    self.finalize_ivars(parent)
</t>
<t tx="ekr.20161111024447.1">def generate_nodes(self, s, parent):
    '''
    A three-stage pipeline to generate all imported nodes.
    '''
    # Stage 1: generate nodes.
    # After this stage, the p.v._import_lines list contains p's future body text.
    self.gen_lines(s, parent)
    #
    # Optional Stage 2, consisting of zero or more sub-stages.
    # Subclasses may freely override this method, **provided**
    # that all substages use the API for setting body text.
    # Changing p.b directly will cause asserts to fail in i.finish().
    self.post_pass(parent)
    #
    # Stage 3: Put directives in the root node and set p.b for all nodes.
    #
    # Subclasses should never need to override this stage.
    self.finish(parent)
</t>
<t tx="ekr.20161113135037.1">@nobeautify
cached_scan_tables = {}

def get_table(self, context):
    '''
    Return the state table for the given context.

    This method handles caching.  x.get_new_table returns the actual table.
    '''
    key = '%s.%s' % (self.name, context)
        # Bug fix: must keep tables separate.
    table = self.cached_scan_tables.get(key)
    if table:
        return table
    table = self.get_new_dict(context)
    self.cached_scan_tables[key] = table
    return table
</t>
<t tx="ekr.20161114012522.1">def all_contexts(self, table):
    '''
    Return a list of all contexts contained in the third column of the given table.

    This is a support method for unit tests.
    '''
    contexts = set()
    d = table
    for key in d:
        aList = d.get(key)
        for data in aList:
            if len(data) == 4:
                # It's an out-of-context entry.
                contexts.add(data[2])
    # Order must not matter, so sorting is ok.
    return sorted(contexts)
</t>
<t tx="ekr.20161114024119.1">def test_scan_state(self, tests, State):
    '''
    Test x.scan_line or i.scan_line.

    `tests` is a list of g.Bunches with 'line' and 'ctx' fields.

    A typical @command test:

        if c.isChanged(): c.save()
        &lt; &lt; imp.reload importers.linescanner and importers.python &gt; &gt;
        importer = py.Py_Importer(c.importCommands)
        importer.test_scan_state(tests, Python_ScanState)
    '''
    assert self.single_comment == '#', self.single_comment
    table = self.get_table(context='')
    contexts = self.all_contexts(table)
    for bunch in tests:
        assert bunch.line is not None
        line = bunch.line
        ctx = getattr(bunch, 'ctx', None)
        if ctx: # Test one transition.
            ctx_in, ctx_out = ctx
            prev_state =  State()
            prev_state.context = ctx_in
            new_state = self.scan_line(line, prev_state)
            new_context = new_state.context
            assert new_context == ctx_out, (
                'FAIL1:\nline: %r\ncontext: %r new_context: %r ctx_out: %r\n%s\n%s' % (
                    line, ctx_in, new_context, ctx_out, prev_state, new_state))
        else: # Test all transitions.
            for context in contexts:
                prev_state =  State()
                prev_state.context = context
                new_state = self.scan_line(line, prev_state)
                assert new_state.context == context, (
                    'FAIL2:\nline: %r\ncontext: %r new_context: %r\n%s\n%s' % (
                        line, context, new_state.context, prev_state, new_state))
</t>
<t tx="ekr.20161116034633.2">def cut_stack(self, new_state, stack, append=False):
    '''Cut back the stack until stack[-1] matches new_state.'''
    # pylint: disable=arguments-differ
    assert len(stack) &gt; 1 # Fail on entry.
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            assert len(stack) &gt; 1, stack # &lt;
            stack.pop()
        elif top_state.level() == new_state.level():
            assert len(stack) &gt; 1, stack # ==
            if append:
                pass # Append line to the previous node.
            else:
                stack.pop() # Create a new node.
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    assert len(stack) &gt; 1 # Fail on exit.
</t>
<t tx="ekr.20161116034633.7">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    assert not prev_state.in_context(), prev_state
    line = lines[i]
    top = stack[-1]
    # Adjust the stack.
    if new_state.indent &gt; top.state.indent:
        pass
    elif new_state.indent == top.state.indent:
        stack.pop()
    else:
        self.cut_stack(new_state, stack)
    # Create the child.
    top = stack[-1]
    parent = top.p
    self.gen_ref(line, parent, top)
    h = self.clean_headline(line, p=None)
    child = self.create_child_node(parent, line, h)
    self.prepend_lines(child, self.decorator_lines)
    self.decorator_lines = []
    target = PythonTarget(child, new_state)
    target.kind = 'class' if h.startswith('class') else 'def'
    stack.append(target)
</t>
<t tx="ekr.20161116040557.1">starts_pattern = re.compile(r'\s*(class|def)\s+')
    # Matches lines that apparently start a class or def.

def starts_block(self, i, lines, new_state, prev_state, stack):
    '''True if the line startswith class or def outside any context.'''
    # pylint: disable=arguments-differ
    if prev_state.in_context():
        return False
    line = lines[i]
    m = self.starts_pattern.match(line)
    if not m:
        return False
    top = stack[-1]
    prev_indent = top.state.indent
    if top.kind == 'None' and new_state.indent &gt; 0:
        # Underindented top-level class/def.
        return False
    if top.kind == 'def' and new_state.indent &gt; prev_indent:
        # class/def within a def.
        # #1493: Insert decorators.
        p = self.tail_p or top.p
        for line in self.decorator_lines:
            self.add_line(p, line)
        return False
    if top.at_others_flag and new_state.indent &gt; prev_indent:
        return False
    return True
</t>
<t tx="ekr.20161116173901.1">def end_block(self, i, lines, new_state, prev_state, stack):
    '''
    Handle a line that terminates the previous class/def. The line is
    neither a class/def line, and we are not in a multi-line token.

    Skip all lines that are at the same level as the class/def.
    '''
    # pylint: disable=arguments-differ
    top = stack[-1]
    assert new_state.indent &lt; top.state.indent, (
        '\nnew: %s\ntop: %s' % (new_state, top.state))
    assert self.skip == 0, self.skip
    end_indent = new_state.indent
    while i &lt; len(lines):
        progress = i
        self.cut_stack(new_state, stack, append=True)
        top = stack[-1]
        # Add the line.
        line = lines[i]
        self.add_line(top.p, line)
        # Move to the next line.
        i += 1
        if i &gt;= len(lines):
            break
        prev_state = new_state
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
            break
        elif not self.is_ws_line(line) and new_state.indent &lt;= end_indent:
            break
        else:
            self.skip += 1
        assert progress &lt; i, repr(line)
    return top.p
</t>
<t tx="ekr.20161119083054.1">def find_class(self, parent):
    '''
    Find the start and end of a class/def in a node.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    '''
    # Called from Leo's core to implement two minor commands.
    prev_state = Python_ScanState()
    target = Target(parent, prev_state)
    stack = [target, target]
    lines = g.splitlines(parent.b)
    index = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
                # Bug fix 2019/06/05: added "stack" arg(!)
            return self.skip_block(i, index, lines, new_state, stack)
        prev_state = new_state
        index += len(line)
    return None, -1, -1
</t>
<t tx="ekr.20161119124217.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    return new_state.level() &gt; prev_state.level()
</t>
<t tx="ekr.20161119130337.1">def cut_stack(self, new_state, stack):
    '''Cut back the stack until stack[-1] matches new_state.'''
    
    def underflow(n):
        g.trace(n)
        g.trace(new_state)
        g.printList(stack)
        
    # assert len(stack) &gt; 1 # Fail on entry.
    if len(stack) &lt;= 1:
        return underflow(0)
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            if len(stack) &gt; 1:
                stack.pop()
            else:
                return underflow(1)
        elif top_state.level() == new_state.level():
            # assert len(stack) &gt; 1, stack # ==
            # This is the only difference between i.cut_stack and python/cs.cut_stack
            if len(stack) &lt;= 1:
                return underflow(2)
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    elif len(stack) &lt;= 1:
        return underflow(3)
    return None
</t>
<t tx="ekr.20161119161953.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    self.tail_p = None
    prev_state = self.state_class()
    target = PythonTarget(parent, prev_state)
    stack = [target, target]
    self.decorator_lines = []
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    first = True
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.starts_decorator(i, lines, new_state):
            pass # Sets self.skip and self.decorator_lines.
        elif self.starts_block(i, lines, new_state, prev_state, stack):
            first = False
            self.tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif first:
            if self.is_ws_line(line):
                p = self.tail_p or top.p
                self.add_line(p, line)
            else:
                first = False
                h = 'Declarations'
                self.gen_ref(line, parent, target)
                p = self.create_child_node(parent, body=line, headline=h)
                stack.append(PythonTarget(p, new_state))
        elif self.ends_block(line, new_state, prev_state, stack):
            first = False
            self.tail_p = self.end_block(i, lines, new_state, prev_state, stack)
        else:
            p = self.tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
    if self.skip:
        g.trace('can not happen: self.skip &gt; 0', color='red')
    if self.decorator_lines:
        g.trace('can not happen: unused decorator lines...', color='red')
        g.printObj(self.decorator_lines)

</t>
<t tx="ekr.20161119162451.1">def trace_status(self, line, new_state, prev_state, stack, top):
    '''Print everything important in the i.gen_lines loop.'''
    print('')
    try:
        g.trace('===== %r' % line)
    except Exception:
        g.trace('     top.p: %s' % g.toEncodedString(top.p.h))
    # print('len(stack): %s' % len(stack))
    print(' new_state: %s' % new_state)
    print('prev_state: %s' % prev_state)
    # print(' top.state: %s' % top.state)
    g.printList(stack)
</t>
<t tx="ekr.20161120022121.1"></t>
<t tx="ekr.20161120105707.1">def nearest_roots(self, copy: bool = True, predicate: Optional[Callable] = None):
    """
    A generator yielding all the root positions "near" p1 = self that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The search first proceeds up the p's tree. If a root is found, this
    generator yields just that root.

    Otherwise, the generator yields all nodes in p.subtree() that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    def default_predicate(p):
        return p.isAnyAtFileNode()
        
    the_predicate = predicate or default_predicate

    # First, look up the tree.
    p1 = self
    for p in p1.self_and_parents(copy=False):
        if the_predicate(p):
            yield p.copy() if copy else p
            return
    # Next, look for all .md files in the tree.
    after = p1.nodeAfterTree()
    p = p1
    while p and p != after:
        if the_predicate(p):
            yield p.copy() if copy else p
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20161123210335.1">def trace_lines(self, lines1, lines2, parent):
    '''Show both s1 and s2.'''
    print('===== s1: %s' % parent.h)
    for i, s in enumerate(lines1):
        g.pr('%3s %r' % (i+1, s))
    print('===== s2')
    for i, s in enumerate(lines2):
        g.pr('%3s %r' % (i+1, s))
</t>
<t tx="ekr.20161123210716.1">def show_failure(self, lines1, lines2, sfn):
    '''Print the failing lines, with surrounding context.'''
    if not g.unitTesting:
        g.es('@auto failed:', sfn, color='red')
    n1, n2 = len(lines1), len(lines2)
    print('\n===== PERFECT IMPORT FAILED =====', sfn)
    print('len(s1): %s len(s2): %s' % (n1, n2))
    for i in range(min(n1, n2)):
        line1, line2 = lines1[i], lines2[i]
        if line1 != line2:
            print('first mismatched line: %s' % (i+1))
            print('s1...')
            print(''.join(self.context_lines(lines1, i)))
            print('s2...')
            print(''.join(self.context_lines(lines2, i)))
            # print(repr(line1))
            # print(repr(line2))
            break
    else:
        print('all common lines match')
</t>
<t tx="ekr.20161124030004.1">def clean_last_lines(self, lines):
    '''Remove blank lines from the end of lines.'''
    while lines and lines[-1].isspace():
        lines.pop()
    return lines
</t>
<t tx="ekr.20161125174423.1">def print_stack(self, stack):
    '''Print a stack of positions.'''
    g.printList([p.h for p in stack])
</t>
<t tx="ekr.20161127102339.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161128025444.1">def scan_dict(self, context, i, s, d):
    '''
    i.scan_dict: Scan at position i of s with the give context and dict.
    Return the 6-tuple: (new_context, i, delta_c, delta_p, delta_s, bs_nl)
    '''
    found = False
    delta_c = delta_p = delta_s = 0
    ch = s[i]
    aList = d.get(ch)
    if aList and context:
        # In context.
        for data in aList:
            kind, pattern, ends = data
            if self.match(s, i, pattern):
                if ends is None:
                    found = True
                    new_context = context
                    break
                elif ends:
                    found = True
                    new_context = ''
                    break
                else:
                    pass # Ignore this match.
    elif aList:
        # Not in context.
        for data in aList:
            kind, pattern, new_context, deltas = data
            if self.match(s, i, pattern):
                found = True
                if deltas:
                    delta_c, delta_p, delta_s = deltas
                break
    if found:
        if kind == 'all':
            i = len(s)
        elif kind == 'len+1':
            i += (len(pattern) + 1)
        else:
            assert kind == 'len', (kind, self.name)
            i += len(pattern)
        bs_nl = pattern == '\\\n'
        return new_context, i, delta_c, delta_p, delta_s, bs_nl
    #
    # No match: stay in present state. All deltas are zero.
    new_context = context
    return new_context, i+1, 0, 0, 0, False
</t>
<t tx="ekr.20161128025508.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, pattern, data):
        key = pattern[0]
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind      pattern  ends?
            '\\':   [('len+1', '\\',    None),],
            '"':    [('len',   '"',     context == '"'),],
            "'":    [('len',   "'",     context == "'"),],
        }
        if block1 and block2:
            add_key(d, block2, ('len', block2, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment, ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1, ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161128054630.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key   kind    pattern ends?
            '\\':   [('len+1', '\\',None),],
            '"':[
                    ('len', '"""',  context == '"""'),
                    ('len', '"',    context == '"'),
                ],
            "'":[
                    ('len', "'''",  context == "'''"),
                    ('len', "'",    context == "'"),
                ],
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block1, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\': [('len+1','\\', context, None),],
            '#':  [('all', '#',   context, None),],
            '"':[
                    # order matters.
                    ('len', '"""',  '"""', None),
                    ('len', '"',    '"',   None),
                ],
            "'":[
                    # order matters.
                    ('len', "'''",  "'''", None),
                    ('len', "'",    "'",   None),
                ],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161205052712.1">def skip_block(self, i, index, lines, prev_state, stack):
    '''
    Find the end of a class/def starting at index
    on line i of lines.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    .'''
    index1 = index
    line = lines[i]
    kind = 'class' if line.strip().startswith('class') else 'def'
    i += 1
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        index += len(line)
        new_state = self.scan_line(line, prev_state)
        if self.ends_block(line, new_state, prev_state, stack):
            return kind, index1, index
        prev_state = new_state
        i += 1
        assert progress &lt; i
    return None, -1, -1
</t>
<t tx="ekr.20161220064822.1">def gen_ref(self, line, parent, target):
    '''
    Generate the at-others and a flag telling this method whether a previous
    @others
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if not target.at_others_flag:
        target.at_others_flag = True
        ref = '%s@others\n' % indent_ws
        self.add_line(parent,ref)
    return h
</t>
<t tx="ekr.20161220073836.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    if self.is_ws_line(line) or prev_state.in_context():
        return False
    # *Any* underindented non-blank line ends the class/def.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161220171728.1">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    return self.get_str_lws(lines[0]) if lines else ''
        # We must unindent the class/def line fully.
        # It would be wrong to examine the indentation of other lines.
</t>
<t tx="ekr.20161222112801.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.children(): # 2018/05/24.
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161222122914.1">def promote_last_lines(self, parent):
    '''A placeholder for python_i.promote_last_lines.'''
</t>
<t tx="ekr.20161222123105.1">def promote_last_lines(self, parent):
    '''python_i.promote_last_lines.'''
    last = parent.lastNode()
    if not last or last.h == 'Declarations':
        return
    if last.parent() != parent:
        return # The indentation would be wrong.
    lines = self.get_lines(last)
    prev_state = self.state_class()
    if_pattern = re.compile(r'^\s*if\b')
    # Scan for a top-level if statement.
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        m = if_pattern.match(line)
        if m and not prev_state.context and new_state.indent == 0:
            self.set_lines(last, lines[:i])
            self.extend_lines(parent, lines[i:])
            break
        else:
            prev_state = new_state
</t>
<t tx="ekr.20170123074946.1">def extractExecutableString(c, p, s):
    """
    Return all lines for the given @language directive.

    Ignore all lines under control of any other @language directive.
    """
    #
    # Rewritten to fix #1071.
    if g.unitTesting:
        return s  # Regretable, but necessary.
    #
    # Return s if no @language in effect. Should never happen.
    language = g.scanForAtLanguage(c, p)
    if not language:
        return s
    #
    # Return s if @language is unambiguous.
    pattern = r'^@language\s+(\w+)'
    matches = list(re.finditer(pattern, s, re.MULTILINE))
    if len(matches) &lt; 2:
        return s
    #
    # Scan the lines, extracting only the valid lines.
    extracting, result = False, []
    for i, line in enumerate(g.splitLines(s)):
        m = re.match(pattern, line)
        if m:
            # g.trace(language, m.group(1))
            extracting = m.group(1) == language
        elif extracting:
            result.append(line)
    return ''.join(result)
</t>
<t tx="ekr.20170126100139.1">def initBlock0(self):
    """
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    """
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20170126101049.1">def setInitialStateNumber(self):
    """
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    """
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None, state + ';blank')
    return n
</t>
<t tx="ekr.20170126103925.1">def languageTag(self, name):
    """
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    """
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    return 'no-language'
</t>
<t tx="ekr.20170228082641.1">def composeScript(c, p, s, forcePythonSentinels=True, useSentinels=True):
    """Compose a script from p.b."""
    # This causes too many special cases.
        # if not g.unitTesting and forceEncoding:
            # aList = g.get_directives_dict_list(p)
            # encoding = scanAtEncodingDirectives(aList) or 'utf-8'
            # s = g.insertCodingLine(encoding,s)
    if not s.strip():
        return ''
    at = c.atFileCommands
    old_in_script = g.app.inScript
    try:
        # #1297: set inScript flags.
        g.app.inScript = g.inScript = True
        g.app.scriptDict["script1"] = s
        # Important: converts unicode to utf-8 encoded strings.
        script = at.stringToString(p.copy(), s,
            forcePythonSentinels=forcePythonSentinels,
            sentinels=useSentinels)
        script = script.replace("\r\n", "\n")  # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
        g.app.scriptDict["script2"] = script
    finally:
        g.app.inScript = g.inScript = old_in_script
    return script
</t>
<t tx="ekr.20170305105047.1">decorator_pattern = re.compile(r'^\s*@\s*(\w+)')

def starts_decorator(self, i, lines, prev_state):
    '''
    True if the line looks like a decorator outside any context.

    Puts the entire decorator into the self.decorator_lines list,
    and sets self.skip so that the next line to be handled is a class/def line.
    '''
    assert self.skip == 0
    if prev_state.context:
        # Only test for docstrings, not [{(.
        return False
    old_skip = self.skip
    old_decorator_lines = self.decorator_lines[:]
    line = lines[i]
    m = self.decorator_pattern.match(line)
    if m and m.group(1) not in g.globalDirectiveList:
        # Fix #360: allow multiline matches
        # Carefully skip all lines until a class/def.
        self.decorator_lines = [line]
        for i, line in enumerate(lines[i+1:]):
            new_state = self.scan_line(line, prev_state)
            m = self.starts_pattern.match(line)
            if m:
                # 2018/05/24: don't check in_context!
                # The class or def could start a context.
                return True
            self.decorator_lines.append(line)
            self.skip += 1
            prev_state = new_state
    # Recover froma a bare decorator, without a class or def.
    self.skip = old_skip
    self.decorator_lines = old_decorator_lines
    return False
</t>
<t tx="ekr.20170404035138.1">def context_lines(self, aList, i, n=2):
    '''Return a list containing the n lines of surrounding context of aList[i].'''
    result = []
    aList1 = aList[max(0, i-n):i]
    aList2 = aList[i+1:i+n+1]
    result.extend(['  %4s %r\n' % (i + 1 - len(aList1) + j, g.truncate(s,60))
        for j, s in enumerate(aList1)])
    result.append('* %4s %r\n' % (i + 1, g.truncate(aList[i], 60)))
    result.extend(['  %4s %r\n' % (i + 2 + j, g.truncate(s, 60))
        for j, s in enumerate(aList2)])
    return result
</t>
<t tx="ekr.20170404103953.1">def import_one_file(self, path, parent):
    """Import one file to the last top-level node."""
    c = self.c
    self.n_files += 1
    assert parent and parent.v != self.root.v, g.callers()
    if self.kind == '@edit':
        p = parent.insertAsLastChild()
        p.v.h = '@edit ' + path.replace('\\', '/')  # 2021/02/19: bug fix: add @edit.
        s, e = g.readFileIntoString(path, kind=self.kind)
        p.v.b = s
        return
    # #1484: Use this for @auto as well.
    c.importCommands.importFilesCommand(
        files=[path],
        parent=parent,
        redrawFlag=False,
        shortFn=True,
        treeType='@file',  # '@auto','@clean','@nosent' cause problems.
    )
    p = parent.lastChild()
    p.h = self.kind + p.h[5:]
        # Bug fix 2017/10/27: honor the requested kind.
    if self.safe_at_file:
        p.v.h = '@' + p.v.h
</t>
<t tx="ekr.20170404134052.1">def strip_prefix(self, path, prefix):
    """Strip the prefix from the path and return the result."""
    if path.startswith(prefix):
        return path[len(prefix) :]
    return ''  # A signal.
</t>
<t tx="ekr.20170405191106.1">def import_binary_file(self, fileName, parent):

    # Fix bug 1185409 importing binary files puts binary content in body editor.
    # Create an @url node.
    c = self.c
    if parent:
        p = parent.insertAsLastChild()
    else:
        p = c.lastTopLevel().insertAfter()
    p.h = f"@url file://{fileName}"
    return p
</t>
<t tx="ekr.20170414034616.3">def gitInfo(path=None):
    """
    Path may be a directory or file.

    Return the branch and commit number or ('', '').
    """
    branch, commit = '', ''  # Set defaults.
    if path is None:
        # Default to leo/core.
        path = os.path.dirname(__file__)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    # Does path/../ref exist?
    path = g.gitHeadPath(path)
    if not path:
        return branch, commit
    try:
        with open(path) as f:
            s = f.read()
            if not s.startswith('ref'):
                branch = 'None'
                commit = s[:7]
                return branch, commit
        # On a proper branch
        pointer = s.split()[1]
        dirs = pointer.split('/')
        branch = dirs[-1]
    except IOError:
        g.trace('can not open:', path)
        return branch, commit
    # Try to get a better commit number.
    git_dir = g.os_path_finalize_join(path, '..')
    try:
        path = g.os_path_finalize_join(git_dir, pointer)
        with open(path) as f:
            s = f.read()
        commit = s.strip()[0:12]
        # shorten the hash to a unique shortname
    except IOError:
        try:
            path = g.os_path_finalize_join(git_dir, 'packed-refs')
            with open(path) as f:
                for line in f:
                    if line.strip().endswith(' ' + pointer):
                        commit = line.split()[0][0:12]
                        break
        except IOError:
            pass
    return branch, commit
</t>
<t tx="ekr.20170414034616.6">def gitHeadPath(path):
    """
    Compute the path to .git/HEAD given the path.
    """
    path = Path(path)
    # #1780: Look up the directory tree, looking the .git directory.
    while os.path.exists(path):
        head = os.path.join(path, '.git', 'HEAD')
        if os.path.exists(head):
            return head
        if path == path.parent:
            break
        path = path.parent
    return None
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">"""Recursively import all python files in a directory and clean the result."""
g.cls()
if 0:
    import importlib
    import leo.core.leoImport as leoImport
    importlib.reload(leoImport)
# dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\black.py'
dir_ = g.os_path_finalize_join(g.app.loadDir, '..', 'modes')
assert g.os_path_exists(dir_), repr(dir_)
c.recursiveImport(
    add_context = False,
    dir_ = dir_,
    kind = '@edit', # '@clean', '@edit', '@nosent','@auto','@file',
    recursive = False,
    safe_at_file = False,
    theTypes = ['.py',]
)
</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170510100003.1">def h_return (self, ch):
    '''
    Handle the return key in the minibuffer.
    Send the contents to k.masterKeyHandler.
    '''
    c = self.leo_c
    k = c.k
    val = self.value.strip()
    self.value = ''
    self.update()
    # g.trace('===== inState: %r val: %r' % (k.inState(), val))
    commandName = val
    c.frame.tree.set_status_line(c.p)
        # This may be changed by the command.
    if k.inState():
        # Handle the key.
        k.w = self.leo_wrapper
        k.arg = val
        g.app.gui.curses_gui_arg = val
        k.masterKeyHandler(
            event=KeyEvent(c, char='\n', event='', shortcut='\n', w=None))
        g.app.gui.curses_gui_arg = None
        k.clearState()
    elif commandName == 'repeat-complex-command':
        g.app.gui.repeatComplexCommand(c)
    else:
        # All other alt-x command
        event=KeyEvent(c,char='',event='',shortcut='',w=None)
        c.doCommandByName(commandName, event)
        # Support repeat-complex-command.
        c.setComplexCommand(commandName=commandName)
        c.redraw()
    # Do a full redraw, with c.p as the first visible node.
    # g.trace('----- after command')
    g.app.gui.redraw_in_context(c)
</t>
<t tx="ekr.20170522015906.1">@frame_cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    c = self.c
    w = event and event.widget
    if not isinstance(w, leoFrame.StringTextWrapper):
        g.trace('not a StringTextWrapper', repr(w))
        return
    wname = c.widget_name(w)
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    s = g.app.gui.getTextFromClipboard()
    s = g.toUnicode(s)
    if trace: g.trace('wname', wname, 'len(s)', len(s))
    single_line = any([wname.startswith(z) for z in ('head', 'minibuffer')])
    if single_line:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[: -1]
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    if wname.startswith('body'):
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif wname.startswith('head'):
        c.frame.tree.onHeadChanged(c.p, s=w.getAllText(), undoType='Paste')
            # New for Curses gui.

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20170606100707.1">def update_body(self, ins, s):
    '''
    Update self.values and p.b and vnode ivars after the present line changes.
    '''
    # pylint: disable=no-member,access-member-before-definition
    trace = False and not g.unitTesting
    c = self.leo_c
    p = c.p
    v = p.v
    undoType = 'update-body'
    i = self.cursor_line
    wrapper = c.frame.body.wrapper
    assert isinstance(wrapper, BodyWrapper), repr(wrapper)
    lines = self.values
    if trace: g.trace(i, len(lines), s.endswith('\n'), repr(s))
    head = lines[:i]
    tail = lines[i+1:]
    if i &lt; len(lines):
        if not s.endswith('\n'):
            s = s + '\n'
        aList = head + [s] + tail
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    elif i == len(lines):
        aList = head + [s]
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    else:
        g.trace('Can not happen', i, len(lines), repr(s))
        v.selectionLength = 0
        v.selectionStart = 0
    if g.splitLines(c.p.b) != self.values:
        g.trace('self.values')
        g.printList(self.values)
        g.trace('g.splitLines(c.p.b)')
        g.printList(g.splitLines(c.p.b))
</t>
<t tx="ekr.20170616102324.1">def execGitCommand(command, directory=None):
    """Execute the given git command in the given directory."""
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir, g.callers())
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n', '')
    # #1777: Save/restore os.curdir
    old_dir = os.path.normpath(os.path.abspath(os.curdir))
    if directory:
        os.chdir(directory)
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=None,  # Shows error traces.
            shell=False,
        )
        out, err = p.communicate()
        lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    finally:
        os.chdir(old_dir)
    return lines
</t>
<t tx="ekr.20170617125213.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Important: i.gen_ref does not know p when it calls
        # self.clean_headline.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
</t>
<t tx="ekr.20170707072347.1">@cmd('beginning-of-line')
def beginningOfLine(self, event):
    """Move the cursor to the first character of the line."""
    self.moveWithinLineHelper(event, 'begin-line', extend=False)

@cmd('beginning-of-line-extend-selection')
def beginningOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to the first character of the
    line.
    """
    self.moveWithinLineHelper(event, 'begin-line', extend=True)
</t>
<t tx="ekr.20170707072524.1">@cmd('end-of-line')
def endOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=False)

@cmd('end-of-line-extend-selection')
def endOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=True)
</t>
<t tx="ekr.20170707072644.1">@cmd('start-of-line')
def startOfLine(self, event):
    """Move the cursor to first non-blank character of the line."""
    self.moveWithinLineHelper(event, 'start-line', extend=False)

@cmd('start-of-line-extend-selection')
def startOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to first non-blank character
    of the line.
    """
    self.moveWithinLineHelper(event, 'start-line', extend=True)
</t>
<t tx="ekr.20170707072837.1">@cmd('finish-of-line')
def finishOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=False)

@cmd('finish-of-line-extend-selection')
def finishOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=True)
</t>
<t tx="ekr.20170707093335.1">@cmd('pop-cursor')
def popCursor(self, event=None):
    """Restore the node, selection range and insert point from the stack."""
    c = self.c
    w = self.editWidget(event)
    if w and self.cursorStack:
        p, i, j, ins = self.cursorStack.pop()
        if c.positionExists(p):
            c.selectPosition(p)
            c.redraw()
            w.setSelectionRange(i, j, insert=ins)
            c.bodyWantsFocus()
        else:
            g.es('invalid position', c.p.h)
    elif not w:
        g.es('no stacked cursor', color='blue')

@cmd('push-cursor')
def pushCursor(self, event=None):
    """Push the selection range and insert point on the stack."""
    c = self.c
    w = self.editWidget(event)
    if w:
        p = c.p.copy()
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        self.cursorStack.append((p, i, j, ins),)
    else:
        g.es('cursor not pushed', color='blue')
</t>
<t tx="ekr.20170707160947.1">@cmd('forward-end-word')
def forwardEndWord(self, event):  # New in Leo 4.4.2
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True, end=True)

@cmd('forward-end-word-extend-selection')
def forwardEndWordExtendSelection(self, event):  # New in Leo 4.4.2
    """Extend the selection by moving the cursor to the next word."""
    self.moveWordHelper(event, extend=True, forward=True, end=True)

@cmd('forward-word')
def forwardWord(self, event):
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True)

@cmd('forward-word-extend-selection')
def forwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the next word."""
    self.moveWordHelper(event, extend=True, forward=True)

@cmd('forward-word-smart')
def forwardWordSmart(self, event):
    """Move the cursor to the end of the current or the beginning of the next word."""
    self.moveWordHelper(event, extend=False, forward=True, smart=True)

@cmd('forward-word-smart-extend-selection')
def forwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the current
    or the beginning of the next word."""
    self.moveWordHelper(event, extend=True, forward=True, smart=True)
</t>
<t tx="ekr.20170806094320.15">def get_file_from_rev(self, rev, fn):
    """Get the file from the given rev, or the working directory if None."""
    path = g.os_path_finalize_join(self.repo_dir, fn)
    if not g.os_path_exists(path):
        return ''
    if rev:
        # Get the file using git.
        # Use the file name, not the path.
        command = f"git show {rev}:{fn}"
        lines = g.execGitCommand(command, self.repo_dir)
        s = ''.join(lines)
    else:
        try:
            with open(path, 'rb') as f:  # Was 'r'
                s = f.read()
        except Exception:
            g.es_print('Can not read', path)
            g.es_exception()
            s = ''
    return g.toUnicode(s).replace('\r', '')
</t>
<t tx="ekr.20170806094320.6">def diff_file(self, fn, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for fn.
    """
    # Common code.
    c = self.c
    if not self.set_directory(directory):
        return
    path = g.os_path_finalize_join(self.repo_dir, fn)  # #1781: bug fix.
    if not os.path.exists(path):
        g.trace('NOT FOUND', path)
        return
    s1 = self.get_file_from_rev(rev1, fn)
    s2 = self.get_file_from_rev(rev2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        rev1 or 'uncommitted',
        rev2 or 'uncommitted',
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    # #1777: The file node will contain the entire added/deleted file.
    if not s1:
        self.file_node.h = f"Added: {self.file_node.h}"
        return
    if not s2:
        self.file_node.h = f"Deleted: {self.file_node.h}"
        return
    # Finish.
    c1 = c2 = None
    if fn.endswith('.leo'):
        c1 = self.make_leo_outline(fn, path, s1, rev1)
        c2 = self.make_leo_outline(fn, path, s2, rev2)
    else:
        root = self.find_file(fn)
        if c.looksLikeDerivedFile(path):
            c1 = self.make_at_file_outline(fn, s1, rev1)
            c2 = self.make_at_file_outline(fn, s2, rev2)
        elif root:
            c1 = self.make_at_clean_outline(fn, root, s1, rev1)
            c2 = self.make_at_clean_outline(fn, root, s2, rev2)
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn, rev1, rev2)
        self.file_node.b = (
            f"{self.file_node.b.rstrip()}\n"
            f"@language {c2.target_language}\n")
</t>
<t tx="ekr.20170806094320.9">def get_files(self, rev1, rev2):
    """Return a list of changed files."""
    command = f"git diff --name-only {(rev1 or '')} {(rev2 or '')}"
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if not z.strip().endswith(('.db', '.zip'))
                # #1781: Allow diffs of .leo files.
    ]
    return files
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171113164709.1">def reload_settings(self):
    """LeoFind.reload_settings."""
    c = self.c
    self.minibuffer_mode = c.config.getBool('minibuffer-find-mode', default=False)
</t>
<t tx="ekr.20171122055719.1">def declutter_style(arg, cmd):
    """Handle style options."""
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
</t>
<t tx="ekr.20171122064635.1">def declutter_replace(arg, cmd):
    """
    Execute cmd and return True if cmd is any replace command.
    """
    # pylint: disable=undefined-loop-variable
    if cmd == 'REPLACE':
        s = pattern.sub(arg, text)
        item.setText(0, s)
        return True
    if cmd == 'REPLACE-HEAD':
        s = text[: m.start()]
        item.setText(0, s.rstrip())
        return True
    if cmd == 'REPLACE-TAIL':
        s = text[m.end() :]
        item.setText(0, s.lstrip())
        return True
    if cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end() :]
        item.setText(0, s.strip())
        return True
    return False
</t>
<t tx="ekr.20171123135625.18">@g.commander_command('convert-blanks')
def convertBlanks(self, event=None):
    """
    Convert *all* blanks to tabs in the selected node.
    Return True if the the p.b was changed.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    oldYview = w.getYScrollPosition()
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = c.getBodyLines()
    #
    # Use the relative @tabwidth, not the global one.
    d = c.scanAllDirectives()
    tabWidth = d.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        s = g.optimizeLeadingWhitespace(line, abs(tabWidth))  # Use positive width.
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Select all text and set scroll position.
    w.selectAllText()
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
    return True
</t>
<t tx="ekr.20171123135625.19">@g.commander_command('convert-tabs')
def convertTabs(self, event=None):
    """Convert all tabs to blanks in the selected node."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Data...
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    # Use the relative @tabwidth, not the global one.
    theDict = c.scanAllDirectives()
    tabWidth = theDict.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed,result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tabWidth)
        s = g.computeLeadingWhitespace(width, -abs(tabWidth)) + line[i:]
            # use negative width.
        if s != line: changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
    return True
</t>
<t tx="ekr.20171123135625.21">@g.commander_command('unindent-region')
def dedentBody(self, event=None):
    """Remove one tab's worth of indentation from all presently selected lines."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(c.p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    bunch = u.beforeChangeBody(p)
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width - abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        ins, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + ins
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'): # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    u.afterChangeBody(p, 'Unindent Region', bunch)
</t>
<t tx="ekr.20171123135625.29">def getBodyLines(self):
    """
    Return (head, lines, tail, oldSel, oldYview).

    - head: string containg all the lines before the selected text (or the
      text before the insert point if no selection)
    - lines: list of lines containing the selected text
      (or the line containing the insert point if no selection)
    - after: string containing all lines after the selected text
      (or the text after the insert point if no  selection)
    - oldSel: tuple containing the old selection range, or None.
    - oldYview: int containing the old y-scroll value, or None.
    """
    c = self
    body = c.frame.body
    w = body.wrapper
    oldVview = w.getYScrollPosition()
    # Note: lines is the entire line containing the insert point if no selection.
    head, s, tail = body.getSelectionLines()
    lines = g.splitLines(s)  # Retain the newlines of each line.
    # Expand the selection.
    i = len(head)
    j = len(head) + len(s)
    oldSel = i, j
    return head, lines, tail, oldSel, oldVview  # string,list,string,tuple,int.
</t>
<t tx="ekr.20171123135625.30">@g.commander_command('always-indent-region')
def alwaysIndentBody(self, event=None):
    """
    The always-indent-region command indents each line of the selected body
    text. The @tabwidth directive in effect determines amount of
    indentation.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # #1801: Don't rely on bindings to ensure that we are editing the body.
    event_w = event and event.w
    if event_w != w:
        c.insertCharFromEvent(event)
        return
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width + abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + i
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'):  # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)

</t>
<t tx="ekr.20171123135625.34">@g.commander_command('add-comments')
def addComments(self, event=None):
    &lt;&lt; addComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Make sure there is a selection.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    #
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    d2 = d2 or ''; d3 = d3 or ''
    if d1:
        openDelim, closeDelim = d1 + ' ', ''
    else:
        openDelim, closeDelim = d2 + ' ', ' ' + d3
    #
    # Calculate the result.
    indent = c.config.getBool('indent-added-comments', default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line, 0)
            if indent:
                s = line[i:].replace('\n', '')
                result.append(line[0:i] + openDelim + s + closeDelim + '\n')
            else:
                s = line.replace('\n', '')
                result.append(openDelim + s + closeDelim + '\n')
        else:
            result.append(line)
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
</t>
<t tx="ekr.20171123135625.35">@pagewidth 50
"""
Converts all selected lines to comment lines using
the comment delimiters given by the applicable @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

@bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
"""
</t>
<t tx="ekr.20171123135625.36">@g.commander_command('delete-comments')
def deleteComments(self, event=None):
    &lt;&lt; deleteComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    #
    # Calculate the result.
    changed, result = False, []
    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1, n1b = len(d1), len(d1b)
        for s in lines:
            i = g.skip_ws(s, 0)
            if g.match(s, i, d1b):
                result.append(s[:i] + s[i + n1b :])
                changed = True
            elif g.match(s, i, d1):
                result.append(s[:i] + s[i + n1 :])
                changed = True
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2, n3 = len(d2), len(d3)
        for s in lines:
            i = g.skip_ws(s, 0)
            j = s.find(d3, i + n2)
            if g.match(s, i, d2) and j &gt; -1:
                first = i + n2
                if g.match(s, first, ' '):
                    first += 1
                last = j
                if g.match(s, last - 1, ' '):
                    last -= 1
                result.append(s[:i] + s[first:last] + s[j + n3 :])
                changed = True
            else:
                result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Set the selection range and scroll position.
    i = len(head)
    j = ins = max(i, len(head) + len(middle) - 1)
    w.setSelectionRange(i, j, insert=ins)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
</t>
<t tx="ekr.20171123135625.37">@pagewidth 50
"""
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
"""
</t>
<t tx="ekr.20171123135625.38">@g.commander_command('insert-body-time')
def insertBodyTime(self, event=None):
    """Insert a time/date stamp at the cursor."""
    c = self; undoType = 'Insert Body Time'
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20171123135625.4">@cmd('execute-script')
def executeScript(self, event=None,
    args=None, p=None, script=None, useSelectedText=True,
    define_g=True, define_name='__main__',
    silent=False, namespace=None, raiseFlag=False,
    runPyflakes=True,
):
    """
    Execute a *Leo* script.
    Keyword args:
    args=None               Not None: set script_args in the execution environment.
    p=None                  Get the script from p.b, unless script is given.
    script=None             None: use script in p.b or c.p.b
    useSelectedText=True    False: use all the text in p.b or c.p.b.
    define_g=True           True: define g for the script.
    define_name='__main__'  Not None: define the name symbol.
    silent=False            No longer used.
    namespace=None          Not None: execute the script in this namespace.
    raiseFlag=False         True: reraise any exceptions.
    runPyflakes=True        True: run pyflakes if allowed by setting.
    """
    c, script1 = self, script
    if runPyflakes:
        run_pyflakes = c.config.getBool('run-pyflakes-on-write', default=False)
    else:
        run_pyflakes = False
    if not script:
        if c.forceExecuteEntireBody:
            useSelectedText = False
        script = g.getScript(c, p or c.p, useSelectedText=useSelectedText)
    script_p = p or c.p
        # Only for error reporting below.
    # #532: check all scripts with pyflakes.
    if run_pyflakes and not g.unitTesting:
        from leo.commands import checkerCommands as cc
        # at = c.atFileCommands
        prefix = ('c,g,p,script_gnx=None,None,None,None;'
                  'assert c and g and p and script_gnx;\n')
        cc.PyflakesCommand(c).check_script(script_p, prefix + script)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0, '.')  # New in Leo 5.0
            sys.path.insert(0, c.frame.openDirectory)  # per SegundoBob
            script += '\n'  # Make sure we end the script properly.
            try:
                if not namespace or namespace.get('script_gnx') is None:
                    namespace = namespace or {}
                    namespace.update(script_gnx=script_p.gnx)
                # We *always* execute the script with p = c.p.
                c.executeScriptHelper(args, define_g, define_name, namespace, script)
            except KeyboardInterrupt:
                g.es('interrupted')
            except Exception:
                if raiseFlag:
                    raise
                g.handleScriptException(c, script_p, script, script1)
            finally:
                del sys.path[0]
                del sys.path[0]
        else:
            tabName = log and hasattr(log, 'tabName') and log.tabName or 'Log'
            g.warning("no script selected", tabName=tabName)
    finally:
        g.app.log = oldLog
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20171123135625.47">def rp_reformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """Reformat the body and update the selection."""
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    s = head + result + tail
    changed = original != s
    bunch = u.beforeChangeBody(p)
    if changed:
        w.setAllText(s)  # Destroys coloring.
    #
    # #1748: Always advance to the next paragraph.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    ins = j + 1
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # It's annoying, imo, to treat @ lines differently.
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    ins = min(ins, len(s))
    w.setSelectionRange(ins, ins, insert=ins)
    #
    # Show more lines, if they exist.
    k = g.see_more_lines(s, ins, 4)
    p.v.insertSpot = ins
    w.see(k)  # New in 6.4. w.see works!
    if not changed:
        return
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20171123135625.5">def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
</t>
<t tx="ekr.20171123135625.50">def unreformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """unformat the body and update the selection."""
    body, w = c.frame.body, c.frame.body.wrapper
    s = head + result + tail
    ins = max(len(head), len(head) + len(result) - 1)
    w.setAllText(s)  # Destroys coloring.
    changed = original != s
    if changed:
        body.onBodyChanged(undoType, oldSel=oldSel)
    # Advance to the next paragraph.
    ins += 1  # Move past the selection.
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    c.recolor()  # Required.
    w.setSelectionRange(ins, ins, insert=ins)
    # More useful than for reformat-paragraph.
    w.see(ins)
    # Make sure we never scroll horizontally.
    w.setXScrollPosition(0)
</t>
<t tx="ekr.20171123135625.6">def redirectScriptOutput(self):
    c = self
    if c.config.redirect_execute_script_output_to_log_pane:
        g.redirectStdout()  # Redirect stdout
        g.redirectStderr()  # Redirect stderr
</t>
<t tx="ekr.20171123135625.7">def setCurrentDirectoryFromContext(self, p):
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    curDir = g.os_path_abspath(os.getcwd())
    if path and path != curDir:
        try:
            os.chdir(path)
        except Exception:
            pass
</t>
<t tx="ekr.20171123135625.8">def unredirectScriptOutput(self):
    c = self
    if c.exists and c.config.redirect_execute_script_output_to_log_pane:
        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20171123201514.1"></t>
<t tx="ekr.20171124043747.1">def registerCommandShortcut(self, commandName, func, pane, shortcut):
    """
    Register a shortcut for the a command.
    
    **Important**: Bindings created here from plugins can not be overridden.
    This includes @command and @button bindings created by mod_scripting.py.
    """
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    assert not g.isStroke(shortcut)
    if shortcut:
        stroke = g.KeyStroke(binding=shortcut) if shortcut else None
    elif commandName.lower() == 'shortcut':  # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for bi in aList:
            if bi.stroke and not bi.pane.endswith('-mode'):
                stroke = bi.stroke
                pane = bi.pane  # 2015/05/11.
                break
    if stroke:
        k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke)  # Must be a stroke.
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20171129205648.1">def compute_find_options(self):  # pragma: no cover (cmd)
    """Return the status line as two strings."""
    z = []
    # Set the scope field.
    head = self.search_headline
    body = self.search_body
    if self.suboutline_only:
        scope = 'tree'
    elif self.node_only:
        scope = 'node'
    else:
        scope = 'all'
    # scope = self.getOption('radio-search-scope')
    # d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    # scope = d.get(scope) or ''
    head = 'head' if head else ''
    body = 'body' if body else ''
    sep = '+' if head and body else ''
    part1 = f"{head}{sep}{body} {scope}  "
    # Set the type field.
    regex = self.pattern_match
    if regex: z.append('regex')
    table = (
        ('reverse', 'reverse'),
        ('ignore_case', 'noCase'),
        ('whole_word', 'word'),
        # ('wrap', 'wrap'),
        ('mark_changes', 'markChg'),
        ('mark_finds', 'markFnd'),
    )
    for ivar, s in table:
        val = getattr(self, ivar)
        if val: z.append(s)
    part2 = ' '.join(z)
    return part1, part2
</t>
<t tx="ekr.20171129211238.1">def compute_find_options_in_status_area(self):
    c = self.c
    ftm = c.findCommands.ftm
    table = (
        ('Word', ftm.check_box_whole_word),
        ('Ig-case', ftm.check_box_ignore_case),
        ('regeXp', ftm.check_box_regexp),
        ('Body', ftm.check_box_search_body),
        ('Head', ftm.check_box_search_headline),
        # ('wrap-Around', ftm.check_box_wrap_around),
        ('mark-Changes', ftm.check_box_mark_changes),
        ('mark-Finds', ftm.check_box_mark_finds),
    )
    result = [option for option, ivar in table if ivar.checkState()]
    table2 = (
        ('Suboutline', ftm.radio_button_suboutline_only),
        ('Node', ftm.radio_button_node_only),
    )
    for option, ivar in table2:
        if ivar.isChecked():
            result.append(f"[{option}]")
            break
    return f"Find: {' '.join(result)}"
</t>
<t tx="ekr.20171226140643.1">@cmd('find-all-unique-regex')
def interactive_find_all_unique_regex(
    self, event=None):  # pragma: no cover (interactive)
    """
    Create a summary node containing all unique matches of the regex search
    string. This command shows only the matched string itself.
    """
    self.ftm.clear_focus()
    self.match_obj = None
    self.changeAllFlag = False
    self.findAllUniqueFlag = True
    self.ftm.set_entry_focus()
    self.start_state_machine(event,
        prefix='Search Unique Regex: ',
        handler=self.interactive_find_all_unique_regex1,
        escape_handler=self.interactive_change_all_unique_regex1,
    )

def interactive_find_all_unique_regex1(
    self, event=None):  # pragma: no cover (interactive)
    k = self.k
    # Settings...
    find_pattern = k.arg
    self.update_find_list(find_pattern)
    self.ftm.set_find_text(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    return self.do_find_all(settings)

def interactive_change_all_unique_regex1(
    self, event):  # pragma: no cover (interactive)
    k = self.k
    find_pattern = self._sString = k.arg
    self.update_find_list(k.arg)
    s = f"'Replace All Unique Regex': {find_pattern} With: "
    k.setLabelBlue(s)
    self.add_change_string_to_label()
    k.getNextArg(self.interactive_change_all_unique_regex2)

def interactive_change_all_unique_regex2(
    self, event):  # pragma: no cover (interactive)
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    find_pattern = self._sString
    change_pattern = k.arg
    self.update_change_list(change_pattern)
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_change_all(settings)
</t>
<t tx="ekr.20171226143621.1">def _create_find_unique_node(self):
    """Create a "Found Unique" node as the last node of the outline."""
    c = self.c
    found = c.lastTopLevel().insertAfter()
    assert found
    found.h = f"Found Unique Regex:{self.find_text}"
    result = sorted(self.unique_matches)
    found.b = '\n'.join(result)
    return found
</t>
<t tx="ekr.20180210092235.1">def backup_helper(self,
    base_dir=None,
    env_key='LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=True,
):
    """
    A helper for scripts that back up a .leo file.
    Use os.environ[env_key] as the base_dir only if base_dir is not given.
    Backup to base_dir or join(base_dir, sub_dir).
    """
    c = self
    old_cwd = os.getcwd()
    join = g.os_path_finalize_join
    if not base_dir:
        if env_key:
            try:
                base_dir = os.environ[env_key]
            except KeyError:
                print(f"No environment var: {env_key}")
                base_dir = None
    if base_dir and g.os_path_exists(base_dir):
        if use_git_prefix:
            git_branch, junk = g.gitInfo()
        else:
            git_branch = None
        theDir, fn = g.os_path_split(c.fileName())
        backup_dir = join(base_dir, sub_dir) if sub_dir else base_dir
        path = join(backup_dir, fn)
        if g.os_path_exists(backup_dir):
            written_fn = c.backup(
                path,
                prefix=git_branch,
                silent=True,
                useTimeStamp=True,
            )
            g.es_print(f"wrote: {written_fn}")
        else:
            g.es_print(f"backup_dir not found: {backup_dir!r}")
    else:
        g.es_print(f"base_dir not found: {base_dir!r}")
    os.chdir(old_cwd)
</t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180312150559.1">@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@&lt;file&gt; type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
</t>
<t tx="ekr.20180312150805.1">def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
</t>
<t tx="ekr.20180312151544.1">def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
</t>
<t tx="ekr.20180312152329.1">def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
</t>
<t tx="ekr.20180312152609.1">def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
</t>
<t tx="ekr.20180312153008.1">def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
</t>
<t tx="ekr.20180312154839.1">def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
</t>
<t tx="ekr.20180318133620.1">def computeThemeFilePath(self):
    """
    Return the absolute path to the theme .leo file, resolved using the search order for themes.
    
    1. Use the --theme command-line option if it exists.
    
    2. Otherwise, preload the first .leo file.
       Load the file given by @string theme-name setting.
       
    3. Finally, look up the @string theme-name in the already-loaded, myLeoSettings.leo.
       Load the file if setting exists.  Otherwise return None.
    """
    trace = 'themes' in g.app.db
    lm = self
    resolve = self.resolve_theme_path
    #
    # Step 1: Use the --theme command-line options if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path:
        # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
        if trace: g.trace('--theme:', path)
        return path
    #
    # Step 2: look for the @string theme-name setting in the first loaded file.
    path = lm.files and lm.files[0]
    if path and g.os_path_exists(path):
        # Tricky: we must call lm.computeLocalSettings *here*.
        theme_c = lm.openSettingsFile(path)
        if theme_c:
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                bindings_d=lm.globalBindingsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path:
                    # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
                    if trace: g.trace(f"First loaded file", theme_c.shortFileName(), path)
                    return path
    #
    # Step 3: use the @string theme-name setting in myLeoSettings.leo.
    # Note: the setting should *never* appear in leoSettings.leo!
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    path = resolve(setting, tag=tag)
    if trace: g.trace(f"myLeoSettings.leo", path)
    return path
</t>
<t tx="ekr.20180321124503.1">def resolve_theme_path(self, fn, tag):
    """Search theme directories for the given .leo file."""
    if not fn or fn.lower().strip() == 'none':
        return None
    if not fn.endswith('.leo'):
        fn += '.leo'
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)
            # Normalizes slashes, etc.
        if g.os_path_exists(path):
            return path
    print(f"theme .leo file not found: {fn}")
    return None
</t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180410074238.1">def insert_toc(c, kind):
    """Insert a table of contents at the cursor."""
    undoType = f"Insert {kind.capitalize()} TOC"
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = make_toc(c, kind=kind, root=c.p)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20180413180751.2">def doNonKeyEvent(self, event, obj):
    """Handle all non-key event. """
    c = self.c
    ev = QtCore.QEvent
    eventType = event.type()
    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event, c, obj, self.tag)
    elif eventType == ev.WindowDeactivate:
        g.app.gui.onDeactivateEvent(event, c, obj, self.tag)
    elif eventType == ev.FocusIn:
        if self.tag == 'body':
            c.frame.body.onFocusIn(obj)
        if c.frame and c.frame.top and obj is c.frame.top.lineEdit:
            if c.k.getStateKind() == 'getArg':
                c.frame.top.lineEdit.restore_selection()
    elif eventType == ev.FocusOut and self.tag == 'body':
        c.frame.body.onFocusOut(obj)
    return eventType not in (ev.ShortcutOverride, ev.KeyPress, ev.KeyRelease)
        # Return True unless we have a key event.
</t>
<t tx="ekr.20180413180751.3">def shouldIgnoreKeyEvent(self, event, obj):
    """
    Return True if we should ignore the key event.
    
    Alas, QLineEdit *only* generates ev.KeyRelease on Windows, Ubuntu,
    so the following hack is required.
    """
    c = self.c
    ev = QtCore.QEvent
    t = event.type()
    isEditWidget = (obj == c.frame.tree.edit_widget(c.p))
    if isEditWidget:
        return t != ev.KeyRelease
            # QLineEdit: ignore all key events except keyRelease events.
    if t == ev.KeyPress:
        return False  # Never ignore KeyPress events.
    # This doesn't work. Two shortcut-override events are generated!
        # if t == ev.ShortcutOverride and event.text():
            # return False # Don't ignore shortcut overrides with a real value.
    return True  # Ignore everything else.
</t>
<t tx="ekr.20180417161548.1">def doLateTweaks(self, binding, ch):
    """Make final tweaks. g.KeyStroke does other tweaks later."""
    #
    # These are needed  because ch is separate from binding.
    if ch == '\r':
        ch = '\n'
    if binding == 'Escape':
        ch = 'Escape'
    #
    # Adjust the case of the binding string (for the minibuffer).
    if len(ch) == 1 and len(binding) == 1 and ch.isalpha() and binding.isalpha():
        if ch != binding:
            binding = ch
    return binding, ch
</t>
<t tx="ekr.20180418023827.1">def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
</t>
<t tx="ekr.20180418024449.1">def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
</t>
<t tx="ekr.20180418025241.1">def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c = self.c
    if c.vim_mode and c.vimCommands:
        # The "acceptance methods" in leoVim.py return True
        # if vim node has completely handled the key.
        # Otherwise, processing in k.masterKeyHandler continues.
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('do_key returns', ok, repr(event and event.stroke))
        return ok
    return False
</t>
<t tx="ekr.20180418031118.1">def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) &gt; 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
</t>
<t tx="ekr.20180418031417.1">def traceVars(self, event):

    trace = False and not g.unitTesting
    if not trace:
        return
    k = self
    char = event.char
    state = k.state.kind
    stroke = event.stroke
    g.trace(
        f"stroke: {stroke!r}, "
        f"char: {char!r}, "
        f"state: {state}, "
        f"state2: {k.unboundKeyAction}")
</t>
<t tx="ekr.20180418033838.1">def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    trace = 'keys' in g.app.debug
    c, k = self.c, self
    #
    # Experimental special case:
    # Inserting a '.' always invokes the auto-completer.
    # The auto-completer just inserts a '.' if it isn't enabled.
    stroke = event.stroke
    if (
        stroke.s == '.'
        and k.isPlainKey(stroke)
        and self.unboundKeyAction in ('insert', 'overwrite')
    ):
        c.doCommandByName('auto-complete', event)
        return True
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event)
    #
    # #327: Ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        # A superb trace. !s gives shorter trace.
        if trace: g.trace(f"{event.stroke!s} {bi.commandName}")
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20180418034305.1">def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
</t>
<t tx="ekr.20180418040158.1">def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
</t>
<t tx="ekr.20180418105228.1">def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    # trace = 'keys' in g.app.debug and 'verbose' in g.app.debug
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
</t>
<t tx="ekr.20180418114300.1">def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
</t>
<t tx="ekr.20180419154543.1">def doAltTweaks(self, actual_ch, keynum, mods, toString):
    """Turn AltGr and some Alt-Ctrl keys into plain keys."""
    qt = QtCore.Qt

    def removeAltCtrl(mods):
        for mod in ('Alt', 'Control'):
            if mod in mods:
                mods.remove(mod)
        return mods

    #
    # Remove Alt, Ctrl for AltGr keys.
    # See https://en.wikipedia.org/wiki/AltGr_key

    if keynum == qt.Key_AltGr:
        return removeAltCtrl(mods)
    #
    # Never alter complex characters.
    if len(actual_ch) != 1:
        return mods
    #
    # #1563: A hack for German keyboards:
    #        Remove *plain* Shift modifier for colon and semicolon.
    #        https://en.m.wikipedia.org/wiki/German_keyboard_layout
    if (
        self.use_german_keyboard
        and actual_ch in ":;" and 'Shift' in mods
        and 'Alt' not in mods and 'Control' not in mods
    ):
        mods.remove('Shift')
        # g.trace('mods', mods, 'ch', repr(actual_ch))
    #
    # Handle Alt-Ctrl modifiers for chars whose that are not ascii.
    # Testing: Alt-Ctrl-E is '€'.
    if ord(actual_ch) &gt; 127 and 'Alt' in mods and 'Control' in mods:
        return removeAltCtrl(mods)
    return mods
</t>
<t tx="ekr.20180419160958.1">def doMacTweaks(self, actual_ch, ch, mods):
    """Replace MacOS Alt characters."""
    if not g.isMac:
        return actual_ch, ch, mods
    if ch == 'Backspace':
        # On the Mac, the reported char can be DEL (7F)
        return '\b', ch, mods
    if len(mods) == 1 and mods[0] == 'Alt':
        # Patch provided by resi147.
        # See the thread: special characters in MacOSX, like '@'.
        mac_d = {
            '/': '\\',
            '5': '[',
            '6': ']',
            '7': '|',
            '8': '{',
            '9': '}',
            'e': '€',
            'l': '@',
        }
        if ch.lower() in mac_d:
            # Ignore the case.
            actual_ch = ch = g.checkUnicode(mac_d.get(ch.lower()))
            mods = []
    return actual_ch, ch, mods
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180507212821.1">def diff_two_revs(self, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    c = self.c
    if not self.set_directory(directory):
        return
    # Get list of changed files.
    files = self.get_files(rev1, rev2)
    n = len(files)
    message = f"diffing {n} file{g.plural(n)}"
    if n &gt; 5:
        message += ". This may take awhile..."
    g.es_print(message)
    # Create the root node.
    self.root = c.lastTopLevel().insertAfter()
    self.root.h = f"git diff revs: {rev1} {rev2}"
    self.root.b = '@ignore\n@nosearch\n'
    # Create diffs of all files.
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
    self.finish()
</t>
<t tx="ekr.20180511045458.1">def _switch_style(self, word):
    """
    Switch between camelCase and underscore_style function defintiions.
    Return None if there would be no change.
    """
    s = word
    if not s:
        return None
    if s[0].isupper():
        return None  # Don't convert class names.
    if s.find('_') &gt; -1:
        # Convert to CamelCase
        s = s.lower()
        while s:
            i = s.find('_')
            if i == -1:
                break
            s = s[:i] + s[i + 1 :].capitalize()
        return s
    # Convert to underscore_style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    s = ''.join(result)
    return None if s == word else s
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    if row &gt;= len(lines):  # 2020/11/27
        return []
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180524100258.1">def add_class_names(self, p):
    """Add class names to headlines for all descendant nodes."""
    # pylint: disable=no-else-continue
    after, class_name = None, None
    class_paren_pattern = re.compile(r'(.*)\(.*\)\.(.*)')
    paren_pattern = re.compile(r'(.*)\(.*\.py\)')
    for p in p.self_and_subtree(copy=False):
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            # prefix = m.group(1)
            # fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        elif p.h.startswith('@path '):
            after, class_name = None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if p.h.startswith(class_name):
                m = class_paren_pattern.match(p.h)
                if m:
                    p.h = f"{m.group(1)}.{m.group(2)}".rstrip()
            else:
                p.h = f"{class_name}.{p.h}"
        else:
            m = paren_pattern.match(p.h)
            if m:
                p.h = m.group(1).rstrip()
        # elif fn:
            # tag = ' (%s)' % fn
            # if not p.h.endswith(tag):
                # p.h += tag
</t>
<t tx="ekr.20180524130023.1">file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    # Note: this method is never called for @clean trees.

def add_class_names(self, p):
    '''
    Add class names to headlines for all descendant nodes.

    Called only when @bool add-context-to-headlines is True.
    '''
    if g.app.unitTesting:
        return # Don't changes the expected headlines.
    after, fn, class_name = None, None, None
    for p in p.self_and_subtree():
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            prefix = m.group(1)
            fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        if p.h.startswith('@path '):
            after, fn, class_name = None, None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if not p.h.startswith(class_name):
                p.h = '%s.%s' % (class_name, p.h)
        elif fn and self.add_file_context:
            tag = ' (%s)' % fn
            if not p.h.endswith(tag):
                p.h += tag
</t>
<t tx="ekr.20180524173510.1"></t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180602062323.7"># #1510: https://en.wikipedia.org/wiki/Valid_characters_in_XML.
translate_table = {z: None for z in range(20) if chr(z) not in '\t\r\n'}

def readWithElementTree(self, path, s):

    contents = g.toUnicode(s)
    contents = contents.translate(self.translate_table)
        # Fix #1036 and #1046.
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        # #970: Just report failure here.
        if path:
            message = f"bad .leo file: {g.shortFileName(path)}"
        else:
            message = 'The clipboard is not a vaild .leo file'
        g.es_print('\n' + message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        # #1510: Return a tuple.
        return None, None
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.handleBits()
    return hidden_v, g_element
</t>
<t tx="ekr.20180602062323.8">def scanTnodes(self, t_elements):

    gnx2body, gnx2ua = {}, defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body[gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                gnx2ua[gnx][key] = self.resolveUa(key, val)
    return gnx2body, gnx2ua
</t>
<t tx="ekr.20180602062323.9">def scanVnodes(self, gnx2body, gnx2vnode, gnx2ua, v_elements):

    c, fc = self.c, self.c.fileCommands
    &lt;&lt; define v_element_visitor &gt;&gt;
    #
    # Create the hidden root vnode.

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '&lt;hidden root vnode&gt;'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
</t>
<t tx="ekr.20180604110143.1">def readFile(self, theFile, path):
    """Read the file, change splitter ratiors, and return its hidden vnode."""
    s = theFile.read()
    v, g_element = self.readWithElementTree(path, s)
    if not v:  # #1510.
        return None
    self.scanGlobals(g_element)
        # Fix #1047: only this method changes splitter sizes.
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v

def readFileFromClipboard(self, s):
    """
    Recreate a file from a string s, and return its hidden vnode.
    
    Unlike readFile above, this does not affect splitter sizes.
    """
    v, g_element = self.readWithElementTree(path=None, s=s)
    if not v:  # #1510.
        return None
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v
</t>
<t tx="ekr.20180605062300.1">def scanGlobals(self, g_element):
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20180605075042.1">v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
</t>
<t tx="ekr.20180605075113.1"># Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
</t>
<t tx="ekr.20180605102822.1">def v_element_visitor(parent_e, parent_v):
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            &lt;&lt; Make a new vnode, linked to the parent &gt;&gt;
            &lt;&lt; handle all other v attributes &gt;&gt;
            # Handle all inner elements.
            v_element_visitor(e, v)

</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606041211.1">def resolveUa(self, attr, val, kind=None):  # Kind is for unit testing.
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if isinstance(val, (str, bytes)):
            return g.toUnicode(val)
    try:
        binString = binascii.unhexlify(val)
            # Throws a TypeError if val is not a hex string.
    except Exception:
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', f"unit test failed: kind={kind}"
        else:
            g.trace(f"can not unhexlify {attr}={val}")
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        return val2
    except Exception:
        try:
            val2 = pickle.loads(binString, encoding='bytes')
            val2 = self.bytesToUnicode(val2)
            return val2
        except Exception:
            g.trace(f"can not unpickle {attr}={val}")
            return val
</t>
<t tx="ekr.20180606044154.1">def bytesToUnicode(self, ob):
    """
    Recursively convert bytes objects in strings / lists / dicts to str
    objects, thanks to TNT
    http://stackoverflow.com/questions/22840092
    Needed for reading Python 2.7 pickles in Python 3.4.
    """
    # This is simpler than using isinstance.
    # pylint: disable=unidiomatic-typecheck
    t = type(ob)
    if t in (list, tuple):
        l = [str(i, 'utf-8') if type(i) is bytes else i for i in ob]
        l = [self.bytesToUnicode(i)
                if type(i) in (list, tuple, dict) else i
                    for i in l]
        ro = tuple(l) if t is tuple else l
    elif t is dict:
        byte_keys = [i for i in ob if type(i) is bytes]
        for bk in byte_keys:
            v = ob[bk]
            del(ob[bk])
            ob[str(bk, 'utf-8')] = v
        for k in ob:
            if type(ob[k]) is bytes:
                ob[k] = str(ob[k], 'utf-8')
            elif type(ob[k]) in (list, tuple, dict):
                ob[k] = self.bytesToUnicode(ob[k])
        ro = ob
    elif t is bytes:  # TNB added this clause
        ro = str(ob, 'utf-8')
    else:
        ro = ob
    return ro
</t>
<t tx="ekr.20180624125321.1">def handleBits(self):
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
</t>
<t tx="ekr.20180708060437.1">def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180806045802.1">def doSmartQuote(self, action, ch, oldSel, w):
    """Convert a straight quote to a curly quote, depending on context."""
    i, j = oldSel
    if i &gt; j:
        i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j:
        w.delete(i, j)
    elif action == 'overwrite':
        w.delete(i)
    ins = w.getInsertPoint()
    # Pick the correct curly quote.
    s = w.getAllText() or ""
    i2 = g.skip_to_start_of_line(s, max(0, ins - 1))
    open_curly = ins == i2 or ins &gt; i2 and s[ins - 1] in ' \t'
        # not s[ins-1].isalnum()
    if open_curly:
        ch = '‘' if ch == "'" else "“"
    else:
        ch = '’' if ch == "'" else "”"
    w.insert(ins, ch)
    w.setInsertPoint(ins + 1)
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1 and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180810052056.3">def slowYieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    while p:
        yield p
        if p == target_p:
            return
        p.moveToVisNext(c)
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import os
import leo.commands.editFileCommands as efc

path = os.path.join(g.app.loadDir, '..', '..')
os.chdir(path)

efc.GitDiffController(c).diff_two_branches(
    branch1='master', # '6bd282f', # 'bc24e607a5', # old branch/rev
    branch2='devel', # new branch/rev
    fn='leo/core/leoTangle.py',
    directory=None,
)
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20180826065640.1">def embed_pyplot_widget(self):

    pc = self
    c = pc.c
    # Careful: we may be unit testing.
    splitter = c.free_layout.get_top_splitter()
    if not splitter:
        return
    if not pc.pyplot_canvas:

        # TODO Create the widgets.
        w = None
        ### Ref
        # pc.gs = QtWidgets.QGraphicsScene(splitter)
        # pc.gv = QtWidgets.QGraphicsView(pc.gs)
        # w = pc.gv.viewport() # A QWidget
        # Embed the widgets.
        pc.pyplot_canvas = w

        def delete_callback():
            pc.pyplot_canvas.deleteLater()
            pc.pyplot_canvas = None

    if pc.pyplot_canvas:
        pc.embed_widget(w, delete_callback=delete_callback)
</t>
<t tx="ekr.20181009072707.1"># -*- coding: utf-8 -*-
import os
import sys
import unittest
from leo.core import leoBridge

load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    tm = c.testManager
    g.unitTesting = g.app.unitTesting = True
    suite = unittest.makeSuite(unittest.TestCase)
    aList = tm.findAllUnitTestNodes(all=False, marked=False)
    setup_script = None
    found = False
    for p in aList:
        if tm.isTestSetupNode(p):
            setup_script = p.b
            test = None
        elif tm.isTestNode(p):
            test = tm.makeTestCase(p, setup_script)
        elif tm.isSuiteNode(p):
            test = tm.makeTestSuite(p, setup_script)
        elif tm.isTestClassNode(p):
            test = tm.makeTestClass(p)
        else:
            test = None
        if test:
            suite.addTest(test)
            found = True
    if not found:
        print('No unit tests')
        sys.exit(1)
    runner = unittest.TextTestRunner(failfast=True, verbosity=1)
    try:
        result = runner.run(suite)
        if result.errors or result.failures:
            print(f"errors: {len(result.errors)}, failures: {len(result.failures)}")
            sys.exit(1)
        else:
            print('Travis unit tests all passed.')
            sys.exit(0)
    except Exception:
        print('Unexpected exception')
        g.es_exception()
        sys.exit(1)
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20181118052203.1">def redraw(self, p=None):
    '''This is c.frame.tree.redraw!'''
    if 0: print(self.tag, '(c.frame.tree) redraw')
    self.root.redraw(p)
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190326183005.1">def reloadSettings(self):
    """Complete the initialization of all settings."""
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('jedit.reloadSettings.')
    # Do the basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
</t>
<t tx="ekr.20190402091335.1">from leo.commands import editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='51715f5', # Before, the *original* base of ekr-theme.
    rev2='HEAD',    # After: Latest ekr-theme (or devel) commit.
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406193429.1"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
from leo.core import leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190505173053.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
</t>
<t tx="ekr.20190506055928.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
</t>
<t tx="ekr.20190506060857.1"></t>
<t tx="ekr.20190506061636.1"></t>
<t tx="ekr.20190510060918.1">@cmd('print-sep')
def printSep(self, event=None):
    """Print a separator"""
    print('\n==========\n')
</t>
<t tx="ekr.20190602134414.1">def _change_all_search_and_replace(self, s):
    """
    Search s for self.find_text and replace with self.change_text.
    
    Return (found, new text)
    """
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:
        return False, None
    #
    # Order matters: regex matches ignore whole-word.
    if self.pattern_match:
        return self._change_all_regex(s)
    if self.whole_word:
        return self._change_all_word(s)
    return self._change_all_plain(s)
</t>
<t tx="ekr.20190602151043.2">def _change_all_regex(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.make_regex_subs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20190602151043.4">def _change_all_plain(self, s):
    """
    Perform all plain find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0 &amp; change.
        count += 1
        result.append(s0[prev_i:i])
        result.append(change)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190602155933.1">def _change_all_word(self, s):
    """
    Perform all whole word find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0, change &amp; find0.
        result.append(s0[prev_i:i])
        if g.match_word(s, i, find):
            count += 1
            result.append(change)
        else:
            result.append(find0)
        prev_i = i + len(find)
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import sys
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member
</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
     if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20190814050007.1">def make_dock(c, name, widget): # pyzo_file_browser.py
    """Create a dock with the given name and widget in c's main window."""
    dw = c.frame.top
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=100,
        name=name,
    )
    dw.leo_docks.append(dock)
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    dw.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190923170528.1">def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
</t>
<t tx="ekr.20191206073301.1">@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
</t>
<t tx="ekr.20191207065251.1"></t>
<t tx="ekr.20200131070055.1">class TestJSImporter(unittest.TestCase):
    @others
</t>
<t tx="ekr.20200202093420.1">def test_get_trailing_comments(self):
    
    table = (
        # Test 1
        ( """\
head
// tail""", 1),

        # Test 2
        ("""\
head
/* comment 1
 * comment 2
 */""", 3),
 
        # Test 3
        ("""\
head
/* comment 1
 * comment 2
 */
tail""", 0), # no tail

        # Test 4
        ("""\
head
// comment
tail""", 0), # no tail

) # End table.
    for s, expected_length in table:
        x = JS_Importer(None)
        s = g.adjustTripleString(s, -4)
        lines = g.splitLines(s)
        head, tail = x.get_trailing_comments(lines)
        expected_lines = lines[-expected_length:] if expected_length else []
        assert tail == expected_lines , (repr(tail), repr(expected_lines))
</t>
<t tx="ekr.20200202104932.1">def test_JsLex(self):
    
    table = (
        ('id', ('f_', '$', 'A1', 'abc')),
        ('other', ('ÁÁ',)),  # Unicode strings are not handled by JsLex.
        ('keyword', ('async', 'await', 'if')),
        ('punct', ('(', ')', '{', '}', ',', ':', ';')),
        # ('num', ('9', '2')),  # This test doesn't matter at present.
    )
    for kind, data in table:
        for contents in data:
            for name, tok in JsLexer().lex(contents):
                assert name == kind, f"expected {kind!s} got {name!s} {tok!r} {contents}"
                # print(f"{kind!s:10} {tok!r:10}")
                    
</t>
<t tx="ekr.20200203051839.1">def test_starts_block(self):

    table = (
        (1, 'xx) =&gt; {}'),
        (1, 'class c1'),
        (1, 'function f1'),
        (1, 'xx(function f2'),
        (1, 'xx = function f3'),
        (1, 'xx, function f4'),
        (0, 'a = "function"'),
        (0, 'a = /function/'),
    )
    for expected, line in table:
        x = JS_Importer(None)
        lines = [line]
        new_state = JS_ScanState()
        new_state.curlies += 1
        prev_state = JS_ScanState()
        results = x.starts_block(0, lines, new_state, prev_state)
        # if expected != results: x.scan_line(line, prev_state
        assert expected == results, f"expected: {expected} got: {int(results)} {line!r}\n"
</t>
<t tx="ekr.20200203060718.1">def test_scan_line(self):

    table = (
        # result        prev_context    s
        ( (0, 0, '"'),  "",             r'"string'),
        ( (0, 0, '/*'), "",             r'/* line 1'),
        ( (0, 0, '/*'), "/*",           r'line 2'), # New.
        ( (0, 0, ''),   "/*",           r'line 3 */'), # New.
        ( (0, 0, ''),   "",             r'a + b // /*'),
        ( (0, 1, ''),   "",             r'(function'),
        ( (1, 1, ''),   "",             r'(function(a) {'),
        ( (0, 0, ''),   "",             r'var x = /abc/'),
        ( (0, 0, ''),   "",             r'var x = /a"c/'),
        ( (0, 0, ''),   "",             r'var x = /a\//'),
        ( (0, 0, ''),   "",             r'var x = /a\//'),
        ( (0, 1, ''),   "",             r'var x = (0,'),
    )
    for result, prev_context, s in table:
        importer = JS_Importer(None) ### c.importCommands)
        prev_state = JS_ScanState()
        prev_state.context = prev_context
        new_state = importer.scan_line(s, prev_state)
        curlies, parens, context = result
        ok = (
            new_state.curlies == curlies and
            new_state.parens == parens and
            new_state.context == context)
        assert ok, (
                f"\n"
                f" expected: curlies: {curlies}, parens: {parens}, context: {context!r}\n"
                f"new_state: {new_state}\n"
                f"        s: {s!r}")
</t>
<t tx="ekr.20200204092455.1">class TestAtFile(unittest.TestCase):
    @others
</t>
<t tx="ekr.20200204094139.1">def test_save_after_external_file_rename(self):
    """Test #1469."""
    # Create a new outline with @file node and save it
    bridge = self.bridge()
    temp_dir = self.temp_dir()
    filename = f"{temp_dir.name}{os.sep}test_file.leo"
    c = bridge.openLeoFile(filename)
    p = c.rootPosition()
    p.h = '@file 1'
    p.b = 'b1'
    c.save()
    # Rename the @file node and save
    p1 = c.rootPosition()
    p1.h = "@file 1_renamed"
    c.save()
    # Remove the original "@file 1" from the disk
    external_filename = f"{temp_dir.name}{os.sep}1"
    assert os.path.exists(external_filename)
    os.remove(external_filename)
    assert not os.path.exists(external_filename)
    # Change the @file contents, save and reopen the outline
    p1.b = "b_1_changed"
    c.save()
    c.close()
    c = bridge.openLeoFile(c.fileName())
    p1 = c.rootPosition()
    assert p1.h == "@file 1_renamed", repr(p1.h)
    assert p1.b == "b_1_changed\n", repr(p1.b)
</t>
<t tx="ekr.20200204095726.1">def bridge(self):
    """Return an instance of Leo's bridge."""
    from leo.core import leoBridge
    return leoBridge.controller(gui='nullGui',
        loadPlugins=False,
        readSettings=False,
        silent=True,
        verbose=False,
    )
</t>
<t tx="ekr.20200204103744.1">def temp_file(self):
    """Create a temp file with the given name."""
    import warnings
    warnings.simplefilter("ignore")
    import tempfile
    return tempfile.NamedTemporaryFile(mode='w')
</t>
<t tx="ekr.20200204104247.1"></t>
<t tx="ekr.20200204112501.1">def temp_dir(self):
    """Create a temp file with the given name."""
    import warnings
    warnings.simplefilter("ignore")
    import tempfile
    return tempfile.TemporaryDirectory()
</t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length</t>
<t tx="ekr.20200212095937.6"></t>
<t tx="ekr.20200216063538.1">class TestFind(unittest.TestCase):
    """Test cases for leoFind.py"""
    @others
</t>
<t tx="ekr.20200219071828.1">class TestLeoGlobals(unittest.TestCase):
    """Tests for leoGlobals.py."""
    @others
</t>
<t tx="ekr.20200219071958.1">def test_comment_delims_from_extension(self):

    # pylint: disable=import-self
    from leo.core import leoGlobals as leo_g
    from leo.core import leoApp
    leo_g.app = leoApp.LeoApp()
    assert leo_g.comment_delims_from_extension(".py") == ('#', '', '')
    assert leo_g.comment_delims_from_extension(".c") == ('//', '/*', '*/')
    assert leo_g.comment_delims_from_extension(".html") == ('', '&lt;!--', '--&gt;')
</t>
<t tx="ekr.20200219072957.1">def test_is_sentinel(self):

    # pylint: disable=import-self
    from leo.core import leoGlobals as leo_g
    # Python.
    py_delims = leo_g.comment_delims_from_extension('.py')
    assert leo_g.is_sentinel("#@+node", py_delims)
    assert not leo_g.is_sentinel("#comment", py_delims)
    # C.
    c_delims = leo_g.comment_delims_from_extension('.c')
    assert leo_g.is_sentinel("//@+node", c_delims)
    assert not g.is_sentinel("//comment", c_delims)
    # Html.
    html_delims = leo_g.comment_delims_from_extension('.html')
    assert leo_g.is_sentinel("&lt;!--@+node--&gt;", html_delims)
    assert not leo_g.is_sentinel("&lt;!--comment--&gt;", html_delims)
</t>
<t tx="ekr.20200221050038.1">def run_unit_test_in_separate_process(command):
    """
    A script to be run from unitTest.leo.
    
    Run the unit testing command (say `python -m leo.core.leoAst`) in a separate process.
    
    Fail (in leoTest.leo) if that fails.
    """
    leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
    os.chdir(leo_editor_dir)
    p = subprocess.Popen(
        shlex.split(command),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=sys.platform.startswith('win'),
    )
    out, err = p.communicate()
    err = g.toUnicode(err)
    out = g.toUnicode(out)
    print('')
    print(command)
    if out.strip():
        # print('traces...')
        print(out.rstrip())
    print(err.rstrip())
    # There may be skipped tests...
    err_lines = g.splitLines(err.rstrip())
    if not err_lines[-1].startswith('OK'):
        g.trace('Test failed')
        g.printObj(err_lines, tag='err_lines')
        assert False
</t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200304130514.1">def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200422075655.1">@g.commander_command('restart-leo')
def restartLeo(self, event=None):
    """Restart Leo, reloading all presently open outlines."""
    c, lm = self, g.app.loadManager
    trace = 'shutdown' in g.app.debug
    # 1. Write .leoRecentFiles.txt.
    g.app.recentFilesManager.writeRecentFilesFile(c)
    # 2. Abort the restart if the user veto's any close.
    for c in g.app.commanders():
        if c.changed:
            veto = False
            try:
                c.promptingForClose = True
                veto = c.frame.promptForSave()
            finally:
                c.promptingForClose = False
            if veto:
                g.es_print('Cancelling restart-leo command')
                return
    # 3. Officially begin the restart process. A flag for efc.ask.
    g.app.restarting = True  # #1240.
    # 4. Save session data.
    if g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    # 5. Close all unsaved outlines.
    g.app.setLog(None)  # Kill the log.
    for c in g.app.commanders():
        frame = c.frame
        # This is similar to g.app.closeLeoWindow.
        g.doHook("close-frame", c=c)
        # Save the window state
        g.app.commander_cacher.commit() # store cache, but don't close it.
        # This may remove frame from the window list.
        if frame in g.app.windowList:
            g.app.destroyWindow(frame)
            g.app.windowList.remove(frame)
        else:
            # #69.
            g.app.forgetOpenFile(fn=c.fileName(), force=True)
    # 6. Complete the shutdown.
    g.app.finishQuit()
    # 7. Restart, restoring the original command line.
    args = ['-c'] + [z for z in lm.old_argv]
    if trace: g.trace('restarting with args', args)
    sys.stdout.flush()
    sys.stderr.flush()
    os.execv(sys.executable, args)
</t>
<t tx="ekr.20200522075411.1">def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&amp;', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
</t>
<t tx="ekr.20200523135601.1">def insertCharFromEvent(self, event):
    """
    Handle the character given by event, ignoring various special keys:
    - getArg state: k.getArg.
    - Tree: onCanvasKey or onHeadlineKey.
    - Body: ec.selfInsertCommand
    - Log: log_w.insert
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if trace: g.trace('stroke', stroke, 'plain:', k.isPlainKey(stroke), 'widget', name)
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
</t>
<t tx="ekr.20200524151214.1"></t>
<t tx="ekr.20200526074132.1">def executeMinibufferCommand(self, commandName):
    """Call c.doCommandByName, creating the required event."""
    c = self
    event = g.app.gui.create_key_event(c)
    return c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20200727095246.1"></t>
<t tx="ekr.20200913074639.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
</t>
<t tx="ekr.20200913074701.1"># in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20200913075121.1">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20200913075250.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200913082124.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200913082155.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200914071303.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012111649.1">gnx: ekr.20170925083314.1
</t>
<t tx="ekr.20201012111649.3">gnx: ekr.20170925083853.1
</t>
<t tx="ekr.20201012114516.1">@nosearch</t>
<t tx="ekr.20201012142922.2">gnx: ekr.20201012111338.43
unl: Declarations (leo_cloud_server.py)
</t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.14">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20201013034742.15">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20201013034742.16">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.set_find_text(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.25"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20201013034742.26">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201018062305.1">"""
Overwrite LeoPyRef.leo from the given list of nodes.

This script will delete any nodes that are in LeoPyRef.leo but not in
leoPy.leo.

"""
import os
@others
main(node_list = ['Startup', 'Notes', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by Виталије Милошевић.
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = g.FileLikeObject()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("&lt;vnodes&gt;\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("&lt;/vnodes&gt;\n")
    fc.putTnodes()
    fc.putPostlog()
    return fc.outputFile.getvalue()
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="ekr.20201021075956.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes at the end of the file marked with "EKR".

@others
if use_php_hack:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = rulesDict4 # EKR: was php_rulesDict1
@language python
@tabwidth -4
</t>
<t tx="ekr.20201021093630.1"></t>
<t tx="ekr.20201022053829.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1718

@language python
@nosearch
</t>
<t tx="ekr.20201022053907.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes by EKR.
&lt;&lt; Attribute dicts &gt;&gt;
&lt;&lt; Keyword dicts &gt;&gt;
@others
&lt;&lt; rulesDictDict &gt;&gt;
# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}
if False:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = php_php_rulesdict

@language python
@tabwidth -4
</t>
<t tx="ekr.20201022053907.10">def php_php_function_rule(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

def php_php_keyword_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

def php_php_keyword_rule2(colorer, s, i):
    return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20201022053907.11">def php_php_op1(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op2(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op3(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op4(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op5(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op7(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op8(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op9(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op10(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op11(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op12(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op13(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op14(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op16(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op17(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op18(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op19(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op20(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op21(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op22(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op23(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op24(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op25(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op26(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op27(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
</t>
<t tx="ekr.20201022053907.12"># Rules dict for php_php ruleset.
php_php_rulesdict = {
    "!": [php_php_op3],
    "\"": [php_php_literal1],
    "#": [php_php_comment4],
    "$": [php_php_keyword_rule1],
    "%": [php_php_op13],
    "&amp;": [php_php_op14],
    "'": [php_php_literal2],
    "(": [php_php_function_rule],
    "*": [php_php_op10],
    "+": [php_php_op7],
    ",": [php_php_op21],
    "-": [php_php_op2, php_php_op8],
    ".": [php_php_op18],
    "/": [php_php_comment1, php_php_comment2, php_php_comment3, php_php_op9],
    "0": [php_php_keyword_rule2],
    "1": [php_php_keyword_rule2],
    "2": [php_php_keyword_rule2],
    "3": [php_php_keyword_rule2],
    "4": [php_php_keyword_rule2],
    "5": [php_php_keyword_rule2],
    "6": [php_php_keyword_rule2],
    "7": [php_php_keyword_rule2],
    "8": [php_php_keyword_rule2],
    "9": [php_php_keyword_rule2],
    ":": [php_php_op27],
    ";": [php_php_op22],
    "&lt;": [php_php_op5, php_php_op12],
    "&lt; ": [php_php_literal4],
    "=": [php_php_op1, php_php_op6],
    "&gt;": [php_php_op4, php_php_op11],
    "?": [php_php_op25],
    "@": [php_php_op26, php_php_keyword_rule2],
    "A": [php_php_keyword_rule2],
    "B": [php_php_keyword_rule2],
    "C": [php_php_keyword_rule2],
    "D": [php_php_keyword_rule2],
    "E": [php_php_keyword_rule2],
    "F": [php_php_keyword_rule2],
    "G": [php_php_keyword_rule2],
    "H": [php_php_keyword_rule2],
    "I": [php_php_keyword_rule2],
    "J": [php_php_keyword_rule2],
    "K": [php_php_keyword_rule2],
    "L": [php_php_keyword_rule2],
    "M": [php_php_keyword_rule2],
    "N": [php_php_keyword_rule2],
    "O": [php_php_keyword_rule2],
    "P": [php_php_keyword_rule2],
    "Q": [php_php_keyword_rule2],
    "R": [php_php_keyword_rule2],
    "S": [php_php_keyword_rule2],
    "T": [php_php_keyword_rule2],
    "U": [php_php_keyword_rule2],
    "V": [php_php_keyword_rule2],
    "W": [php_php_keyword_rule2],
    "X": [php_php_keyword_rule2],
    "Y": [php_php_keyword_rule2],
    "Z": [php_php_keyword_rule2],
    "[": [php_php_op24],
    "]": [php_php_op23],
    "^": [php_php_op16],
    "_": [php_php_keyword_rule2],
    "`": [php_php_literal3],
    "a": [php_php_keyword_rule2],
    "b": [php_php_keyword_rule2],
    "c": [php_php_keyword_rule2],
    "d": [php_php_keyword_rule2],
    "e": [php_php_keyword_rule2],
    "f": [php_php_keyword_rule2],
    "g": [php_php_keyword_rule2],
    "h": [php_php_keyword_rule2],
    "i": [php_php_keyword_rule2],
    "j": [php_php_keyword_rule2],
    "k": [php_php_keyword_rule2],
    "l": [php_php_keyword_rule2],
    "m": [php_php_keyword_rule2],
    "n": [php_php_keyword_rule2],
    "o": [php_php_keyword_rule2],
    "p": [php_php_keyword_rule2],
    "q": [php_php_keyword_rule2],
    "r": [php_php_keyword_rule2],
    "s": [php_php_keyword_rule2],
    "t": [php_php_keyword_rule2],
    "u": [php_php_keyword_rule2],
    "v": [php_php_keyword_rule2],
    "w": [php_php_keyword_rule2],
    "x": [php_php_keyword_rule2],
    "y": [php_php_keyword_rule2],
    "z": [php_php_keyword_rule2],
    "{": [php_php_op20],
    "|": [php_php_op15],
    "}": [php_php_op19],
    "~": [php_php_op17],
}
</t>
<t tx="ekr.20201022053907.13"># Rules for the php_php_literal ruleset.

def php_php_literal_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
php_php_literal_rulesdict = {
    "$": [php_php_literal_rule1],
}
</t>
<t tx="ekr.20201022053907.14"># Rules for the php_javascript_php ruleset...

def php_javascript_php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_javascript_php ruleset.
php_javascript_php_rulesdict = {
    "&lt;": [
        php_javascript_php_rule1,
        php_javascript_php_rule2,
        php_javascript_php_rule3],
}
</t>
<t tx="ekr.20201022053907.15"># Rules for the php_javascript ruleset...

def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
php_javascript_rulesdict = {
    "&gt;": [php_rule58],
    "S": [php_rule59],
}

</t>
<t tx="ekr.20201022053907.16">def phpdoc_rule1(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule2(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def phpdoc_rule4(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule5(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)
        
def phpdoc_rule8(colorer, s, i):
    return colorer.match_keywords(s, i)
    
# Rules dict for php_phpdoc ruleset.
phpdoc_rulesdict = {
    "*": [phpdoc_rule2],
    "0": [phpdoc_rule8],
    "1": [phpdoc_rule8],
    "2": [phpdoc_rule8],
    "3": [phpdoc_rule8],
    "4": [phpdoc_rule8],
    "5": [phpdoc_rule8],
    "6": [phpdoc_rule8],
    "7": [phpdoc_rule8],
    "8": [phpdoc_rule8],
    "9": [phpdoc_rule8],
    "&lt;": [phpdoc_rule3,phpdoc_rule4,phpdoc_rule5,phpdoc_rule6,phpdoc_rule7],
    "@": [phpdoc_rule8],
    "A": [phpdoc_rule8],
    "B": [phpdoc_rule8],
    "C": [phpdoc_rule8],
    "D": [phpdoc_rule8],
    "E": [phpdoc_rule8],
    "F": [phpdoc_rule8],
    "G": [phpdoc_rule8],
    "H": [phpdoc_rule8],
    "I": [phpdoc_rule8],
    "J": [phpdoc_rule8],
    "K": [phpdoc_rule8],
    "L": [phpdoc_rule8],
    "M": [phpdoc_rule8],
    "N": [phpdoc_rule8],
    "O": [phpdoc_rule8],
    "P": [phpdoc_rule8],
    "Q": [phpdoc_rule8],
    "R": [phpdoc_rule8],
    "S": [phpdoc_rule8],
    "T": [phpdoc_rule8],
    "U": [phpdoc_rule8],
    "V": [phpdoc_rule8],
    "W": [phpdoc_rule8],
    "X": [phpdoc_rule8],
    "Y": [phpdoc_rule8],
    "Z": [phpdoc_rule8],
    "_": [phpdoc_rule8],
    "a": [phpdoc_rule8],
    "b": [phpdoc_rule8],
    "c": [phpdoc_rule8],
    "d": [phpdoc_rule8],
    "e": [phpdoc_rule8],
    "f": [phpdoc_rule8],
    "g": [phpdoc_rule8],
    "h": [phpdoc_rule8],
    "i": [phpdoc_rule8],
    "j": [phpdoc_rule8],
    "k": [phpdoc_rule8],
    "l": [phpdoc_rule8],
    "m": [phpdoc_rule8],
    "n": [phpdoc_rule8],
    "o": [phpdoc_rule8],
    "p": [phpdoc_rule8],
    "q": [phpdoc_rule8],
    "r": [phpdoc_rule8],
    "s": [phpdoc_rule8],
    "t": [phpdoc_rule8],
    "u": [phpdoc_rule8],
    "v": [phpdoc_rule8],
    "w": [phpdoc_rule8],
    "x": [phpdoc_rule8],
    "y": [phpdoc_rule8],
    "z": [phpdoc_rule8],
    "{": [phpdoc_rule1],
}
</t>
<t tx="ekr.20201022053907.17"># rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": php_javascript_rulesdict,
    "php_javascript_php": php_javascript_php_rulesdict,
    "php_main": php_main_rulesdict,
    "php_php": php_php_rulesdict,
    "php_php_literal": php_php_literal_rulesdict,
    "php_phpdoc": phpdoc_rulesdict,
    "php_tags": php_tags_rulesdict,
    "php_tags_literal": php_tags_literal_rulesdict,
}
</t>
<t tx="ekr.20201022053907.2">

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}
</t>
<t tx="ekr.20201022053907.3"># Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}
</t>
<t tx="ekr.20201022053907.4"># Rules for php_main ruleset...
# All rules start with '&lt;' or '&amp;'.

def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup",
        begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
php_main_rulesdict = {
    "&amp;": [php_rule9],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule4,php_rule5,php_rule6,php_rule7,php_rule8],
}
</t>
<t tx="ekr.20201022053907.5"># Rules for the php_tags ruleset...

def php_tags_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule4(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
# Rules dict for php_tags ruleset.
php_tags_rulesdict = {
    "\"": [php_tags_rule4,],
    "'": [php_tags_rule5,],
    "&lt;": [php_tags_rule1, php_tags_rule2, php_tags_rule3,],
    "=": [php_tags_rule6,],
}

</t>
<t tx="ekr.20201022053907.6">def php_tags_literal_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
php_tags_literal_rulesdict = {
    "&lt;": [
        php_tags_literal_rule1,
        php_tags_literal_rule2,
        php_tags_literal_rule3,
    ],
}
</t>
<t tx="ekr.20201022053907.7"># Rules for the php_php ruleset...

</t>
<t tx="ekr.20201022053907.8">def php_php_comment1(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment2(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment3(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

def php_php_comment4(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)
</t>
<t tx="ekr.20201022053907.9">def php_php_literal1(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal2(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal3(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1",
        begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</t>
<t tx="ekr.20201022055738.1">use_php_hack = False

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}

# Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}

# Rules for php_main ruleset.

</t>
<t tx="ekr.20201022055738.10">def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.11">def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
rulesDict1 = {
    "&amp;": [php_rule9,],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule5,php_rule6,php_rule7,php_rule8,],
    "&lt; ": [php_rule4,],
}

# Rules for php_tags ruleset.

</t>
<t tx="ekr.20201022055738.12">def php_rule10(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.13">def php_rule11(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.14">def php_rule12(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.15">def php_rule13(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.16">def php_rule14(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.17">def php_rule15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

# Rules dict for php_tags ruleset.
rulesDict2 = {
    "\"": [php_rule13,],
    "'": [php_rule14,],
    "&lt;": [php_rule10,php_rule11,php_rule12,],
    "=": [php_rule15,],
}

# Rules for php_tags_literal ruleset.

</t>
<t tx="ekr.20201022055738.18">def php_rule16(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.19">def php_rule17(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.2">def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.20">def php_rule18(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
rulesDict3 = {
    "&lt;": [php_rule16,php_rule17,php_rule18,],
}

# Rules for php_php ruleset.

</t>
<t tx="ekr.20201022055738.21">def php_rule19(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.22">def php_rule20(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.23">def php_rule21(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.24">def php_rule22(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.25">def php_rule23(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.26">def php_rule24(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.27">def php_rule25(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.28">def php_rule26(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1", begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.29">def php_rule27(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

</t>
<t tx="ekr.20201022055738.3">def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.30">def php_rule28(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.31">def php_rule29(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.32">def php_rule30(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.33">def php_rule31(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.34">def php_rule32(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.35">def php_rule33(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.36">def php_rule34(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.37">def php_rule35(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.38">def php_rule36(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.39">def php_rule37(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.4">def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.40">def php_rule38(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.41">def php_rule39(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.42">def php_rule40(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.43">def php_rule41(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.44">def php_rule42(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.45">def php_rule43(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.46">def php_rule44(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.47">def php_rule45(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.48">def php_rule46(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.49">def php_rule47(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.5">def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.50">def php_rule48(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.51">def php_rule49(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.52">def php_rule50(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.53">def php_rule51(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.54">def php_rule52(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.55">def php_rule53(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.56">def php_rule54(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.57">def php_rule55(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

</t>
<t tx="ekr.20201022055738.58">def php_rule56(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_php ruleset.
rulesDict4 = {
    "!": [php_rule30,],
    "\"": [php_rule21,],
    "#": [php_rule25,],
    "$": [php_rule27,],
    "%": [php_rule40,],
    "&amp;": [php_rule41,],
    "'": [php_rule22,],
    "(": [php_rule55,],
    "*": [php_rule37,],
    "+": [php_rule34,],
    ",": [php_rule48,],
    "-": [php_rule29,php_rule35,],
    ".": [php_rule45,],
    "/": [php_rule19,php_rule20,php_rule24,php_rule36,],
    "0": [php_rule56,],
    "1": [php_rule56,],
    "2": [php_rule56,],
    "3": [php_rule56,],
    "4": [php_rule56,],
    "5": [php_rule56,],
    "6": [php_rule56,],
    "7": [php_rule56,],
    "8": [php_rule56,],
    "9": [php_rule56,],
    ":": [php_rule54,],
    ";": [php_rule49,],
    "&lt;": [php_rule32,php_rule39,],
    "&lt; ": [php_rule26,],
    "=": [php_rule28,php_rule33,],
    "&gt;": [php_rule31,php_rule38,],
    "?": [php_rule52,],
    "@": [php_rule53,php_rule56,],
    "A": [php_rule56,],
    "B": [php_rule56,],
    "C": [php_rule56,],
    "D": [php_rule56,],
    "E": [php_rule56,],
    "F": [php_rule56,],
    "G": [php_rule56,],
    "H": [php_rule56,],
    "I": [php_rule56,],
    "J": [php_rule56,],
    "K": [php_rule56,],
    "L": [php_rule56,],
    "M": [php_rule56,],
    "N": [php_rule56,],
    "O": [php_rule56,],
    "P": [php_rule56,],
    "Q": [php_rule56,],
    "R": [php_rule56,],
    "S": [php_rule56,],
    "T": [php_rule56,],
    "U": [php_rule56,],
    "V": [php_rule56,],
    "W": [php_rule56,],
    "X": [php_rule56,],
    "Y": [php_rule56,],
    "Z": [php_rule56,],
    "[": [php_rule51,],
    "]": [php_rule50,],
    "^": [php_rule43,],
    "_": [php_rule56,],
    "`": [php_rule23,],
    "a": [php_rule56,],
    "b": [php_rule56,],
    "c": [php_rule56,],
    "d": [php_rule56,],
    "e": [php_rule56,],
    "f": [php_rule56,],
    "g": [php_rule56,],
    "h": [php_rule56,],
    "i": [php_rule56,],
    "j": [php_rule56,],
    "k": [php_rule56,],
    "l": [php_rule56,],
    "m": [php_rule56,],
    "n": [php_rule56,],
    "o": [php_rule56,],
    "p": [php_rule56,],
    "q": [php_rule56,],
    "r": [php_rule56,],
    "s": [php_rule56,],
    "t": [php_rule56,],
    "u": [php_rule56,],
    "v": [php_rule56,],
    "w": [php_rule56,],
    "x": [php_rule56,],
    "y": [php_rule56,],
    "z": [php_rule56,],
    "{": [php_rule47,],
    "|": [php_rule42,],
    "}": [php_rule46,],
    "~": [php_rule44,],
}

# Rules for php_php_literal ruleset.

</t>
<t tx="ekr.20201022055738.59">def php_rule57(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
rulesDict5 = {
    "$": [php_rule57,],
}

# Rules for php_javascript ruleset.

</t>
<t tx="ekr.20201022055738.6">def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup", begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.60">def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

</t>
<t tx="ekr.20201022055738.61">def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
rulesDict6 = {
    "&gt;": [php_rule58,],
    "S": [php_rule59,],
}

# Rules for php_javascript_php ruleset.

</t>
<t tx="ekr.20201022055738.62">def php_rule60(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.63">def php_rule61(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.64">def php_rule62(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)


# Rules dict for php_javascript_php ruleset.
rulesDict7 = {
    "&lt;": [php_rule60,php_rule61,php_rule62,],
}

# Rules for php_phpdoc ruleset.

</t>
<t tx="ekr.20201022055738.65">def php_rule63(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.66">def php_rule64(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.67">def php_rule65(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.68">def php_rule66(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.69">def php_rule67(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.7">def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.70">def php_rule68(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.71">def php_rule69(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)

</t>
<t tx="ekr.20201022055738.72">def php_rule70(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_phpdoc ruleset.
rulesDict8 = {
    "*": [php_rule64,],
    "0": [php_rule70,],
    "1": [php_rule70,],
    "2": [php_rule70,],
    "3": [php_rule70,],
    "4": [php_rule70,],
    "5": [php_rule70,],
    "6": [php_rule70,],
    "7": [php_rule70,],
    "8": [php_rule70,],
    "9": [php_rule70,],
    "&lt;": [php_rule65,php_rule66,php_rule67,php_rule68,php_rule69,],
    "@": [php_rule70,],
    "A": [php_rule70,],
    "B": [php_rule70,],
    "C": [php_rule70,],
    "D": [php_rule70,],
    "E": [php_rule70,],
    "F": [php_rule70,],
    "G": [php_rule70,],
    "H": [php_rule70,],
    "I": [php_rule70,],
    "J": [php_rule70,],
    "K": [php_rule70,],
    "L": [php_rule70,],
    "M": [php_rule70,],
    "N": [php_rule70,],
    "O": [php_rule70,],
    "P": [php_rule70,],
    "Q": [php_rule70,],
    "R": [php_rule70,],
    "S": [php_rule70,],
    "T": [php_rule70,],
    "U": [php_rule70,],
    "V": [php_rule70,],
    "W": [php_rule70,],
    "X": [php_rule70,],
    "Y": [php_rule70,],
    "Z": [php_rule70,],
    "_": [php_rule70,],
    "a": [php_rule70,],
    "b": [php_rule70,],
    "c": [php_rule70,],
    "d": [php_rule70,],
    "e": [php_rule70,],
    "f": [php_rule70,],
    "g": [php_rule70,],
    "h": [php_rule70,],
    "i": [php_rule70,],
    "j": [php_rule70,],
    "k": [php_rule70,],
    "l": [php_rule70,],
    "m": [php_rule70,],
    "n": [php_rule70,],
    "o": [php_rule70,],
    "p": [php_rule70,],
    "q": [php_rule70,],
    "r": [php_rule70,],
    "s": [php_rule70,],
    "t": [php_rule70,],
    "u": [php_rule70,],
    "v": [php_rule70,],
    "w": [php_rule70,],
    "x": [php_rule70,],
    "y": [php_rule70,],
    "z": [php_rule70,],
    "{": [php_rule63,],
}

# x.rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": rulesDict6,
    "php_javascript_php": rulesDict7,
    "php_main": rulesDict1,
    "php_php": rulesDict4,
    "php_php_literal": rulesDict5,
    "php_phpdoc": rulesDict8,
    "php_tags": rulesDict2,
    "php_tags_literal": rulesDict3,
}

# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}

# EKR
</t>
<t tx="ekr.20201022055738.8">def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.9">def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201030052707.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1720

@language python
</t>
<t tx="ekr.20201030053803.1"></t>
<t tx="ekr.20201030065903.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1721

@language python
@nosearch</t>
<t tx="ekr.20201030084949.1"></t>
<t tx="ekr.20201030085148.1">@nosearch

# flattened, word, ignore-case, head, body

 search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2

# found 17 nodes</t>
<t tx="ekr.20201030085515.1"></t>
<t tx="ekr.20201031083701.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1413

@language python
@nosearch
</t>
<t tx="ekr.20201107145642.1">def afterChangeHeadline(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeHeadline."""
    u = self
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'headline'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeHeadline
    bunch.redoHelper = u.redoChangeHeadline
    bunch.newHead = p.h
    u.pushBead(bunch)

afterChangeHead = afterChangeHeadline
</t>
<t tx="ekr.20201107145859.1">def beforeChangeHeadline(self, p):
    """
    Return data that gets passed to afterChangeNode.
    
    The oldHead kwarg works around a Qt difficulty when changing headlines.
    """
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldHead = p.h
    return bunch

beforeChangeHead = beforeChangeHeadline
</t>
<t tx="ekr.20201107150041.1">def undoChangeHeadline(self):
    """Undo a change to a node's headline."""
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    u.p.initHeadString(u.oldHead)
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
</t>
<t tx="ekr.20201107150619.1">def redoChangeHeadline(self):
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
</t>
<t tx="ekr.20201108061811.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1726

@language python
</t>
<t tx="ekr.20201108064325.1"></t>
<t tx="ekr.20201108064358.1">@language rest
@wrap

Use leo-c to test cursesGui2.
Use f to test flexx.

How the headline was reverted:
- Ctrl-I: New headline
- type abc
- *click* (not return) another node: the headline appears to stick.
- Double click abc node: the headline reverts to newHeadline
- Does *not* happen after Ctrl-h.

@language python
</t>
<t tx="ekr.20201108144604.1"># QAbstractItemModel::headerDataChanged(Qt::Orientation orientation, int first, int last)</t>
<t tx="ekr.20201109043641.1">def editingFinished_callback():
    """Called when Qt emits the editingFinished signal."""
    s = e.text()
    i = s.find('\n')
    # Truncate to one line.
    if i &gt; -1:
        s = s[:i]
    # #1310: update the tooltip.
    if p.h != s:
        # Update p.h and handle undo.
        item.setToolTip(0, s)
        undoData = u.beforeChangeHeadline(p)
        p.v.setHeadString(s)  # Set v.h *after* calling the undoer's before method.
        if not c.changed:
            c.setChanged()
        # We must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        p.setDirty()
        u.afterChangeHeadline(p, 'Edit Headline', undoData)
    self.redraw_after_head_changed()
    c.outerUpdate()
</t>
<t tx="ekr.20201109074740.1">def beforeChangeBody(self, p):
    """Return data that gets passed to afterChangeBody."""
    w = self.c.frame.body.wrapper
    bunch = self.createCommonBunch(p)
        # Sets u.oldMarked, u.oldSel, u.p
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    bunch.oldIns = w.getInsertPoint()
    bunch.oldYScroll = w.getYScrollPosition()
    return bunch
</t>
<t tx="ekr.20201109075104.1">def afterChangeBody(self, p, command, bunch):
    """
    Create an undo node using d created by beforeChangeNode.
    
    *Important*: Before calling this method, caller must:
    - Set p.v.b. (Setting p.b would cause a redraw).
    - Set the desired selection range and insert point.
    - Set the y-scroll position, if desired.
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'body'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeBody
    bunch.redoHelper = u.redoChangeBody
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newIns = w.getInsertPoint()
    bunch.newMarked = p.isMarked()
    # Careful: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
    # 
    if g.unitTesting:
        assert command.lower() != 'typing', g.callers()
    elif command.lower() == 'typing':
        g.trace(
            'Error: undoType should not be "Typing"\n'
            'Call u.doTyping instead')
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20201109080631.1">def undoChangeBody(self):
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.oldMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.oldBody)
        i, j = u.oldSel
        w.setSelectionRange(i, j, insert=u.oldIns)
        w.setYScrollPosition(u.oldYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('old')
</t>
<t tx="ekr.20201109080732.1">def redoChangeBody(self):
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.newBody
    u.p.h = u.newHead
    # This is required so. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
    if u.newMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.newBody)
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=u.newIns)
        w.setYScrollPosition(u.newYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20201109082007.1"></t>
<t tx="ekr.20201109104158.1">@nosearch

# flattened, word, ignore-case, head, body

# found 21 nodes</t>
<t tx="ekr.20201109104329.1"> search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2
</t>
<t tx="ekr.20201109104353.1"> search: c\.setHeadString\((\w+)\s*,\s*(\w+)\)
replace: \1.h = \2
</t>
<t tx="ekr.20201109104837.1"></t>
<t tx="ekr.20201109105836.1"></t>
<t tx="ekr.20201109110403.1"></t>
<t tx="ekr.20201110015336.1">g.cls()
import os
import re
path = os.path.join(g.app.loadDir, '..', 'modes', 'php.py')
with open(path, 'r') as f:
    contents = f.read()
def_pat = r'^def\s*(php_rule[0-9]+)'
for line in g.splitLines(contents):
    m = re.match(def_pat, line)
    if m:
        print(m.group(1))</t>
<t tx="ekr.20201110092953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1591

In ekr-1591 branch.

@language python
@nosearch
</t>
<t tx="ekr.20201110094832.1"></t>
<t tx="ekr.20201111052557.1">def patch_1591(self):
    """
    A workaround for #1591.
    
    Add labels and tooltips for all buttons.
    """
    # Patch the buttons only if the pyqt version is greater than 5.12.
    from leo.core.leoQt import isQt5, qt_version
    if not isQt5:
        return
    qt_version = [int(z) for z in qt_version.split('.')]
    if qt_version[1] &lt;= 12:
        return
    ui = self.ui.UI
    # Add text and tooltips to all numeric priority buttons.
    for i in range(10):
        button = getattr(ui, f"butPri{i}")
        button.setText(f"{i}")
        button.setToolTip(f"Priority {i}")
    # Add text and tooltips to other buttons...
    table = (
        # Alternate priorities...
        ('butPriChk', 'Check', 'Check Mark'),
        ('butPriToDo', 'Box', 'Box Mark'),
        ('butPriX', 'X', 'Black X'),
        ('butPriXgry', 'X', 'Gray X'),
        ('butPriBang', '!', 'Exclamation Point'),
        ('butPriQuery', '?', 'Question Mark'),
        ('butPriBullet', '•', 'Bullet'),
        ('butPriClr', 'Clear', 'Clear Priority'),
        # Other labels...
        ('butDetails', 'Details', 'Toggle Details'),
        ('butNext', 'Next Node', 'Next Node'),
        ('butNextTodo', 'Next Todo', 'Next To Do'),
        ('butClrTime', 'Clear Time', 'Clear Required Time'),
        ('butClrProg', 'Clear Progress', 'Clear Progress')
    )
    for attr, text, tooltip in table:
        button = getattr(ui, attr)
        button.setText(text)
        button.setToolTip(tooltip)
        
        
</t>
<t tx="ekr.20201111182127.1">indent-region       !text = Tab
newline-and-indent  = Ctrl-j
focus-to-body       !tree = Tab
unindent-region     = ctrl-less # Ctrl-Shift-&lt;
unindent-region     = Shift-tab</t>
<t tx="ekr.20201112060726.1">@language rest
@wrap

Issue: https://github.com/leo-editor/leo-editor/issues/1731
PR: https://github.com/leo-editor/leo-editor/pull/1732

--- Reopened.


@language python
@nosearch
</t>
<t tx="ekr.20201112095019.1"></t>
<t tx="ekr.20201113190926.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1734

@language python
@nosearch
</t>
<t tx="ekr.20201114110737.1">def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    
    Return the value returned by the command, or None if no command is executed.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return None
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&amp;', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return None
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        return None
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return None
    #
    # Invoke the command, if given.
    if func:
        return_value = c.doCommand(func, commandName, event=event)
        if c.exists:
            c.frame.updateStatusLine()
        return return_value
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return None
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()
    return None
</t>
<t tx="ekr.20201114160816.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">@language rest
@wrap
@nosearch

**Move More**

- Reconnect Woo Commerce.

Promises:
- Restart music lessons after second vaccination.
  Goal: play in rhythm with right notes.
- Finish Phil's portrait.
- Reconnect Woo Commerce.
- Ride bicycle 2 times. Move every day, preferably outside.
- Relax and dream.
</t>
<t tx="ekr.20201118031649.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1739

PR: https://github.com/leo-editor/leo-editor/issues/1740

@language python
@nosearch
</t>
<t tx="ekr.20201118080056.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1743

@language python
@nosearch
</t>
<t tx="ekr.20201118194139.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1742

@language python
@nosearch
</t>
<t tx="ekr.20201118195915.1"></t>
<t tx="ekr.20201119104633.1"></t>
<t tx="ekr.20201119113415.1">************* Module leo.commands.killBufferCommands
killBufferCommands.py:297:16: E1102: self.kbiterator.next is not callable (not-callable)

************* Module leo.core.leoKeys
leoKeys.py:3135:12: E1102: handler is not callable (not-callable)

************* Module leo.core.leoRst
leoRst.py:1804:8: E1121: Too many positional arguments for method call (too-many-function-args)
leoRst.py:1991:8: E1120: No value for argument 'p' in method call (no-value-for-parameter)

************* Module leo.plugins.active_path
active_path.py:284:16: E1120: No value for argument 'a' in function call (no-value-for-parameter)

************* Module leo.plugins.bookmarks
bookmarks.py:489:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
bookmarks.py:544:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.cursesGui2
cursesGui2.py:481:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2740:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2974:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3122:4: W0222: Signature differs from overridden 'display' method (signature-differs)
cursesGui2.py:3128:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3134:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3298:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3756:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3976:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.demo
demo.py:31:8: E1101: Instance of 'LeoApp' has no 'next' member (no-member)
demo.py:39:8: E1101: Instance of 'LeoApp' has no 'prev' member (no-member)
demo.py:47:8: E1101: Instance of 'LeoApp' has no 'end' member (no-member)
demo.py:274:28: E1102: self.next is not callable (not-callable)
demo.py:276:24: E1102: self.next is not callable (not-callable)
demo.py:727:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:732:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:745:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:766:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:787:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:795:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:799:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:806:13: E1101: Instance of 'LeoApp' has no 'get_icon_fn' member (no-member)
demo.py:824:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:825:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:833:12: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:844:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:848:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:855:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:859:25: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:860:24: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:893:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:902:12: E1101: Instance of 'LeoApp' has no 'find_node' member (no-member)
demo.py:904:25: E1101: Instance of 'LeoApp' has no 'headline_geometry' member (no-member)

************* Module leo.plugins.importers.javascript
importers/javascript.py:520:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.notebook
notebook.py:74:12: E0611: No name 'QtQuick' in module 'PyQt5' (no-name-in-module)

************* Module leo.plugins.python_terminal
python_terminal.py:76:12: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
python_terminal.py:294:16: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.quicksearch
quicksearch.py:249:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.read_only_nodes
read_only_nodes.py:167:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:200:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:221:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)

************* Module leo.plugins.screencast
screencast.py:622:16: E1102: m.next is not callable (not-callable)
screencast.py:683:12: E1102: m.next is not callable (not-callable)
screencast.py:689:12: E1102: m.next is not callable (not-callable)
screencast.py:691:12: E1102: m.next is not callable (not-callable)
screencast.py:693:12: E1102: m.prev is not callable (not-callable)

************* Module leo.plugins.stickynotes_plus
stickynotes_plus.py:184:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
</t>
<t tx="ekr.20201119114229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1746

@language python
@nosearch
</t>
<t tx="ekr.20201119120953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1747

@language python
@nosearch
</t>
<t tx="ekr.20201121085817.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1748

regex fails with replace-all

@language python
@nosearch
</t>
<t tx="ekr.20201122134617.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1749

@language python
@nosearch
</t>
<t tx="ekr.20201122165543.1"></t>
<t tx="ekr.20201122165606.1"></t>
<t tx="ekr.20201123183452.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1754

w.see works for the first time ever!

@language python
@nosearch
</t>
<t tx="ekr.20201124191844.1">@g.commander_command('reformat-selection')
def reformatSelection(self, event=None, undoType='Reformat Paragraph'):
    """
    Reformat the selected text, as in reformat-paragraph, but without
    expanding the selection past the selected lines.
    """
    c, undoType = self, 'reformat-selection'
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    bunch = u.beforeChangeBody(p)
    oldSel, oldYview, original, pageWidth, tabWidth = rp_get_args(c)
    head, middle, tail = c.frame.body.getSelectionLines()
    lines = g.splitLines(middle)
    if not lines:
        return
    indents, leading_ws = rp_get_leading_ws(c, lines, tabWidth)
    result = rp_wrap_all_lines(c, indents, leading_ws, lines, pageWidth)
    s = head + result + tail
    if s == original:
        return
    #
    # Update the text and the selection.
    w.setAllText(s)  # Destroys coloring.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    j = min(j, len(s))
    w.setSelectionRange(i, j, insert=j)
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20201125041840.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1751

File "C:\Programs\Leo\leo\plugins\quicksearch.py", line 733, in onSelectItem
    indent = len(cur.text()) - len(str(cur.text()).lstrip())
AttributeError: 'NoneType' object has no attribute 'text'

@language python
@nosearch
</t>
<t tx="ekr.20201127035748.1">def updateAfterTyping(self, p, w):
    """
    Perform all update tasks after changing body text.
    
    This is ugly, ad-hoc code, but should be done uniformly.
    """
    c = self.c
    if g.isTextWrapper(w):
        # An important, ever-present unit test.
        all = w.getAllText()
        if g.unitTesting:
            assert p.b == all, (w, g.callers())
        elif p.b != all:
            g.trace(
                f"\np.b != w.getAllText() p: {p.h} \n"
                f"w: {w!r} \n{g.callers()}\n")
            # g.printObj(g.splitLines(p.b), tag='p.b')
            # g.printObj(g.splitLines(all), tag='getAllText')
        p.v.insertSpot = ins = w.getInsertPoint()
        # From u.doTyping.
        newSel = w.getSelectionRange()
        if newSel is None:
            p.v.selectionStart, p.v.selectionLength = (ins, 0)
        else:
            i, j = newSel
            p.v.selectionStart, p.v.selectionLength = (i, j - i)
    else:
        if g.unitTesting:
            assert False, f"Not a text wrapper: {g.callers()}"
        g.trace('Not a text wrapper')
        p.v.insertSpot = 0
        p.v.selectionStart, p.v.selectionLength = (0, 0)
    #
    # #1749.
    if p.isDirty():
        redraw_flag = False
    else:
        p.setDirty() # Do not call p.v.setDirty!
        redraw_flag = True
    if not c.isChanged():
        c.setChanged()
    # Update editors.
    c.frame.body.updateEditors()
    # Update icons.
    val = p.computeIcon()
    if not hasattr(p.v, "iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
    #
    # Recolor the body.
    c.frame.scanForTabWidth(p)  # Calls frame.setTabWidth()
    c.recolor()
    if g.app.unitTesting:
        g.app.unitTestDict['colorized'] = True
    if redraw_flag:
        c.redraw_after_icons_changed()
    w.setFocus()
</t>
<t tx="ekr.20201127072229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1759

@language python
@nosearch
</t>
<t tx="ekr.20201127072238.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1757

k.doBinding and k.getPaneBinding fix the primary issue.

vc.vim_dot fixes a secondary issue, described in #1757.

- Update vim docs.

@language python
@nosearch
</t>
<t tx="ekr.20201127143342.1">def see_more_lines(s, ins, n=4):
    """
    Extend index i within string s to include n more lines.
    """
    # Show more lines, if they exist.
    if n &gt; 0:
        for z in range(n):
            if ins &gt;= len(s):
                break
            i, j = g.getLine(s, ins)
            ins = j
    return max(0, min(ins, len(s)))
</t>
<t tx="ekr.20201128042351.1"></t>
<t tx="ekr.20201128042437.1"></t>
<t tx="ekr.20201128043237.1"></t>
<t tx="ekr.20201128045435.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1760

These seem harmless, but they are mysterious.

@language python
@nosearch


</t>
<t tx="ekr.20201128050540.1">c:\leo.repo\leo-editor&gt;python c:\leo.repo\leo-editor\launchLeo.py --no-splash --gui=qttabs leo\core\leoPy.leo

Leo 6.4-devel, ekr-undo branch, build d1ba6bc993

2020-11-27 15:02:52 -0600
wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
pylint: leoKeys.py
pylint finished
Starting log_listener.py
About to start TCP server...
--------------------
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
   pr: Saving: c:/leo.repo/leo-editor/leo/test/unitTest.leo
listener suspended
killed log listener.

c:\leo.repo\leo-editor&gt;</t>
<t tx="ekr.20201128051459.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1733

@language python
@nosearch
</t>
<t tx="ekr.20201128052211.1">@nosearch

# flattened, word, ignore-case, body

# found 22 nodes</t>
<t tx="ekr.20201128125708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1758

**After** the sabbatical:

- Enable tests of selection range.
- Enable tests of undo/redo.
- Rename 'directives' kwarg to 'parent_b'.
- Remove tempNode.
- (Maybe): run-all-tests command.

@language python
@nosearch
</t>
<t tx="ekr.20201128132124.1"></t>
<t tx="ekr.20201128132228.1"></t>
<t tx="ekr.20201128132310.1"></t>
<t tx="ekr.20201128132526.1"></t>
<t tx="ekr.20201128133405.1"></t>
<t tx="ekr.20201128133541.1"></t>
<t tx="ekr.20201128164717.1"></t>
<t tx="ekr.20201128164717.10">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.100">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.101">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.102">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.103">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.104">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.105">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.106">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.107">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.108">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.109"></t>
<t tx="ekr.20201128164717.11">vr = c.helpCommands.helpForBindings()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.110">from leo.core import leoBeautify
from leo.commands import convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.111">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20201128164717.112">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.113">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.114">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.115">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.116">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.118">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.12">vr = c.helpCommands.helpForFindCommands()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.120">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.121">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.122">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.123">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.124">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.125"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.126"># Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
</t>
<t tx="ekr.20201128164717.127"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.128">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.129">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.13">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.130">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.131">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.132">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        target = p.copy()
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h, c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
</t>
<t tx="ekr.20201128164717.133"></t>
<t tx="ekr.20201128164717.136"></t>
<t tx="ekr.20201128164717.137"></t>
<t tx="ekr.20201128164717.138"></t>
<t tx="ekr.20201128164717.139"></t>
<t tx="ekr.20201128164717.14">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.140"></t>
<t tx="ekr.20201128164717.141">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.142">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.145"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

</t>
<t tx="ekr.20201128164717.146"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0:
        c.undoer.undo()
</t>
<t tx="ekr.20201128164717.147">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.148">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.149">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.15">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.150">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.151">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.152">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.153">first line
    line 1
last line
</t>
<t tx="ekr.20201128164717.154">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.155">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
</t>
<t tx="ekr.20201128164717.156">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.157">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.158">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.159">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.16">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.160">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.161">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.162">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.164">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.165">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.166">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.167">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.168">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.169">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.17">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.170">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.171">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.172">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.174">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.175">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.176">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.177">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.178">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.179">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.18">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.180">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.181">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.182">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.184">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.186">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.188">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.189">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.19">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.190">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.191">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.192">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.193">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.194">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.195">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.196">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.197">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.198">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.199">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.2"></t>
<t tx="ekr.20201128164717.20">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.200">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.202">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.204">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.205">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.206">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.207">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.208">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.209">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.21">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.210">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.211">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.212"># Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
</t>
<t tx="ekr.20201128164717.213"></t>
<t tx="ekr.20201128164717.214">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.215">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.216">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.217">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.218">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.219">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.22">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.220">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.221">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.222">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.223">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.224">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.225">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.226">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.227">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.228">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.229">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.23">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.230">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.231">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.232">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.233">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.234">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.235">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.236">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.237">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.238">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.239">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.24">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.240">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.241">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.242"></t>
<t tx="ekr.20201128164717.245"></t>
<t tx="ekr.20201128164717.246"></t>
<t tx="ekr.20201128164717.247"></t>
<t tx="ekr.20201128164717.248"></t>
<t tx="ekr.20201128164717.249"></t>
<t tx="ekr.20201128164717.25">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.250"></t>
<t tx="ekr.20201128164717.251">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.254">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.255">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.256">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.257">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.258">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.259">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.26">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.260">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.261">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.262">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.263">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.266">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.267">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.268">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.269">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.27">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.270">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.271">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.272">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.273">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.274">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.275">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.276">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.277">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.278">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.279">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.28">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.280">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.281">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.282">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.283">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.284">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.285">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.286">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.287">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.288">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.289">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.29">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.290">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.291">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.292">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.293">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.294">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.295">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.296">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.297">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.298">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.299">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
</t>
<t tx="ekr.20201128164717.3">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.30">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.300">result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
</t>
<t tx="ekr.20201128164717.301">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.302">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.303">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.304">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.305">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.306">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.308">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.309">c.editCommands.ccolumn = 4 # Set the comment column
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.31">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.310">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.311">first line
line b
last line
</t>
<t tx="ekr.20201128164717.312">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.313">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.314">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.315">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.316">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.317">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.318">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.319">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.32">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.320">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.321">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.322">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.323">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.324">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.325">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.326">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.327">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.328">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.329">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.33">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.330">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.331">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.332">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.333"># To do: use tables as in the clean-c test.
</t>
<t tx="ekr.20201128164717.334">child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20201128164717.335">@language python
def spam:
    pass
</t>
<t tx="ekr.20201128164717.336">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
if not sys.platform.startswith('win'):
    self.skipTest('Requires Windows')
trace = False
h = '@auto unittest/at-auto-md-line-number-test.md'
root = g.findNodeAnywhere(c, h)
assert root
s = c.gotoCommands.get_external_file_with_sentinels(root)
if trace:
    print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
for n in range(20):
    p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
    if found:
        if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
    else:
        if trace: print('not found: %s' % (n+1))
        assert n == 8, n
        break
</t>
<t tx="ekr.20201128164717.337"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.org'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.338"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.otl'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 5, n
            break
</t>
<t tx="ekr.20201128164717.339">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20201128164717.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.340"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
</t>
<t tx="ekr.20201128164717.341"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.342"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.343"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.344"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.345"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
</t>
<t tx="ekr.20201128164717.346">c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

</t>
<t tx="ekr.20201128164717.347"></t>
<t tx="ekr.20201128164717.348"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.349">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.350">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.351">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.352">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.353">line 1
line 2

</t>
<t tx="ekr.20201128164717.354">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.355">line 1
line 2

</t>
<t tx="ekr.20201128164717.356">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.357">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.358">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.359">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.36">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.360">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.361">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.362">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.363">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.364"></t>
<t tx="ekr.20201128164717.365"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.366">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.367">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.368">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.369">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.37">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.370">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.371">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.372">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.373">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.374">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.375">line 1
# The next line contains two trailing blanks.
line 3  
line 4
</t>
<t tx="ekr.20201128164717.376">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.377">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.378">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.379">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.38">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.380">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.381">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.382">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.383">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.384">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.385">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.386">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.387">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.388">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.389"></t>
<t tx="ekr.20201128164717.39">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.390">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.391">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.392">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.393">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.394">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.395">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.396">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.397">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.398"># Test of bug 799695: colorizer bug after move-lines-up into a docstring

# import os ; os.system('cls')

n = c.frame.body.colorizer.full_recolor_count

c.testManager.runEditCommandTest(p)

# Not an effective test, even though the bug fix was to call
# c.recolor_now(incremental=False)

# g.trace(n,c.frame.body.colorizer.full_recolor_count)

# assert c.frame.body.colorizer.full_recolor_count &gt; n
</t>
<t tx="ekr.20201128164717.399">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.4">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.40">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.400">@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
</t>
<t tx="ekr.20201128164717.401">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.402">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.403">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.404">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.405">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.406">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.407">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.408">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.409">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.41">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.410">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.411">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.412">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.413">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.414">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.415">a

b
</t>
<t tx="ekr.20201128164717.416">a

b
</t>
<t tx="ekr.20201128164717.417">a

b
</t>
<t tx="ekr.20201128164717.418">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.419">a

b
</t>
<t tx="ekr.20201128164717.42">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.420">a

b
</t>
<t tx="ekr.20201128164717.421">a

b
</t>
<t tx="ekr.20201128164717.422">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.423">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.424">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.425">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.426">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.427">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.428">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.429">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.43">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.430">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.431">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.432">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.433">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.434">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.435">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.436">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.437">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.438">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.439">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.44">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.440">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.441">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.442">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.443">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.444">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.445">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.446">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.447">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.448">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.449">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.45">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.450">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.451">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.452">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.453">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.454">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.455">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.456">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.457">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.458">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.459">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.46">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.460">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.461">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.462">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.463">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.464">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.465">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.466">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.467">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.468">a
d
e
z
x
</t>
<t tx="ekr.20201128164717.469">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.47">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.470">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.471">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.472">c
A
z
X
Y
b
</t>
<t tx="ekr.20201128164717.473">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.474">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = '(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉ©BE|cz):\n'
    u = '(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        binding = 'Return' if char == '\n' else char
        event = g.app.gui.create_key_event(c,char=char,binding=binding,w=w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20201128164717.475">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c, binding='Tab', char='\t', w=w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
</t>
<t tx="ekr.20201128164717.476"># xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
</t>
<t tx="ekr.20201128164717.477">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.478">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.479">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.48">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.480">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.481">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.482">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.483">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.484">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.485">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.486">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.487">x
z
A
c
B
</t>
<t tx="ekr.20201128164717.488">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.489">c.sortRecentFiles()
</t>
<t tx="ekr.20201128164717.49">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.490">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
</t>
<t tx="ekr.20201128164717.491"></t>
<t tx="ekr.20201128164717.492"></t>
<t tx="ekr.20201128164717.493"></t>
<t tx="ekr.20201128164717.494">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.495">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.496">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.497">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.498">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.499">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.5">first line
line 1
    line a
line b
last line
</t>
<t tx="ekr.20201128164717.50">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.500">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.501">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.502">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.503">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.504">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.505">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.506">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.507">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.508">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.509">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.51">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.510">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.511">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.512">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.513">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.514">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.515">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.516">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.517">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.518">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.519">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.52">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.520">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.521">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.522">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.523">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.524">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.525">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.526">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.527">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.528">first line
before bar2 += foo after
last line
</t>
<t tx="ekr.20201128164717.529">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.53">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.530">from leo.core import leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.531">@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength &gt;= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (&lt;any&gt;oldScope).leftCurlyCount or not (&lt;any&gt;oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(&lt;any&gt;oldScope).leftCurlyCount !==(&lt;any&gt;newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(&lt;any&gt;oldScope).rightCurlyCount !==(&lt;any&gt;newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
</t>
<t tx="ekr.20201128164717.532">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.533">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.534">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.535">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.536">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.537">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.538">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.539">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.54">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.540">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.541">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.542">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.543">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.544"></t>
<t tx="ekr.20201128164717.545"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.546">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.547">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.548">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.549"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.55">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.550">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.551">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.552">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.553"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.554">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.555">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.556">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.557"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.558">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.559">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.56">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.560">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.561"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.562">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.563">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.564">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.565"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.566">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.567">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.568">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.569"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.57">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.570">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.571">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.572">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.573"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.574">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.575">@pagewidth 40
'''
docstring.
more docstring.
'''
</t>
<t tx="ekr.20201128164717.576">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.577"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.578">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.579">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.58">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.580">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.581"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.582">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.583">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.584">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.585"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.586">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.587">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.588">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.589"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.59">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.590">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.591">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.592">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.593"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.594">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.595">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.596">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.597"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.598">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.599">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.6">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.60">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.600">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.601"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.602">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.603">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.604">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.605"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.606">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.607">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.608">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.609"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.61">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.610">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.611">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.612">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.613"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.614">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.615">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.616">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.617"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.618">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.619">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.62">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.620">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.621"></t>
<t tx="ekr.20201128164717.622">ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20201128164717.623">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20201128164717.624">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s &lt;%s&gt; expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,s,expected,result)
</t>
<t tx="ekr.20201128164717.625"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType='X')
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20201128164717.626"># A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
</t>
<t tx="ekr.20201128164717.627">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20201128164717.628"># start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
</t>
<t tx="ekr.20201128164717.629"># targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20201128164717.63">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.630">vr = c.helpCommands.helpForMinibuffer()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.631">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.632">ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.633">ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,w=w)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20201128164717.634">w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20201128164717.635"># These tests will be important when revising config code.
</t>
<t tx="ekr.20201128164717.636"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20201128164717.637"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
</t>
<t tx="ekr.20201128164717.638">line 1.
line 2(xxx).
line 3.
</t>
<t tx="ekr.20201128164717.639">if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20201128164717.64">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.640"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20201128164717.641">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.642">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.643">u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.644">u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.645">n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
</t>
<t tx="ekr.20201128164717.646">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w, 'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste, 'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, f"oops3 expected {h} got: {p.h}"
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.647">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.648">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.649">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.65">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.650">h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
</t>
<t tx="ekr.20201128164717.651">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.652">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')

k = c.k
if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        # char, shortcut.
        g.app.gui.event_generate(c,'X','Shift+X',w)
        g.app.gui.event_generate(c,'Y','Shift+Y',w)
        g.app.gui.event_generate(c,'Z','Shift+Z',w)
        g.app.gui.event_generate(c,'\n','Return',w)
        expected = h + 'XYZ'
        assert p.h == expected, f"oops 1: expected {expected!r} got {p.h!r}"
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, f"oops 2: expected {h!r} got {p.h!r}"
    finally:
        if 1:
            c.setHeadString(p, h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.653">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.654">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.655">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
</t>
<t tx="ekr.20201128164717.656"># Print does not work: it is redirected.
g.pr('\nEnd of typing tests')
</t>
<t tx="ekr.20201128164717.657"># Print does not work: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
</t>
<t tx="ekr.20201128164717.66">firstline
last line
</t>
<t tx="ekr.20201128164717.67">first line
last line
</t>
<t tx="ekr.20201128164717.68">firstline
last line
</t>
<t tx="ekr.20201128164717.69">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.70">first line
last lin
</t>
<t tx="ekr.20201128164717.71">first line
last line
</t>
<t tx="ekr.20201128164717.72">first line
last lin
</t>
<t tx="ekr.20201128164717.73">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.74">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.75">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.76">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.77">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.78">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.79">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.8">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.80">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.81">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.82">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.83">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.84">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.85">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.86">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.87">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.88">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.89">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.9">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.90">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.91">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.92">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.93">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.95">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.96">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.97">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.98">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.99">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128165500.1">"""Convert old-style tests to new-style tests"""
g.cls()
import importlib
from leo.core import leoTest2
importlib.reload(leoTest2)

root = g.findTopLevelNode(c, 'unit-tests: leoEditCommands')
target = g.findTopLevelNode(c, 'new-tests')
if root and target:
    leoTest2.convert_leoEditCommands_tests(c, root, target)
else:
    print('Error: root and target nodes must be top-level nodes.')</t>
<t tx="ekr.20201128171127.1"></t>
<t tx="ekr.20201129132149.1"></t>
<t tx="ekr.20201130074836.1">def convert_leoEditCommands_tests(c, root, target):
    """
    Convert @test nodes to new-style tests.
    
    root:   A node containing (a copy of) tests from unitTest.leo.
    target: A node whose children will be the resulting tests.
            These nodes can then be copied to be children of a test class.
    """
    if not root or not target:
        print('Error: root and target nodes must be top-level nodes.', color='red')
        return
    # Be safe.
    if target.hasChildren():
        print('Please delete children of ', target.h, color='red')
        return
    converter = ConvertEditCommandsTests()
    count = 0
    for p in root.subtree():
        if p.h.startswith('@test') and 'runEditCommandTest' in p.b:
            converter.convert(p, target)
            count += 1
    c.redraw()
    print(f"converted {count} @test nodes", color='blue')
</t>
<t tx="ekr.20201130195111.1">def create_app():
    """
    Create the Leo application, g.app, the Gui, g.app.gui, and a commander.
    
    This method is expensive (about 1 sec) only the first time it is called.
    
    Thereafter, recreating g.app, g.app.gui, and new commands is fast.
    """
    # dump_leo_modules()
    t1 = time.process_time()
    from leo.core import leoGlobals as g
    from leo.core import leoApp
    from leo.core import leoConfig
    from leo.core import leoNodes
    from leo.core import leoCommands
    from leo.core import leoGui
    t2 = time.process_time()
    g.app = leoApp.LeoApp()
    g.app.recentFilesManager = leoApp.RecentFilesManager()
    g.app.loadManager = leoApp.LoadManager()
    g.app.loadManager.computeStandardDirectories()
    if not g.app.setLeoID(useDialog=False, verbose=True):
        raise ValueError("unable to set LeoID.")
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.db = g.TracingNullObject('g.app.db')
    g.app.pluginsController = g.NullObject('g.app.pluginsController')
    g.app.commander_cacher = g.NullObject('g.app.commander_cacher')
    g.app.gui=leoGui.NullGui()
    t3 = time.process_time()
    # Create a dummy commander, to do the imports in c.initObjects.
    c = leoCommands.Commands(fileName=None, gui=g.app.gui)
    # dump_leo_modules()
    t4 = time.process_time()
    if False and t4 - t3 &gt; 0.1:
        print('create_app\n'
            f"  imports: {(t2-t1):.3f}\n"
            f"      gui: {(t3-t2):.3f}\n"
            f"commander: {(t4-t2):.3f}\n"
            f"    total: {(t4-t1):.3f}\n")
    return c
</t>
<t tx="ekr.20201202085332.1">def test_add_space_to_lines(self):
    """Test case for add-space-to-lines"""
    before_b = """\
first line
line 1
    line a
line b
last line
"""
    after_b = """\
first line
 line 1
     line a
 line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "4.6"),
        after_sel=("2.0", "4.7"),
        command_name="add-space-to-lines",
    )
</t>
<t tx="ekr.20201202085332.10">def test_back_to_home_at_start_of_line(self):
    """Test case for back-to-home (at start of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.100">def test_rectangle_yank(self):
    """Test case for rectangle-yank"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-yank",
    )
</t>
<t tx="ekr.20201202085332.101">def test_remove_blank_lines(self):
    """Test case for remove-blank-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "6.9"),
        command_name="remove-blank-lines",
    )
</t>
<t tx="ekr.20201202085332.102">def test_remove_space_from_lines(self):
    """Test case for remove-space-from-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line

line 1
   line a
       line b

line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "9.0"),
        command_name="remove-space-from-lines",
    )
</t>
<t tx="ekr.20201202085332.103">def test_remove_tab_from_lines(self):
    """Test case for remove-tab-from-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="remove-tab-from-lines",
    )
</t>
<t tx="ekr.20201202085332.104">def test_reverse_region(self):
    """Test case for reverse-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\

last line
line c
        line b
    line a
line 1
first line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.10", "7.10"),
        command_name="reverse-region",
    )
</t>
<t tx="ekr.20201202085332.105">def test_reverse_sort_lines(self):
    """Test case for reverse-sort-lines"""
    before_b = """\
a
d
e
z
x
"""
    after_b = """\
z
x
e
d
a
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="reverse-sort-lines",
    )
</t>
<t tx="ekr.20201202085332.106">def test_reverse_sort_lines_ignoring_case(self):
    """Test case for reverse-sort-lines-ignoring-case"""
    before_b = """\
c
A
z
X
Y
b
"""
    after_b = """\
z
Y
X
c
b
A
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.1"),
        after_sel=("1.0", "6.1"),
        command_name="reverse-sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.107">def test_sort_columns(self):
    """Test case for sort-columns"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
        line b
    line a
first line
last line
line 1
line c
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.2"),
        after_sel=("1.0", "7.0"),
        command_name="sort-columns",
    )
</t>
<t tx="ekr.20201202085332.108">def test_sort_lines(self):
    """Test case for sort-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
        line b
    line a
line 1
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.6"),
        command_name="sort-lines",
    )
</t>
<t tx="ekr.20201202085332.109">def test_sort_lines_ignoring_case(self):
    """Test case for sort-lines-ignoring-case"""
    before_b = """\
x
z
A
c
B
"""
    after_b = """\
A
B
c
x
z
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.11">def test_back_to_home_at_indentation(self):
    """Test case for back-to-home (at indentation"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "2.4"),
        after_sel=("2.0", "2.0"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.110">def test_split_line(self):
    """Test case for split-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first
 line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("2.0", "2.0"),
        command_name="split-line",
    )
</t>
<t tx="ekr.20201202085332.111">def test_start_of_line(self):
    """Test case for start-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.112">def test_start_of_line_2(self):
    """Test case for start-of-line (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.113">def test_start_of_line_extend_selection(self):
    """Test case for start-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.10"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.114">def test_start_of_line_extend_selection_2(self):
    """Test case for start-of-line-extend-selection (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.4"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.115">def test_tabify(self):
    """Test case for tabify"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="tabify",
    )
</t>
<t tx="ekr.20201202085332.116">def test_transpose_chars(self):
    """Test case for transpose-chars"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
frist line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.2", "1.2"),
        command_name="transpose-chars",
    )
</t>
<t tx="ekr.20201202085332.117">def test_transpose_lines(self):
    """Test case for transpose-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.10", "2.10"),
        command_name="transpose-lines",
    )
</t>
<t tx="ekr.20201202085332.118">def test_transpose_words(self):
    """Test case for transpose-words"""
    before_b = """\
first line
before bar2 += foo after
last line
"""
    after_b = """\
first line
before foo += bar2 after
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.11", "2.11"),
        command_name="transpose-words",
    )
</t>
<t tx="ekr.20201202085332.119">def test_untabify(self):
    """Test case for untabify"""
    before_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="untabify",
    )
</t>
<t tx="ekr.20201202085332.12">def test_back_to_home_at_end_of_line(self):
    """Test case for back-to-home (at end of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.12", "2.12"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.120">def test_upcase_region(self):
    """Test case for upcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="upcase-region",
    )
</t>
<t tx="ekr.20201202085332.121">def test_upcase_word(self):
    """Test case for upcase-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    LINE a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.7"),
        command_name="upcase-word",
    )
</t>
<t tx="ekr.20201202085332.122">def test_reformat_paragraph_list_1_of_5(self):
    """Test case for reformat-paragraph list 1 of 5"""
    before_b = """\
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.123">def test_reformat_paragraph_list_2_of_5(self):
    """Test case for reformat-paragraph list 2 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.0", "4.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.124">def test_reformat_paragraph_list_3_of_5(self):
    """Test case for reformat-paragraph list 3 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("10.0", "10.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.125">def test_reformat_paragraph_list_4_of_5(self):
    """Test case for reformat-paragraph list 4 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.126">def test_reformat_paragraph_list_5_of_5(self):
    """Test case for reformat-paragraph list 5 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("15.1", "15.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.127">def test_reformat_paragraph_new_code_1_of_8(self):
    """Test case for reformat-paragraph new code 1 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("2.0", "2.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.128">def test_reformat_paragraph_new_code_2_of_8(self):
    """Test case for reformat-paragraph new code 2 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.129">def test_reformat_paragraph_new_code_3_of_8(self):
    """Test case for reformat-paragraph new code 3 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
more docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring. more docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "4.1"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.13">def test_back_word(self):
    """Test case for back-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.183", "1.183"),
        after_sel=("1.178", "1.178"),
        command_name="back-word",
    )
</t>
<t tx="ekr.20201202085332.130">def test_reformat_paragraph_new_code_4_of_8(self):
    """Test case for reformat-paragraph new code 4 of 8"""
    before_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.131">def test_reformat_paragraph_new_code_5_of_8(self):
    """Test case for reformat-paragraph new code 5 of 8"""
    before_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.132">def test_reformat_paragraph_new_code_6_of_8(self):
    """Test case for reformat-paragraph new code 6 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.133">def test_reformat_paragraph_new_code_7_of_8(self):
    """Test case for reformat-paragraph new code 7 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.11", "2.11"),
        after_sel=("3.1", "3.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.134">def test_reformat_paragraph_new_code_8_of_8(self):
    """Test case for reformat-paragraph new code 8 of 8"""
    before_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.135">def test_reformat_paragraph_paragraph_1_of_3(self):
    """Test case for reformat-paragraph paragraph 1 of 3"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.136">def test_reformat_paragraph_paragraph_2_of_3(self):
    """Test case for reformat-paragraph paragraph 2 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("25.0", "25.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.137">def test_reformat_paragraph_paragraph_3_of_3(self):
    """Test case for reformat-paragraph paragraph 3 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("25.10", "25.10"),
        after_sel=("34.0", "34.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.138">def test_reformat_paragraph_simple_hanging_indent(self):
    """Test case for reformat-paragraph simple hanging indent"""
    before_b = """\
Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.139">def test_reformat_paragraph_simple_hanging_indent_2(self):
    """Test case for reformat-paragraph simple hanging indent 2"""
    before_b = """\
Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.14">def test_back_word_extend_selection(self):
    """Test case for back-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.342", "3.342"),
        after_sel=("3.332", "3.342"),
        command_name="back-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.140">def test_reformat_paragraph_simple_hanging_indent_3(self):
    """Test case for reformat-paragraph simple hanging indent 3"""
    before_b = """\
Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.15">def test_backward_delete_char(self):
    """Test case for backward-delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first lie
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.9", "1.9"),
        after_sel=("1.8", "1.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.16">def test_backward_delete_char__middle_of_line(self):
    """Test case for backward-delete-char  (middle of line)"""
    before_b = """\
first line
last line
"""
    after_b = """\
firstline
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.6", "1.6"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.17">def test_backward_delete_char_last_char(self):
    """Test case for backward-delete-char (last char)"""
    before_b = """\
first line
last line
"""
    after_b = """\
first line
last lin
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.8", "2.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.18">def test_backward_delete_word_no_selection(self):
    """Test case for backward-delete-word (no selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa cccc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.19">def test_backward_delete_word_selection(self):
    """Test case for backward-delete-word (selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa bbcc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.7", "1.12"),
        after_sel=("1.7", "1.7"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.2">def test_add_tab_to_lines(self):
    """Test case for add-tab-to-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
    line 1
        line a
            line b
    line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.10"),
        command_name="add-tab-to-lines",
    )
</t>
<t tx="ekr.20201202085332.20">def test_backward_kill_paragraph(self):
    """Test case for backward-kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("7.0", "7.0"),
        command_name="backward-kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.21">def test_backward_kill_sentence(self):
    """Test case for backward-kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("2.23", "2.23"),
        command_name="backward-kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.22">def test_backward_kill_word(self):
    """Test case for backward-kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.5", "3.5"),
        command_name="backward-kill-word",
    )
</t>
<t tx="ekr.20201202085332.23">def test_beginning_of_buffer(self):
    """Test case for beginning-of-buffer"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.56", "5.56"),
        after_sel=("1.0", "1.0"),
        command_name="beginning-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.24">def test_beginning_of_buffer_extend_selection(self):
    """Test case for beginning-of-buffer-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.423", "3.423"),
        after_sel=("1.0", "3.423"),
        command_name="beginning-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.25">def test_beginning_of_line(self):
    """Test case for beginning-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.0", "3.0"),
        command_name="beginning-of-line",
    )
</t>
<t tx="ekr.20201202085332.26">def test_beginning_of_line_extend_selection(self):
    """Test case for beginning-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.10", "4.10"),
        after_sel=("4.0", "4.10"),
        command_name="beginning-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.27">def test_capitalize_word(self):
    """Test case for capitalize-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    Line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="capitalize-word",
    )
</t>
<t tx="ekr.20201202085332.28">def test_center_line(self):
    """Test case for center-line"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "9.0"),
        after_sel=("3.0", "9.0"),
        command_name="center-line",
    )
</t>
<t tx="ekr.20201202085332.29">def test_center_region(self):
    """Test case for center-region"""
    before_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    after_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="center-region",
    )
</t>
<t tx="ekr.20201202085332.3">def test_back_char(self):
    """Test case for back-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.8", "3.8"),
        after_sel=("3.7", "3.7"),
        command_name="back-char",
    )
</t>
<t tx="ekr.20201202085332.30">def test_clean_lines(self):
    """Test case for clean-lines"""
    before_b = """\
# Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
"""
    after_b = """\
# Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="clean-lines",
    )
</t>
<t tx="ekr.20201202085332.31">def test_clear_selected_text(self):
    """Test case for clear-selected-text"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.4"),
        after_sel=("2.4", "2.4"),
        command_name="clear-selected-text",
    )
</t>
<t tx="ekr.20201202085332.32">def test_count_region(self):
    """Test case for count-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.8"),
        after_sel=("2.4", "4.8"),
        command_name="count-region",
    )
</t>
<t tx="ekr.20201202085332.33">def test_delete_char(self):
    """Test case for delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
firstline
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.5", "1.5"),
        command_name="delete-char",
    )
</t>
<t tx="ekr.20201202085332.34">def test_delete_indentation(self):
    """Test case for delete-indentation"""
    before_b = """\
first line
    line 1
last line
"""
    after_b = """\
first line
line 1
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.8", "2.8"),
        after_sel=("2.4", "2.4"),
        command_name="delete-indentation",
    )
</t>
<t tx="ekr.20201202085332.35">def test_delete_spaces(self):
    """Test case for delete-spaces"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("3.0", "3.0"),
        command_name="delete-spaces",
    )
</t>
<t tx="ekr.20201202085332.36">def test_do_nothing(self):
    """Test case for do-nothing"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="do-nothing",
    )
</t>
<t tx="ekr.20201202085332.37">def test_downcase_region(self):
    """Test case for downcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="downcase-region",
    )
</t>
<t tx="ekr.20201202085332.38">def test_downcase_word(self):
    """Test case for downcase-word"""
    before_b = """\
XYZZY line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
xyzzy line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.4", "1.4"),
        after_sel=("1.4", "1.4"),
        command_name="downcase-word",
    )
</t>
<t tx="ekr.20201202085332.39">def test_end_of_buffer(self):
    """Test case for end-of-buffer"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.3", "1.3"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.4">def test_back_char_extend_selection(self):
    """Test case for back-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.12", "4.12"),
        after_sel=("4.11", "4.12"),
        command_name="back-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.40">def test_end_of_buffer_extend_selection(self):
    """Test case for end-of-buffer-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "7.0"),
        command_name="end-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.41">def test_end_of_line(self):
    """Test case for end-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.10", "1.10"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.42">def test_end_of_line_2(self):
    """Test case for end-of-line 2"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("6.0", "6.0"),
        after_sel=("6.9", "6.9"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.43">def test_end_of_line_internal_blank_line(self):
    """Test case for end-of-line (internal blank line)"""
    before_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.0", "2.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.44">def test_end_of_line_blank_last_line(self):
    """Test case for end-of-line (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.45">def test_end_of_line_single_char_last_line(self):
    """Test case for end-of-line (single char last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.1", "7.1"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.46">def test_end_of_line_extend_selection(self):
    """Test case for end-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.10"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.47">def test_end_of_line_extend_selection_blank_last_line(self):
    """Test case for end-of-line-extend-selection (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.48">def test_exchange_point_mark(self):
    """Test case for exchange-point-mark"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.10"),
        after_sel=("1.0", "1.10"),
        command_name="exchange-point-mark",
    )
</t>
<t tx="ekr.20201202085332.49">def test_extend_to_line(self):
    """Test case for extend-to-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "3.3"),
        after_sel=("3.0", "3.10"),
        command_name="extend-to-line",
    )
</t>
<t tx="ekr.20201202085332.5">def test_back_paragraph(self):
    """Test case for back-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("6.7", "6.7"),
        command_name="back-paragraph",
    )
</t>
<t tx="ekr.20201202085332.50">def test_extend_to_paragraph(self):
    """Test case for extend-to-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "13.33"),
        command_name="extend-to-paragraph",
    )
</t>
<t tx="ekr.20201202085332.51">def test_extend_to_sentence(self):
    """Test case for extend-to-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("1.395", "3.142"),
        command_name="extend-to-sentence",
    )
</t>
<t tx="ekr.20201202085332.52">def test_extend_to_word(self):
    """Test case for extend-to-word"""
    before_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.12"),
        command_name="extend-to-word",
    )
</t>
<t tx="ekr.20201202085332.53">def test_finish_of_line(self):
    """Test case for finish-of-line"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.12", "3.12"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.54">def test_finish_of_line_2(self):
    """Test case for finish-of-line (2)"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.55">def test_finish_of_line_extend_selection(self):
    """Test case for finish-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.9"),
        command_name="finish-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.56">def test_fill_paragraph(self):
    """Test case for fill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.7"),
        after_sel=("10.0", " 10.0"),
        command_name="fill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.57">def test_forward_char(self):
    """Test case for forward-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.3", "1.3"),
        command_name="forward-char",
    )
</t>
<t tx="ekr.20201202085332.58">def test_forward_char_extend_selection(self):
    """Test case for forward-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("1.1", "1.2"),
        command_name="forward-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.59">def test_forward_end_word_end_of_line(self):
    """Test case for forward-end-word (end of line)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("3.4", "3.4"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.6">def test_back_paragraph_extend_selection(self):
    """Test case for back-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.5"),
        after_sel=("6.7", "9.5"),
        command_name="back-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.60">def test_forward_end_word_start_of_word(self):
    """Test case for forward-end-word (start of word)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.310", "1.310"),
        after_sel=("1.317", "1.317"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.61">def test_forward_end_word_extend_selection(self):
    """Test case for forward-end-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.20", "3.20"),
        after_sel=("3.20", "3.30"),
        command_name="forward-end-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.62">def test_forward_paragraph(self):
    """Test case for forward-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("15.0", "15.0"),
        command_name="forward-paragraph",
    )
</t>
<t tx="ekr.20201202085332.63">def test_forward_paragraph_extend_selection(self):
    """Test case for forward-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("10.0", "15.0"),
        command_name="forward-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.64">def test_forward_sentence(self):
    """Test case for forward-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.17", "3.17"),
        after_sel=("3.142", "3.142"),
        command_name="forward-sentence",
    )
</t>
<t tx="ekr.20201202085332.65">def test_forward_sentence_extend_selection(self):
    """Test case for forward-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.264", "1.264"),
        after_sel=("1.264", "1.395"),
        command_name="forward-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.66">def test_forward_word(self):
    """Test case for forward-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.261", "1.261"),
        after_sel=("1.272", "1.272"),
        command_name="forward-word",
    )
</t>
<t tx="ekr.20201202085332.67">def test_forward_word_extend_selection(self):
    """Test case for forward-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("1.395", "3.4"),
        command_name="forward-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.68">def test_indent_relative(self):
    """Test case for indent-relative"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
        line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.0", "5.0"),
        after_sel=("5.8", "5.8"),
        command_name="indent-relative",
    )
</t>
<t tx="ekr.20201202085332.69">def test_indent_rigidly(self):
    """Test case for indent-rigidly"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
	line 1
	    line a
	        line b
	line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.0"),
        after_sel=("2.0", "5.1"),
        command_name="indent-rigidly",
    )
</t>
<t tx="ekr.20201202085332.7">def test_back_sentence(self):
    """Test case for back-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.169", "3.169"),
        after_sel=("3.143", "3.143"),
        command_name="back-sentence",
    )
</t>
<t tx="ekr.20201202085332.70">def test_indent_to_comment_column(self):
    """Test case for indent-to-comment-column"""
    before_b = """\
first line
line b
last line
"""
    after_b = """\
first line
    line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="indent-to-comment-column",
    )
</t>
<t tx="ekr.20201202085332.71">def test_insert_newline(self):
    """Test case for insert-newline"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first li
ne
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.8", "1.8"),
        after_sel=("2.0", "2.0"),
        command_name="insert-newline",
    )
</t>
<t tx="ekr.20201202085332.72">def test_insert_parentheses(self):
    """Test case for insert-parentheses"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first() line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.6", "1.6"),
        command_name="insert-parentheses",
    )
</t>
<t tx="ekr.20201202085332.73">def test_kill_paragraph(self):
    """Test case for kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "8.0"),
        command_name="kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.74">def test_kill_sentence(self):
    """Test case for kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.27", "1.27"),
        command_name="kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.75">def test_kill_word(self):
    """Test case for kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.7", "2.7"),
        command_name="kill-word",
    )
</t>
<t tx="ekr.20201202085332.76">def test_kill_line_end_body_text(self):
    """Test case for kill-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.77">def test_kill_line_end_line_text(self):
    """Test case for kill-line end-line-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2

"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.78">def test_kill_line_start_line(self):
    """Test case for kill-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.79">def test_kill_line_start_blank_line(self):
    """Test case for kill-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.8">def test_back_sentence_extend_selection(self):
    """Test case for back-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.208", "3.208"),
        after_sel=("3.143", "3.208"),
        command_name="back-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.80">def test_kill_to_end_of_line_end_body_text(self):
    """Test case for kill-to-end-of-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.81">def test_kill_to_end_of_line_end_line(self):
    """Test case for kill-to-end-of-line end-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.6", "2.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.82">def test_kill_to_end_of_line_after_last_visible_char(self):
    """Test case for kill-to-end-of-line after last visible char"""
    before_b = """\
line 1
# The next line contains two trailing blanks.
line 3  
line 4
"""
    after_b = """\
line 1
# The next line contains two trailing blanks.
line 3line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.83">def test_kill_to_end_of_line_start_line(self):
    """Test case for kill-to-end-of-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.84">def test_kill_to_end_of_line_start_blank_line(self):
    """Test case for kill-to-end-of-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.85">def test_kill_to_end_of_line_middle_line(self):
    """Test case for kill-to-end-of-line middle-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
li
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.2", "2.2"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.86">def test_move_lines_down(self):
    """Test case for move-lines-down"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line c
    line a
        line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "4.3"),
        after_sel=("4.3", "5.3"),
        command_name="move-lines-down",
    )
</t>
<t tx="ekr.20201202085332.87">def test_move_lines_up(self):
    """Test case for move-lines-up"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.2", "1.2"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.88">def test_move_lines_up_into_docstring(self):
    """Test case for move-lines-up (into docstring)"""
    before_b = '''\
@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
'''
    after_b = '''\
@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
'''
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.1", "7.1"),
        after_sel=("6.1", "6.1"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.89">def test_move_past_close(self):
    """Test case for move-past-close"""
    before_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.12", "1.12"),
        command_name="move-past-close",
    )
</t>
<t tx="ekr.20201202085332.9">def test_back_to_indentation(self):
    """Test case for back-to-indentation"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.13", "4.13"),
        after_sel=("4.8", "4.8"),
        command_name="back-to-indentation",
    )
</t>
<t tx="ekr.20201202085332.90">def test_move_past_close_extend_selection(self):
    """Test case for move-past-close-extend-selection"""
    before_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.11"),
        command_name="move-past-close-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.91">def test_newline_and_indent(self):
    """Test case for newline-and-indent"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("3.4", "3.4"),
        command_name="newline-and-indent",
    )
</t>
<t tx="ekr.20201202085332.92">def test_next_line(self):
    """Test case for next-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("2.0", "2.0"),
        command_name="next-line",
    )
</t>
<t tx="ekr.20201202085332.93">def test_previous_line(self):
    """Test case for previous-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("2.0", "2.0"),
        command_name="previous-line",
    )
</t>
<t tx="ekr.20201202085332.94">def test_rectangle_clear(self):
    """Test case for rectangle-clear"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-clear",
    )
</t>
<t tx="ekr.20201202085332.95">def test_rectangle_close(self):
    """Test case for rectangle-close"""
    before_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-close",
    )
</t>
<t tx="ekr.20201202085332.96">def test_rectangle_delete(self):
    """Test case for rectangle-delete"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-delete",
    )
</t>
<t tx="ekr.20201202085332.97">def test_rectangle_kill(self):
    """Test case for rectangle-kill"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("5.3", "5.3"),
        command_name="rectangle-kill",
    )
</t>
<t tx="ekr.20201202085332.98">def test_rectangle_open(self):
    """Test case for rectangle-open"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-open",
    )
</t>
<t tx="ekr.20201202085332.99">def test_rectangle_string(self):
    """Test case for rectangle-string"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.8"),
        command_name="rectangle-string",
    )
</t>
<t tx="ekr.20201202112206.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1763

@language python
@nosearch
</t>
<t tx="ekr.20201202144529.1"></t>
<t tx="ekr.20201203045146.1">import os
g.cls()
cwd = os.getcwd()
os.system('leo-unittest')
os.chdir(cwd)</t>
<t tx="ekr.20201203081649.1"></t>
<t tx="ekr.20201203114411.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1766

@language python
@nosearch
</t>
<t tx="ekr.20201204104619.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1768

@language python
@nosearch

</t>
<t tx="ekr.20201204172235.1">leo_cursor_width = 0

leo_vim_mode = None

def paintEvent(self, event):
    """
    LeoQTextBrowser.paintEvent.
    
    New in Leo 6.4: Draw a box around the cursor in command mode.
                    This is as close as possible to vim's look.
    """
    c, vc, w = self.leo_c, self.leo_c.vimCommands, self
    #
    # First, call the base class paintEvent.
    QtWidgets.QTextBrowser.paintEvent(self, event)
    
    def set_cursor_width(width):
        """Set the cursor width, but only if necessary."""
        if self.leo_cursor_width != width:
            self.leo_cursor_width = width
            w.setCursorWidth(width)
    
    #
    # Are we in vim mode?
    if self.leo_vim_mode is None:
        self.leo_vim_mode = c.config.getBool('vim-mode', default=False)
    #
    # Are we in command mode?
    if self.leo_vim_mode:
        in_command = vc and vc.state == 'normal'  # vim mode.
    else:
        in_command = c.k.unboundKeyAction == 'command'  # vim emulation.
    #
    # Draw the box only in command mode, when w is the body pane, with focus.
    if (
        not in_command
        or w != c.frame.body.widget
        or w != g.app.gui.get_focus()
    ):
        set_cursor_width(c.config.getInt('qt-cursor-width') or 1)
        return
    #
    # Set the width of the cursor.
    font = w.currentFont()
    cursor_width = QtGui.QFontMetrics(font).averageCharWidth()
    set_cursor_width(cursor_width)
    #
    # Draw a box around the cursor.
    qp = QtGui.QPainter()
    qp.begin(self.viewport())
    qp.drawRect(w.cursorRect())
    qp.end()
</t>
<t tx="ekr.20201205182226.1"></t>
<t tx="ekr.20201205203155.1"></t>
<t tx="ekr.20201207055200.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1240

@language python
@nosearch
</t>
<t tx="ekr.20201207055713.1">def idle_check_leo_file(self, c):
    """Check c's .leo file for external changes."""
    path = c.fileName()
    if not self.has_changed(path):
        return
    #
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
    if self.ask(c, path):
        # Do a complete restart of Leo.
        g.es_print('restarting Leo...')
        c.restartLeo()
</t>
<t tx="ekr.20201207084531.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1772

Added gdc.diff_pull_request.

@language python
@nosearch
</t>
<t tx="ekr.20201208114431.1">def diff_pull_request(self, branch_name, base_branch_name='devel', directory=None):
    """
    Create a Leonine version of the diffs that would be
    produced by a pull request between two branches.
    """
    if not directory:
        directory = os.path.join(g.app.loadDir, '..', '..')
    aList = g.execGitCommand(f"git rev-parse devel", directory)
    if aList:
        devel_rev = aList[0]
        devel_rev = devel_rev[:8]
        self.diff_two_revs(
            rev1=devel_rev,  # Before: Latest devel commit.
            rev2='HEAD',     # After: Lastest branch commit
            directory=directory,
        )
    else:
        g.es_print('FAIL: git rev-parse devel')
</t>
<t tx="ekr.20201208114843.1"># No longer needed. Use the git-diff-pr command.
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request()
</t>
<t tx="ekr.20201210081319.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1775

Just remove the branch_name arg to gdc.diff_pull_request

@language python
@nosearch
</t>
<t tx="ekr.20201210120346.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1777

@language python
@nosearch
</t>
<t tx="ekr.20201210123153.1"></t>
<t tx="ekr.20201211164320.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1780

@language python
@nosearch
</t>
<t tx="ekr.20201211182659.1">def standard_timestamp():
    """Return a reasonable timestamp."""
    return time.strftime("%Y%m%d-%H%M%S")
</t>
<t tx="ekr.20201211182722.1"></t>
<t tx="ekr.20201211183100.1">def get_backup_path(sub_directory):
    """
    Return the full path to the subdirectory of the main backup directory.
    
    The main backup directory is computed as follows:
        
    1. os.environ['LEO_BACKUP']
    2. ~/Backup
    """
    # Compute the main backup directory.
    # First, try the LEO_BACKUP directory.
    backup = None
    try:
        backup = os.environ['LEO_BACKUP']
        if not os.path.exists(backup):
            backup = None
    except KeyError:
        pass
    except Exception:
        g.es_exception()
    # Second, try ~/Backup.
    if not backup:
        backup = os.path.join(str(Path.home()), 'Backup')
        if not os.path.exists(backup):
            backup = None
    if not backup:
        return None
    # Compute the path to backup/sub_directory
    directory = os.path.join(backup, sub_directory)
    return directory if os.path.exists(directory) else None
</t>
<t tx="ekr.20201212090129.1"></t>
<t tx="ekr.20201212091359.1">@language rest
@wrap

Leonine diffs of .leo files
https://github.com/leo-editor/leo-editor/issues/1781

@language python
@nosearch
</t>
<t tx="ekr.20201212175532.1"></t>
<t tx="ekr.20201213055506.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes</t>
<t tx="ekr.20201213172138.1">@language rest
@wrap

https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging

Stage 1 is the common ancestor,
stage 2 is your version 
stage 3 is from the MERGE_HEAD, the version you’re merging in (“theirs”).

You can extract a copy of each of these versions of the conflicted file with the git show command:

$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb

</t>
<t tx="ekr.20201214173524.1"></t>
<t tx="ekr.20201214185152.1"># https://github.com/leo-editor/leo-editor/issues/1781
# g.cls()
from leo.commands import editFileCommands
import importlib
importlib.reload(efc)
fn = 'git_diff_test.leo'
rev1, rev2 = '1ae08a66', 'HEAD'  # 'HEAD@{1}', 'HEAD@{0}'
x = efc.GitDiffController(c)
x.set_directory(None)
x.root = x.create_root(rev1, rev2)
x.diff_file(fn, rev1=rev1, rev2=rev2)
c.redraw()
</t>
<t tx="ekr.20201215050832.1">def make_leo_outline(self, fn, path, s, rev):
    """Create a hidden temp outline for the .leo file in s."""
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    hidden_c.fileCommands.getLeoFile(
        theFile=g.FileLikeObject(fromString=s),
        fileName=path,
        readAtFileNodesFlag=False,
        silent=False,
        checkOpenFiles=False,
    )
    return hidden_c
</t>
<t tx="ekr.20201215093414.1">@cmd('git-diff-pull-request')
@cmd('git-diff-pr')
def gitDiffPullRequest(self, event=None):
    """
    Produce a Leonine diff of pull request in the current branch.
    """
    GitDiffController(c=self.c).diff_pull_request()
</t>
<t tx="ekr.20201215145115.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1783

@font-size-tree

@language python
@nosearch
</t>
<t tx="ekr.20201216061006.1">@nosearch

# flattened, ignore-case, head, body

# found 4 nodes</t>
<t tx="ekr.20201216061211.1"></t>
<t tx="ekr.20201217144708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1788

@language python
@nosearch
</t>
<t tx="ekr.20201218161308.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1790

@language python
@nosearch
</t>
<t tx="ekr.20201221061215.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1792

@language python
@nosearch
</t>
<t tx="ekr.20201221071542.1"></t>
<t tx="ekr.20201222095250.1">g.cls()
import glob
import os
theme_dir = os.path.join(g.app.loadDir, '..', 'themes')
assert os.path.exists(theme_dir), repr(theme_dir)
paths = glob.glob(f"{theme_dir}{os.sep}*.leo")

def clean(s):
    return s.strip().replace('-','').replace('_','').replace(' ','')
    
for path in paths:
    d = {}
    c = g.createHiddenCommander(path)
    sfn = c.shortFileName()
    if sfn == 'old_themes.leo':
        continue
    print('checking ', sfn)
    for p in c.all_unique_positions():
        h = clean(p.h)
        if h.startswith('@'):
            if h in d:
                print(f"  {sfn:20}: duplicate {h}")
            else:
                d [h] = True
print('done')</t>
<t tx="ekr.20201228103916.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1798

Note: Leo can not recognize @path directives in the body text of @file nodes!

@language python
@nosearch
</t>
<t tx="ekr.20201228104039.1"></t>
<t tx="ekr.20201228113135.1"></t>
<t tx="ekr.20210103092453.1"></t>
<t tx="ekr.20210103095019.1"># Called using if __name__ == '__main__'.</t>
<t tx="ekr.20210103130324.1"></t>
<t tx="ekr.20210103130403.1"></t>
<t tx="ekr.20210103130436.1"></t>
<t tx="ekr.20210103192132.1"></t>
<t tx="ekr.20210103192210.1">
 if 0:  # #1342: These are no longer needed, because there are no buttons.
    table = (
        ('findNextCommand', 'find-next'),
        ('findPrevCommand', 'find-prev'),
        ('findAll', 'find-all'),
        ('changeCommand', 'replace'),
        ('changeThenFind', 'replace-then-find'),
        ('changeAll', 'replace-all'),
    )
    for func_name, cmd_name in table:
        ivar = f"{cmd_name}-{'button'}"
        ivar = ivar.replace('-', '_')
        w = getattr(ftm, ivar, None)
        func = getattr(fc, func_name, None)
        if w and func:
            next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
            EventWrapper(c, w=w, next_w=next_w, func=func)
        else:
            g.trace('**oops**')</t>
<t tx="ekr.20210103222604.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1801

PR: https://github.com/leo-editor/leo-editor/pull/1803

@language python
@nosearch
</t>
<t tx="ekr.20210104122029.1">def getYScrollPosition(self):
    return 0  # #1801.
</t>
<t tx="ekr.20210104122304.1"></t>
<t tx="ekr.20210104122316.1"></t>
<t tx="ekr.20210104123442.1">@g.commander_command('indent-region')
def indentBody(self, event=None):
    """
    The indent-region command indents each line of the selected body text.
    Unlike the always-indent-region command, this command inserts a tab
    (soft or hard) when there is no selected text.
    
    The @tabwidth directive in effect determines amount of indentation.
    """
    c, event_w, w = self, event and event.w, self.frame.body.wrapper
    # #1801: Don't rely on bindings to ensure that we are editing the body.
    if event_w != w:
        c.insertCharFromEvent(event)
        return
    # # 1739. Special case for a *plain* tab bound to indent-region.
    sel_1, sel_2 = w.getSelectionRange()
    if sel_1 == sel_2:
        char = getattr(event, 'char', None)
        stroke = getattr(event, 'stroke', None)
        if char == '\t' and stroke and stroke.isPlainKey():
            c.editCommands.selfInsertCommand(event)  # Handles undo.
            return
    c.alwaysIndentBody(event)
</t>
<t tx="ekr.20210108053422.1">def batch_change(self, root, replacements, settings=None):
    """
    Support batch change scripts.
    
    replacement: a list of tuples (find_string, change_string).
    settings: a dict or g.Bunch containing find/change settings.
    
    Example:
        
        h = '@file src/ekr/coreFind.py'
        root = g.findNodeAnywhere(c, h)
        assert root
        replacements = (
            ('clone_find_all', 'do_clone_find_all'),
            ('clone_find_all_flattened', 'do_clone_find_all_flattened'),
        )
        settings = dict(suboutline_only=True)
        count = c.findCommands.batch_change(c, root, replacements, settings)
        if count:
            c.save()
    """
    try:
        self._init_from_dict(settings or {})
        count = 0
        for find, change in replacements:
            count += self._batch_change_helper(root, find, change)
        return count
    except Exception:
        g.es_exception()
        return 0
</t>
<t tx="ekr.20210108070948.1">def _batch_change_helper(self, p, find_text, change_text):

    c, p1, u = self.c, p.copy(), self.c.undoer
    undoType = 'Batch Change All'
    # Check...
    if not find_text:  # pragma: no cover
        return 0
    if not self.search_headline and not self.search_body:
        return 0  # pragma: no cover
    if self.pattern_match:
        ok = self.precompile_pattern()
        if not ok:  # pragma: no cover
            return 0
    # Init...
    self.find_text = find_text
    self.change_text = self.replace_back_slashes(change_text)
    if self.node_only:
        positions = [p1]
    elif self.suboutline_only:
        positions = p1.self_and_subtree()
    else:
        positions = c.all_unique_positions()
    # Init the work widget.
    s = p.h if self.in_headline else p.b
    self.work_s = s
    self.work_sel = (0, 0, 0)
    # The main loop.
    u.beforeChangeGroup(p1, undoType)
    count = 0
    for p in positions:
        count_h, count_b = 0, 0
        undoData = u.beforeChangeNodeContents(p)
        if self.search_headline:
            count_h, new_h = self._change_all_search_and_replace(p.h)
            if count_h:
                count += count_h
                p.h = new_h
        if self.search_body:
            count_b, new_b = self._change_all_search_and_replace(p.b)
            if count_b:
                count += count_b
                p.b = new_b
        if count_h or count_b:
            u.afterChangeNodeContents(p1, 'Replace All', undoData)
    u.afterChangeGroup(p1, undoType, reportFlag=True)
    if not g.unitTesting:  # pragma: no cover
        print(f"{count:3}: {find_text:&gt;30} =&gt; {change_text}")
    return count
</t>
<t tx="ekr.20210108083003.1">def _init_from_dict(self, settings):
    """Initialize ivars from settings (a dict or g.Bunch)."""
    # The valid ivars and reasonable defaults.
    valid = dict(
        ignore_case=False,
        node_only=False,
        pattern_match=False,
        search_body=True,
        search_headline=True,
        suboutline_only=False,  # Seems safest.  # Was True !!!
        whole_word=True,
    )
    # Set ivars to reasonable defaults.
    for ivar in valid:
        setattr(self, ivar, valid.get(ivar))
    # Override ivars from settings.
    errors = 0
    for ivar in settings.keys():
        if ivar in valid:
            val = settings.get(ivar)
            if val in (True, False):
                setattr(self, ivar, val)
            else:  # pragma: no cover
                g.trace("bad value: {ivar!r} = {val!r}")
                errors += 1
        else:  # pragma: no cover
            g.trace(f"ignoring {ivar!r} setting")
            errors += 1
    if errors:  # pragma: no cover
        g.printObj(sorted(valid.keys()), tag='valid keys')
</t>
<t tx="ekr.20210108130751.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1804

@language python
@nosearch
</t>
<t tx="ekr.20210110073117.10">def _cfa_find_next_match(self, p):
    """
    Find the next batch match at p.
    """
    # Called only from unit tests.
    table = []
    if self.search_headline:
        table.append(p.h)
    if self.search_body:
        table.append(p.b)
    for s in table:
        self.reverse = False
        pos, newpos = self.inner_search_helper(s, 0, len(s), self.find_text)
        if pos != -1:
            return True
    return False
</t>
<t tx="ekr.20210110073117.11"># A stand-alone method for unit tests.
def do_clone_find_tag(self, tag):
    """
    Do the clone-all-find commands from settings.
    Return (len(clones), found) for unit tests.
    """
    c, u = self.c, self.c.undoer
    tc = getattr(c, 'theTagController', None)
    if not tc:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print('nodetags not active')
        return 0, c.p
    clones = tc.get_tagged_nodes(tag)
    if not clones:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.es_print(f"tag not found: {tag}")
        tc.show_all_tags()
        return 0, c.p
    undoData = u.beforeInsertNode(c.p)
    found = self._create_clone_tag_nodes(clones)
    u.afterInsertNode(found, 'Clone Find Tag', undoData)
    assert c.positionExists(found, trace=True), found
    c.setChanged()
    c.selectPosition(found)
    c.redraw()
    return len(clones), found
</t>
<t tx="ekr.20210110073117.12">def _create_clone_tag_nodes(self, clones):
    """
    Create a "Found Tag" node as the last node of the outline.
    Clone all positions in the clones set as children of found.
    """
    c, p = self.c, self.c.p
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = f"Found Tag: {self.find_text}"
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkCopiedAsNthChild(found, n)
    return found
</t>
<t tx="ekr.20210110073117.23">def replace_all_helper(self, s):
    """
    Search s for self.find_text and replace with self.change_text.
    
    Return (found, new text)
    """
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:
        return False, None
    #
    # Order matters: regex matches ignore whole-word.
    if self.pattern_match:
        return self.batch_regex_replace(s)
    if self.whole_word:
        return self.batch_word_replace(s)
    return self.batch_plain_replace(s)
</t>
<t tx="ekr.20210110073117.24">def batch_plain_replace(self, s):
    """
    Perform all plain find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0 &amp; change.
        count += 1
        result.append(s0[prev_i:i])
        result.append(change)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20210110073117.25">def batch_regex_replace(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.make_regex_subs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20210110073117.26">def batch_word_replace(self, s):
    """
    Perform all whole word find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replace_back_slashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        progress = prev_i
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0, change &amp; find0.
        result.append(s0[prev_i:i])
        if g.match_word(s, i, find):
            count += 1
            result.append(change)
        else:
            result.append(find0)
        prev_i = max(prev_i + 1, i + len(find))  # 2021/01/08 (!)
        assert prev_i &gt; progress, prev_i
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20210110073117.31">def check_args(self, tag):
    """Check the user arguments to a command."""
    if not self.search_headline and not self.search_body:
        if not g.unitTesting:
            g.es_print("not searching headline or body")  # pragma: no cover (skip)
        return False
    if not self.find_text:
        if not g.unitTesting:
            g.es_print(f"{tag}: empty find pattern")  # pragma: no cover (skip)
        return False
    return True
</t>
<t tx="ekr.20210110073117.32">def compile_pattern(self):
    """Precompile the regexp pattern if necessary."""
    try:  # Precompile the regexp.
        # pylint: disable=no-member
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        # Escape the search text.
        # Ignore the whole_word option.
        s = self.find_text
        # A bad idea: insert \b automatically.
            # b, s = '\\b', self.find_text
            # if self.whole_word:
                # if not s.startswith(b): s = b + s
                # if not s.endswith(b): s = s + b
        self.re_obj = re.compile(s, flags)
        return True
    except Exception:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.warning('invalid regular expression:', self.find_text)
        return False
</t>
<t tx="ekr.20210110073117.33">def compute_result_status(self, find_all_flag=False):  # pragma: no cover (cmd)
    """Return the status to be shown in the status line after a find command completes."""
    # Too similar to another method...
    status = []
    table = (
        ('whole_word', 'Word'),
        ('ignore_case', 'Ignore Case'),
        ('pattern_match', 'Regex'),
        ('suboutline_only', '[Outline Only]'),
        ('node_only', '[Node Only]'),
        ('search_headline', 'Head'),
        ('search_body', 'Body'),
    )
    for ivar, val in table:
        if getattr(self, ivar):
            status.append(val)
    return f" ({', '.join(status)})" if status else ''
</t>
<t tx="ekr.20210110073117.34">def _cfa_create_nodes(self, clones, flattened):
    """
    Create a "Found" node as the last node of the outline.
    Clone all positions in the clones set a children of found.
    """
    c = self.c
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = f"Found:{self.find_text}"
    status = self.compute_result_status(find_all_flag=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    flat = 'flattened, ' if flattened else ''
    found.b = f"@nosearch\n\n# {flat}{status}\n\n# found {len(clones)} nodes"
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkCopiedAsNthChild(found, n)
    # Sort the clones in place, without undo.
    found.v.children.sort(key=lambda v: v.h.lower())
    return found
</t>
<t tx="ekr.20210110073117.4">def init_ivars_from_settings(self, settings):
    """
    Initialize all ivars from settings, including required defaults.
    
    This should be called from the do_ methods as follows:
        
        self.init_ivars_from_settings(settings)
        if not self.check_args('find-next'):
            return &lt;appropriate error indication&gt;
    """
    #
    # Init required defaults.
    self.reverse = False
    #
    # Init find/change strings.
    self.change_text = settings.change_text
    self.find_text = settings.find_text
    #
    # Init find options.
    self.ignore_case = settings.ignore_case
    self.mark_changes = settings.mark_changes
    self.mark_finds = settings.mark_finds
    self.node_only = settings.node_only
    self.pattern_match = settings.pattern_match
    self.search_body = settings.search_body
    self.search_headline = settings.search_headline
    self.suboutline_only = settings.suboutline_only
    self.whole_word = settings.whole_word
    # self.wrapping = settings.wrapping
</t>
<t tx="ekr.20210110073117.43">def inner_search_helper(self, s, i, j, pattern):
    """
    Dispatch the proper search method based on settings.
    """
    backwards = self.reverse
    nocase = self.ignore_case
    regexp = self.pattern_match
    word = self.whole_word
    if backwards:
        i, j = j, i
    if not s[i:j] or not pattern:
        return -1, -1
    if regexp:
        pos, newpos = self._inner_search_regex(s, i, j, pattern, backwards, nocase)
    elif backwards:
        pos, newpos = self._inner_search_backward(s, i, j, pattern, nocase, word)
    else:
        pos, newpos = self._inner_search_plain(s, i, j, pattern, nocase, word)
    return pos, newpos
</t>
<t tx="ekr.20210110073117.44">def _inner_search_backward(self, s, i, j, pattern, nocase, word):
    """
    rfind(sub [,start [,end]])

    Return the highest index in the string where substring sub is found,
    such that sub is contained within s[start,end].
    
    Optional arguments start and end are interpreted as in slice notation.

    Return (-1, -1) on failure.
    """
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
    pattern = self.replace_back_slashes(pattern)
    n = len(pattern)
    # Put the indices in range.  Indices can get out of range
    # because the search code strips '\r' characters when searching @edit nodes.
    i = max(0, i)
    j = min(len(s), j)
    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        return -1, -1
    if word:
        while 1:
            k = s.rfind(pattern, i, j)
            if k == -1:
                break
            if self._inner_search_match_word(s, k, pattern):
                return k, k + n
            j = max(0, k - 1)
        return -1, -1
    k = s.rfind(pattern, i, j)
    if k == -1:
        return -1, -1
    return k, k + n
</t>
<t tx="ekr.20210110073117.45">def _inner_search_match_word(self, s, i, pattern):
    """Do a whole-word search."""
    pattern = self.replace_back_slashes(pattern)
    if not s or not pattern or not g.match(s, i, pattern):
        return False
    pat1, pat2 = pattern[0], pattern[-1]
    n = len(pattern)
    ch1 = s[i - 1] if 0 &lt;= i - 1 &lt; len(s) else '.'
    ch2 = s[i + n] if 0 &lt;= i + n &lt; len(s) else '.'
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    return not inWord
</t>
<t tx="ekr.20210110073117.46">def _inner_search_plain(self, s, i, j, pattern, nocase, word):
    """Do a plain search."""
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
    pattern = self.replace_back_slashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern, i, j)
            if k == -1:
                break
            if self._inner_search_match_word(s, k, pattern):
                return k, k + n
            i = k + n
        return -1, -1
    k = s.find(pattern, i, j)
    if k == -1:
        return -1, -1
    return k, k + n
</t>
<t tx="ekr.20210110073117.47">def _inner_search_regex(self, s, i, j, pattern, backwards, nocase):
    """Called from inner_search_helper"""
    re_obj = self.re_obj  # Use the pre-compiled object
    if not re_obj:
        if not g.unitTesting:  # pragma: no cover (skip)
            g.trace('can not happen: no re_obj')
        return -1, -1
    if backwards:
        # Scan to the last match using search here.
        i, last_mo = 0, None
        while i &lt; len(s):
            mo = re_obj.search(s, i, j)
            if not mo:
                break
            i += 1
            last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s, i, j)
    if mo:
        self.match_obj = mo
        return mo.start(), mo.end()
    self.match_obj = None
    return -1, -1
    #
    # The following is mysterious.
    # Félix, please don't bother with it.
    # I'll re-enable it if it ever makes sense to me :-)
    ###
        # # if mo and mo.group(0) != 'def': g.trace(i, mo, mo.start(), mo.end())
        # while mo and 0 &lt;= i &lt;= len(s):
            # if mo.start() == mo.end():
                # if backwards:
                    # # Search backward using match instead of search.
                    # i -= 1
                    # while 0 &lt;= i &lt; len(s):
                        # mo = re_obj.match(s, i, j)
                        # if mo: break
                        # i -= 1
                # else:
                    # i += 1
                    # mo = re_obj.search(s, i, j)
            # else:
                # self.match_obj = mo
                # return mo.start(), mo.end()
        # self.match_obj = None
        # return -1, -1
</t>
<t tx="ekr.20210110073117.48">def make_regex_subs(self, change_text, groups):
    """
    Substitute group[i-1] for \\i strings in change_text.
    
    Groups is a tuple of strings, one for every matched group.
    """

    # g.printObj(list(groups), tag=f"groups in {change_text!r}")

    def repl(match_object):
        """re.sub calls this function once per group."""
        # # 1494...
        n = int(match_object.group(1)) - 1
        if 0 &lt;= n &lt; len(groups):
            # Executed only if the change text contains groups that match.
            return (
                groups[n].
                    replace(r'\b', r'\\b').
                    replace(r'\f', r'\\f').
                    replace(r'\n', r'\\n').
                    replace(r'\r', r'\\r').
                    replace(r'\t', r'\\t').
                    replace(r'\v', r'\\v'))
        # No replacement.
        return match_object.group(0)

    result = re.sub(r'\\([0-9])', repl, change_text)
    return result
</t>
<t tx="ekr.20210110073117.49">def replace_back_slashes(self, s):
    """Carefully replace backslashes in a search pattern."""
    # This is NOT the same as:
    #
    #   s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    #
    # because there is no rescanning.
    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i + 1]
            if ch == '\\':
                s = s[:i] + s[i + 1 :]  # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i + 2 :]  # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i + 2 :]  # replace \t by a tab
            else:
                i += 1  # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20210110073117.5">def init_settings(self, settings):
    """Initialize all user settings."""

</t>
<t tx="ekr.20210110073117.55"></t>
<t tx="ekr.20210110073117.56">def make_test_tree(self):
    """Make a test tree for other tests"""
    c = self.c
    root = c.rootPosition()
    root.h = 'Root'
    root.b = f"def root():\n    pass\n"
    last = root

    def make_child(n, p):
        p2 = p.insertAsLastChild()
        p2.h = f"child {n}"
        p2.b = f"def child{n}():\n    v{n} = 2\n"
        return p2

    def make_top(n, sib):
        p = sib.insertAfter()
        p.h = f"Node {n}"
        p.b = f"def top{n}():\n    v{n} = 3\n"
        return p

    for n in range(0, 4, 3):
        last = make_top(n + 1, last)
        child = make_child(n + 2, last)
        make_child(n + 3, child)

    for p in c.all_positions():
        p.v.clearDirty()
        p.v.clearVisited()
        
    # Always start with the root selected.
    c.selectPosition(c.rootPosition())
</t>
<t tx="ekr.20210110073117.57">def setUp(self):
    """setUp for TestFind class"""
    # pylint: disable=import-self
    from leo.core import leoFind
    from leo.core.leoGui import StringFindTabManager
    g.unitTesting = True
    self.c = c = leoTest2.create_app()
    c.findCommands = self.x = x = leoFind.LeoFind(c)
    # Set c.p in the command.
    x.c.selectPosition(self.c.rootPosition())
    x.ftm = StringFindTabManager(c)
    self.settings = x.default_settings()
    self.make_test_tree()

def tearDown(self):
    g.unitTesting = False
</t>
<t tx="ekr.20210110073117.58">def test_tree(self):
    table = (
        (0, 'Root'),
        (0, 'Node 1'),
        (1, 'child 2'),
        (2, 'child 3'),
        (0, 'Node 4'),
        (1, 'child 5'),
        (2, 'child 6'),
    )
    i = 0
    for p in self.c.all_positions():
        level, h = table[i]
        i += 1
        assert p.h == h, (p.h, h)
        assert p.level() == level, (p.level(), level, p.h)
        # print(' '*p.level(), p.h)
        # g.printObj(g.splitLines(p.b), tag=p.h)
</t>
<t tx="ekr.20210110073117.59"></t>
<t tx="ekr.20210110073117.6">def default_settings(self):
    """Return a dict representing all default settings."""
    c = self.c
    return g.Bunch(
        # State...
        in_headline=False,
        p=c.rootPosition(),
        # Find/change strings...
        find_text='',
        change_text='',
        # Find options...
        ignore_case=False,
        mark_changes=False,
        mark_finds=False,
        node_only=False,
        pattern_match=False,
        reverse=False,
        search_body=True,
        search_headline=True,
        suboutline_only=False,
        whole_word=False,
        wrapping=False,
    )
</t>
<t tx="ekr.20210110073117.60">def test_clone_find_all(self):
    settings, x = self.settings, self.x
    # Regex find.
    settings.find_text = r'^def\b'
    settings.change_text = 'def'  # Don't actually change anything!
    settings.pattern_match = True
    x.do_clone_find_all(settings)
    # Word find.
    settings.find_text = 'def'
    settings.match_word = True
    settings.pattern_match = False
    x.do_clone_find_all(settings)
    # Suboutline only.
    settings.suboutline_only = True
    x.do_clone_find_all(settings)
</t>
<t tx="ekr.20210110073117.61">def test_clone_find_all_flattened(self):
    settings, x = self.settings, self.x
    # regex find.
    settings.find_text = r'^def\b'
    settings.pattern_match = True
    x.do_clone_find_all_flattened(settings)
    # word find.
    settings.find_text = 'def'
    settings.match_word = True
    settings.pattern_match = False
    x.do_clone_find_all_flattened(settings)
    # Suboutline only.
    settings.suboutline_only = True
    x.do_clone_find_all_flattened(settings)
</t>
<t tx="ekr.20210110073117.62">def test_clone_find_tag(self):
    c, x = self.c, self.x

    class DummyTagController:

        def __init__(self, clones):
            self.clones = clones

        def get_tagged_nodes(self, tag):
            return self.clones

        def show_all_tags(self):
            pass

    c.theTagController = DummyTagController([c.rootPosition()])
    x.do_clone_find_tag('test')
    c.theTagController = DummyTagController([])
    x.do_clone_find_tag('test')
    c.theTagController = None
    x.do_clone_find_tag('test')
</t>
<t tx="ekr.20210110073117.63">def test_find_all(self):
    settings, x = self.settings, self.x
    
    def init():
        self.make_test_tree()  # Reinit the whole tree.
        x.findAllUniqueFlag = False
        x.unique_matches = set()
        settings.change_text = '_DEF_'
        settings.find_text = 'def'
        settings.ignore_case = False
        settings.node_only = False
        settings.pattern_match = False
        settings.suboutline_only = False
        settings.whole_word = True

    # Test 1.
    init()
    settings.pattern_match = True
    x.do_find_all(settings)
    # Test 2.
    init()
    settings.suboutline_only = True
    x.do_find_all(settings)
    # Test 3.
    init()
    settings.search_headline = False
    settings.p.setVisited()
    x.do_find_all(settings)
    # Test 4.
    init()
    x.findAllUniqueFlag = True
    settings.pattern_match = True
    settings.find_text = r'^(def)'
    settings.change_text = '*\1*'
    x.do_find_all(settings)
    # Test 5: no match.
    init()
    settings.find_text = 'not-found-xyzzy'
    x.do_find_all(settings)
    
</t>
<t tx="ekr.20210110073117.64">def test_find_next(self):
    settings, x = self.settings, self.x
    settings.find_text = 'def top1'
    p, pos, newpos = x.do_find_next(settings)
    assert p and p.h == 'Node 1', repr(p)
    s = p.b[pos:newpos]
    assert s == settings.find_text, repr(s)
</t>
<t tx="ekr.20210110073117.65">def test_find_def(self):
    settings, x = self.settings, self.x
    # Test methods called by x.find_def.
    # It would be wrong to call these methods from x.do_find_def.
    x._save_before_find_def(x.c.rootPosition())  # Also tests _restore_after_find_def.
    x._compute_find_def_settings('my-find-pattern')
    #
    # Now the main tests...
    # Test 1.
    p, pos, newpos = x.do_find_def(settings, word='child5', strict=True)
    assert p and p.h == 'child 5', repr(p and p.h)  # Test 1.
    s = p.b[pos:newpos]
    assert s == 'def child5', repr(s)
    # Test 2: switch style.
    p, pos, newpos = x.do_find_def(settings, word='child_5', strict=False)
    assert p and p.h == 'child 5', repr(p and p.h)  # Test 2.
    # Test 3: not found after switching style.
    p, pos, newpos = x.do_find_def(settings, word='xyzzy', strict=False)
    assert p is None, repr(p)  # Test 3.
</t>
<t tx="ekr.20210110073117.66">def test_find_var(self):
    settings, x = self.settings, self.x
    p, pos, newpos = x.do_find_var(settings, word='v5')
    assert p and p.h == 'child 5', repr(p)
    s = p.b[pos:newpos]
    assert s == 'v5 =', repr(s)
</t>
<t tx="ekr.20210110073117.67">def test_change_all(self):
    c, settings, x = self.c, self.settings, self.x
    root = c.rootPosition()
    
    def init():
        self.make_test_tree()  # Reinit the whole tree.
        settings.change_text = '_DEF_'
        settings.find_text = 'def'
        settings.ignore_case = False
        settings.node_only = False
        settings.pattern_match = False
        settings.suboutline_only = False
        settings.whole_word = True

    # Default settings.
    init()
    x.do_change_all(settings)
    # Plain search, ignore case.
    init()
    settings.whole_word = False
    settings.ignore_case = True
    x.do_change_all(settings)
    # Node only.
    init()
    settings.node_only = True
    x.do_change_all(settings)
    # Suboutline only.
    init()
    settings.suboutline_only = True
    x.do_change_all(settings)
    # Pattern match.
    init()
    settings.pattern_match = True
    x.do_change_all(settings)
    # Pattern match, ignore case.
    init()
    settings.pattern_match = True
    settings.ignore_case = True
    x.do_change_all(settings)
    # Pattern match, with groups.
    init()
    settings.pattern_match = True
    settings.find_text = r'^(def)'
    settings.change_text = '*\1*'
    x.do_change_all(settings)
    # Ignore case
    init()
    settings.ignore_case = True
    x.do_change_all(settings)
    # Word, ignore case.
    init()
    settings.ignore_case = True
    settings.whole_word = True
    x.do_change_all(settings)
    # Multiple matches
    init()
    root.h = 'abc'
    root.b = 'abc\nxyz abc\n'
    settings.find_text = settings.change_text = 'abc'
    x.do_change_all(settings)
    # Set ancestor @file node dirty.
    root.h = '@file xyzzy'
    settings.find_text = settings.change_text = 'child1'
    x.do_change_all(settings)
</t>
<t tx="ekr.20210110073117.68">def test_replace_then_find(self):
    settings, w, x = self.settings, self.c.frame.body.wrapper, self.x
    settings.find_text = 'def top1'
    settings.change_text = 'def top'
    # find-next
    p, pos, newpos = x.do_find_next(settings)
    assert p and p.h == 'Node 1', p.h
    s = p.b[pos:newpos]
    assert s == settings.find_text, repr(s)
    # replace-then-find
    w.setSelectionRange(pos, newpos, insert=pos)
    x.do_change_then_find(settings)
    # Failure exit.
    w.setSelectionRange(0, 0)
    x.do_change_then_find(settings)

def test_replace_then_find_regex(self):
    settings, w, x = self.settings, self.c.frame.body.wrapper, self.x
    settings.find_text = r'(def) top1'
    settings.change_text = r'\1\1'
    settings.pattern_match = True
    # find-next
    p, pos, newpos = x.do_find_next(settings)
    s = p.b[pos:newpos]
    assert s == 'def top1', repr(s)
    # replace-then-find
    w.setSelectionRange(pos, newpos, insert=pos)
    x.do_change_then_find(settings)

def test_replace_then_find_in_headline(self):
    settings, x = self.settings, self.x
    p = settings.p
    settings.find_text = 'Node 1'
    settings.change_text = 'Node 1a'
    settings.in_headline = True
    # find-next
    p, pos, newpos = x.do_find_next(settings)
    assert p and p.h == settings.find_text, p.h
    w = self.c.edit_widget(p)
    assert w
    s = p.h[pos:newpos]
    assert s == settings.find_text, repr(s)
</t>
<t tx="ekr.20210110073117.69">def test_tag_children(self):

    c, x = self.c, self.x

    class DummyTagController:
        def add_tag(self, p, tag):
            pass

    p = c.rootPosition().next()
    c.theTagController = None
    x.do_tag_children(p, 'test')
    c.theTagController = DummyTagController()
    x.do_tag_children(p, 'test')
</t>
<t tx="ekr.20210110073117.70"></t>
<t tx="ekr.20210110073117.71">def test_cfa_backwards_search(self):
    settings, x = self.settings, self.x
    pattern = 'def'
    for nocase in (True, False):
        settings.ignore_case = nocase
        for word in (True, False):
            for s in ('def spam():\n', 'define spam'):
                settings.whole_word = word
                x.init_ivars_from_settings(settings)
                x._inner_search_backward(s, 0, len(s), pattern, nocase, word)
                x._inner_search_backward(s, 0, 0, pattern, nocase, word)
</t>
<t tx="ekr.20210110073117.72">def test_argument_errors(self):

    settings, x = self.settings, self.x
    # Bad search pattern.
    settings.find_text = r'^def\b(('
    settings.pattern_match = True
    x.do_clone_find_all(settings)
    x.find_next_match(p=None)
    x.do_change_all(settings)
</t>
<t tx="ekr.20210110073117.73">def test_batch_word_replace(self):
    settings, x = self.settings, self.x
    settings.find_text = 'b'
    settings.change_text = 'B'
    for ignore in (True, False):
        settings.ignore_case = ignore
        x.init_ivars_from_settings(settings)
        s = 'abc b z'
        count, s2 = x.batch_word_replace(s)
        assert count == 1 and s2 == 'abc B z', (ignore, count, repr(s2))
</t>
<t tx="ekr.20210110073117.74">def test_batch_plain_replace(self):
    settings, x = self.settings, self.x
    settings.find_text = 'b'
    settings.change_text = 'B'
    for ignore in (True, False):
        settings.ignore_case = ignore
        x.init_ivars_from_settings(settings)
        s = 'abc b z'
        count, s2 = x.batch_plain_replace(s)
        assert count == 2 and s2 == 'aBc B z', (ignore, count, repr(s2))
</t>
<t tx="ekr.20210110073117.75">def test_batch_regex_replace(self):
    settings, x = self.settings, self.x
    s = 'abc b z'
    table = (
        (1, 2, 'B', 'B', 'aBc B z'),
        (0, 2, 'b', 'B', 'aBc B z'),
        (1, 2, r'([BX])', 'B', 'aBc B z'),
    )
    for ignore, count, find, change, expected_s in table:
        settings.ignore_case = bool(ignore)
        settings.find_text = find
        settings.change_text = change
        x.init_ivars_from_settings(settings)
        actual_count, actual_s = x.batch_regex_replace(s)
        assert actual_count == count and actual_s == expected_s, (
            f"ignore: {ignore} find: {find} change {change}\n"
            f"expected count: {count} s: {expected_s}\n"
            f"     got count: {actual_count} s: {actual_s}")

</t>
<t tx="ekr.20210110073117.76">def test_check_args(self):
    # Bad search patterns..
    x = self.x
    settings = self.settings
    # Not searching headline or body.
    settings.search_body = False
    settings.search_headline = False
    x.do_clone_find_all(settings)
    # Empty find pattern.
    settings.search_body = True
    settings.find_text = ''
    x.do_clone_find_all(settings)
    x.do_clone_find_all_flattened(settings)
    x.do_find_all(settings)
    ### x.do_find_def(settings, word='xyzzy')
    ### x.do_find_var(settings, word='xyzzy')
    x.do_find_next(settings)
    x.do_find_next(settings)
    x.do_find_prev(settings)
    x.do_change_all(settings)
    x.do_change_then_find(settings)
</t>
<t tx="ekr.20210110073117.77">def test_compute_result_status(self):
    x = self.x
    # find_all_flag is True
    all_settings = x.default_settings()
    all_settings.ignore_case = True
    all_settings.pattern_match = True
    all_settings.whole_word = True
    all_settings.wrapping = True
    x.init_ivars_from_settings(all_settings)
    x.compute_result_status(find_all_flag=True)
    # find_all_flag is False
    partial_settings = x.default_settings()
    partial_settings.search_body = True
    partial_settings.search_headline = True
    partial_settings.node_only = True
    partial_settings.suboutline_only = True
    partial_settings.wrapping = True
    x.init_ivars_from_settings(partial_settings)
    x.compute_result_status(find_all_flag=False)
</t>
<t tx="ekr.20210110073117.79">def dump_tree(self, tag=''):  # pragma: no cover (skip)
    """Dump the test tree created by make_test_tree."""
    c = self.c
    print('dump_tree', tag)
    for p in c.all_positions():
        print(' ' * p.level(), p.h)
        print(' ' * p.level(), p.b)
</t>
<t tx="ekr.20210110073117.80">def test_cfa_find_next_match(self):
    c, settings, x = self.c, self.settings, self.x
    p = c.rootPosition()
    for find in ('xxx', 'def'):
        settings.find_text = find
        x._cfa_find_next_match(p)
</t>
<t tx="ekr.20210110073117.82">def test_make_regex_subs(self):
    x = self.x
    x.re_obj = re.compile(r'(.*)pattern')  # The search pattern.
    m = x.re_obj.search('test pattern')  # The find pattern.
    change_text = r'\1Pattern\2'  # \2 is non-matching group.
    x.make_regex_subs(change_text, m.groups())

    # OLD
    # groups = (r"f'", r"line\n")
    # change_text = r"""\1 AA \2 BB \3'"""
    # expected = r"""f' AA line\\n BB \3'"""
    # result = x.makeRegexSubs(change_text, groups)
    # assert result == expected, (expected, result)
</t>
<t tx="ekr.20210110073117.83">def test_cfa_match_word(self):
    x = self.x
    x._inner_search_match_word("def spam():", 0, "spam")
    x._inner_search_match_word("def spam():", 0, "xxx")

</t>
<t tx="ekr.20210110073117.84">def test_fnm_next_after_fail(self):
    settings, x = self.settings, self.x
    for reverse in (True, False):
        settings.reverse = reverse
        for wrapping in (True, False):
            settings.wrapping = wrapping
            x.init_ivars_from_settings(settings)
            x._fnm_next_after_fail(settings.p)
</t>
<t tx="ekr.20210110073117.85">def test_cfa_plain_search(self):
    settings, x = self.settings, self.x
    pattern = 'def'
    for nocase in (True, False):
        settings.ignore_case = nocase
        for word in (True, False):
            for s in ('def spam():\n', 'define'):
                settings.whole_word = word
                x.init_ivars_from_settings(settings)
                x._inner_search_plain(s, 0, len(s), pattern, nocase, word)
                x._inner_search_plain(s, 0, 0, pattern, nocase, word)
</t>
<t tx="ekr.20210110073117.86">def test_replace_all_helper(self):
    settings, x = self.settings, self.x
    settings.find_text = 'xyzzy'
    settings.change_text = 'xYzzy'
    s = 'abc xyzzy done'
    x.replace_all_helper('')  # Error test.
    for regex in (True, False):
        settings.pattern_match = regex
        for word in (True, False):
            settings.whole_word = word
            x.init_ivars_from_settings(settings)
            x.replace_all_helper(s)
</t>
<t tx="ekr.20210110073117.87">def test_replace_back_slashes(self):
    x = self.x
    table = (
        (r'a\bc', r'a\bc'),
        (r'a\\bc', r'a\bc'),
        (r'a\tc', 'a\tc'),  # Replace \t by a tab.
        (r'a\nc', 'a\nc'),  # Replace \n by a newline.
    )
    for s, expected in table:
        result = x.replace_back_slashes(s)
        assert result == expected, (s, result, expected)
</t>
<t tx="ekr.20210110073117.88">def test_cfa_regex_search(self):
    x = self.x
    pattern = r'(.*)pattern'
    x.re_obj = re.compile(pattern)
    table = (
        'test pattern',  # Match.
        'xxx',  # No match.
    )
    for backwards in (True, False):
        for nocase in (True, False):
            for s in table:
                if backwards:
                    i = j = len(s)
                else:
                    i = j = 0
                x._inner_search_regex(s, i, j, pattern, backwards, nocase)
    # Error test.
    x.re_obj = None
    backwards = pattern = nocase = None
    x._inner_search_regex("", 0, 0, pattern, backwards, nocase)

    # for change_text, groups, expected in table:
        # result = x.make_regex_subs(change_text, groups)
        # assert result == expected, (
            # f"change_text: {change_text}\n"
            # f"     groups: {groups}\n"
            # f"   expected: {expected}\n"
            # f"        got: {result}")
</t>
<t tx="ekr.20210110073117.89">def test_switch_style(self):
    x = self.x
    table = (
        ('', None),
        ('TestClass', None),
        ('camelCase', 'camel_case'),
        ('under_score', 'underScore'),
    )
    for s, expected in table:
        result = x._switch_style(s)
        assert result == expected, (
            f"       s: {s}\n"
            f"expected: {expected!r}\n"
            f"     got: {result!r}")
</t>
<t tx="ekr.20210110073117.9">def _cf_helper(self, settings, flatten):  # Caller has  checked the settings.
    """
    The common part of the clone-find commands.
    
    Return the number of found nodes.
    """
    c, u = self.c, self.c.undoer
    if self.pattern_match:
        ok = self.compile_pattern()
        if not ok: return 0
    if self.suboutline_only:
        p = c.p
        after = p.nodeAfterTree()
    else:
        p = c.rootPosition()
        after = None
    count, found = 0, None
    clones, skip = [], set()
    while p and p != after:
        progress = p.copy()
        if p.v in skip:  # pragma: no cover (minor)
            p.moveToThreadNext()
        elif g.inAtNosearch(p):
            p.moveToNodeAfterTree()
        elif self._cfa_find_next_match(p):
            count += 1
            if p not in clones:
                clones.append(p.copy())
            if flatten:
                p.moveToThreadNext()
            else:
                # Don't look at the node or it's descendants.
                for p2 in p.self_and_subtree(copy=False):
                    skip.add(p2.v)
                p.moveToNodeAfterTree()
        else:  # pragma: no cover (minor)
            p.moveToThreadNext()
        assert p != progress
    self.ftm.set_radio_button('entire-outline')
    # suboutline-only is a one-shot for batch commands.
    self.node_only = self.suboutline_only = False
    self.root = None
    if clones:
        undoData = u.beforeInsertNode(c.p)
        found = self._cfa_create_nodes(clones, flattened=False)
        u.afterInsertNode(found, 'Clone Find All', undoData)
        assert c.positionExists(found, trace=True), found
        c.setChanged()
        c.selectPosition(found)
    g.es("found", count, "matches for", self.find_text)
    return count  # Might be useful for the gui update.
</t>
<t tx="ekr.20210110073209.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1806

@language python
@nosearch
</t>
<t tx="ekr.20210110092457.1">@language python
@nosearch
</t>
<t tx="ekr.20210110092457.5">g.cls()
import os
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
# os.system('py-cov-find')
command = r'pytest --cov-report html --cov-report term-missing --cov leo.core.leoFind leo\core\leoFind.py'
os.system(command)
g.es_print('done')</t>
<t tx="ekr.20210110092457.6">import os
# os.system('moz htmlcov/leo_core_leoFind_py.html')
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
os.system('moz htmlcov/leo_core_leoFind_py.html')</t>
<t tx="ekr.20210110092457.7">g.cls()
import os
os.system('python -m unittest leoFind.py')
g.es_print('done')</t>
<t tx="ekr.20210111082524.1">def init_vim_search(self, pattern):  # pragma: no cover (cmd)
    """Initialize searches in vim mode."""
    c = self.c
    if c.vim_mode and c.vimCommands:
        c.vimCommands.update_dot_before_search(
            find_pattern=pattern,
            change_pattern=None)  # A flag.
</t>
<t tx="ekr.20210112044303.1">@cmd('re-search-backward')
def interactive_re_search_backward(self, event):  # pragma: no cover (interactive)
    """Same as start-find, but with regex and in reverse."""
    # Set flags for show_find_options.
    self.reverse = True
    self.pattern_match = True
    self.show_find_options()
    # Set flags for do_find_next().
    self.request_reverse = True
    self.request_pattern_match = True
    # Go.
    self.start_state_machine(event,
        prefix='Regexp Search Backward:',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )

</t>
<t tx="ekr.20210112050845.1">@cmd('word-search')
@cmd('word-search-forward')
def word_search_forward(self, event):  # pragma: no cover (interactive)
    """Same as start-search, with whole_word setting."""
    # Set flag for show_find_options.
    self.whole_word = True
    self.show_find_options()
    # Set flag for do_find_next().
    self.request_whole_world = True
    # Go.
    self.start_state_machine(event,
        prefix='Word Search: ',
        handler=self.start_search1,  # See start-search
        escape_handler=self.start_search_escape1,  # See start-search
    )
</t>
<t tx="ekr.20210112192011.1"></t>
<t tx="ekr.20210112192427.1"></t>
<t tx="ekr.20210113054702.1">import os
print(f"\nos.curdir: {os.path.abspath(os.curdir)}")</t>
<t tx="ekr.20210114063355.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1808

@language python
@nosearch
</t>
<t tx="ekr.20210114094846.1"># A stand-alone method for unit testing.
def do_clone_find_all(self, settings):
    """
    Do the clone-all-find commands from settings.

    Return the count of found nodes.
    
    This is a stand-alone method for unit testing.
    """
    self.init_ivars_from_settings(settings)
    if not self.check_args('clone-find-all'):
        return 0
    return self._cf_helper(settings, flatten=False)
</t>
<t tx="ekr.20210114094944.1"># A stand-alone method for unit testing.
def do_clone_find_all_flattened(self, settings):
    """
    Do the clone-find-all-flattened command from the settings.
    
    Return the count of found nodes.
    
    This is a stand-alone method for unit testing.
    """
    self.init_ivars_from_settings(settings)
    if self.check_args('clone-find-all-flattened'):
        return self._cf_helper(settings, flatten=True)
    return 0
</t>
<t tx="ekr.20210114100105.1"># A stand-alone method for unit testing.
def do_change_then_find(self, settings):
    """
    Do the change-then-find command from settings.
    
    This is a stand-alone method for unit testing.
    """
    p = self.c.p
    self.init_ivars_from_settings(settings)
    if not self.check_args('change-then-find'):
        return False
    if self.change_selection(p):
        self.do_find_next(settings)
    return True

</t>
<t tx="ekr.20210114202757.1">def _compute_find_def_settings(self, find_pattern):

    settings = self.default_settings()
    table = (
        ('change_text', ''),
        ('find_text', find_pattern),
        ('ignore_case', False),
        ('pattern_match', False),
        ('reverse', False),
        ('search_body', True),
        ('search_headline', False),
        ('whole_word', True),
    )
    for attr, val in table:
        # Guard against renamings &amp; misspellings.
        assert hasattr(self, attr), attr
        assert attr in settings.__dict__, attr
        # Set the values.
        setattr(self, attr, val)
        settings[attr] = val
    return settings
</t>
<t tx="ekr.20210115173729.153">def showSuccess(self, pos, newpos, showState=True):
    """Display the result of a successful find operation."""
    c = self.c
    self.p = p = self.p or c.p
    # Set state vars.
    # Ensure progress in backwards searches.
    insert = min(pos, newpos) if self.reverse else max(pos, newpos)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
    if c.sparse_find:
        c.expandOnlyAncestorsOfNode(p=p)
    if self.in_headline:
        c.endEditing()
        selection = pos, newpos, insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
        self.was_in_headline = True  # 2015/03/25
    else:
        # Tricky code.  Do not change without careful thought.
        w = c.frame.body.wrapper
        # *Always* do the full selection logic.
        # This ensures that the body text is inited  and recolored.
        c.selectPosition(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        c.bodyWantsFocusNow()
        w.setSelectionRange(pos, newpos, insert=insert)
        k = g.see_more_lines(w.getAllText(), insert, 4)
        w.see(k)
            # #78: find-next match not always scrolled into view.
        c.outerUpdate()
            # Set the focus immediately.
        if c.vim_mode and c.vimCommands:
            c.vimCommands.update_selection_after_search()
    # Support for the console gui.
    if hasattr(g.app.gui, 'show_find_success'):
        g.app.gui.show_find_success(c, self.in_headline, insert, p)
    c.frame.bringToFront()
    return w  # Support for isearch.
</t>
<t tx="ekr.20210117064814.1">from collections import namedtuple

Work = namedtuple('Work', ('start', 'end', 'ins'), defaults=(0,0,0))
w = Work(ins=1)
print(w.start, w.end, w.ins)
print(repr(w))</t>
<t tx="ekr.20210117143611.1">def start_search1(self, event=None):  # pragma: no cover
    """Common handler for use by vim commands and other find commands."""
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Settings...
    find_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    self.update_find_list(find_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()  # Required.
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    # Do the command!
    self.do_find_next(settings)  # Handles reverse.
</t>
<t tx="ekr.20210117143614.1">def start_search_escape1(self, event=None):  # pragma: no cover
    """
    Common escape handler for use by find commands.
    
    Prompt for a change pattern.
    """
    k = self.k
    self._sString = find_pattern = k.arg
    # Settings.
    k.getArgEscapeFlag = False
    self.ftm.set_find_text(find_pattern)
    self.update_find_list(find_pattern)
    self.find_text = find_pattern
    self.change_text = self.ftm.get_change_text()
    # Gui...
    regex = ' Regex' if self.pattern_match else ''
    backward = ' Backward' if self.reverse else ''
    prompt = f"Replace{regex}{backward}: {find_pattern} With: "
    k.setLabelBlue(prompt)
    self.add_change_string_to_label()
    k.getNextArg(self._start_search_escape2)

</t>
<t tx="ekr.20210117143615.1">def _start_search_escape2(self, event):  # pragma: no cover
    c, k, w = self.c, self.k, self.c.frame.body.wrapper
    # Compute settings...
    find_pattern = self._sString
    change_pattern = k.arg
    self.ftm.set_find_text(find_pattern)
    self.ftm.set_change_text(change_pattern)
    self.update_change_list(change_pattern)
    self.init_vim_search(find_pattern)
    self.init_in_headline()  # Required
    settings = self.ftm.get_settings()
    # Gui...
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
    c.widgetWantsFocusNow(w)
    self.do_find_next(settings)
</t>
<t tx="ekr.20210118003803.1">@cmd('find-var')
def find_var(self, event=None):  # pragma: no cover (cmd)
    """Find the var under the cursor."""
    ftm, p = self.ftm, self.c.p
    # Check...
    word = self._compute_find_def_word(event)
    if not word:
        return
    # Settings...
    self.find_pattern = find_pattern = word + ' ='
    ftm.set_find_text(find_pattern)
    self._save_before_find_def(p)  # Save previous settings.
    self.init_vim_search(find_pattern)
    self.update_change_list(self.change_text)  # Optional. An edge case.
    settings = self._compute_find_def_settings(find_pattern)
    # Do the command!
    self.do_find_var(settings, word)

def do_find_var(self, settings, word):
    """A standalone helper for unit tests."""
    return self._fd_helper(settings, word, def_flag=False, strict=False)
</t>
<t tx="ekr.20210118013157.1">"""
Convert defs in LeoFind to pep8 names.
- Don't change defs containing underscores.
- Check for existing target.
"""
g.cls()
import re
h = 'class LeoFind (LeoFind.py)'
root = g.findNodeAnywhere(c, h)
@others
if root:
    main(root)
else:
    print('not found:', root)</t>
<t tx="ekr.20210118013807.1">def main(root):
    pattern = re.compile(r'^def\s+(\w+)', re.MULTILINE)
    for pass_n in (0, 1):
        n = 0
        for p in root.subtree():
            for m in re.finditer(pattern, p.b):
                target = m.group(0)
                old_func = m.group(1)
                if '_' in target:
                    continue
                if target.islower():
                    continue
                if old_func == 'finishCreate':  # Special case.
                    return
                new_func = new_name(old_func)
                if new_func == old_func:
                    continue
                if pass_n == 0:
                    if exists(new_func, root):
                        g.trace(f"already exists: {old_func} {new_func}")
                        g.trace('aborting')
                        return
                else:
                    n += 1
                    convert(old_func, new_func, root)
    g.trace(f"converted {n} function names")
    c.redraw()
            </t>
<t tx="ekr.20210118020530.1">def new_name(s):
    """Return the new name of s."""
    assert ' ' not in s
    # Convert s to underscore style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    return ''.join(result).replace('i_search', 'isearch')
</t>
<t tx="ekr.20210118021337.1">def exists(s, root):
    """Return True if s exists in any of root's nodes."""
    for p in root.self_and_subtree():
        if s in p.b:
            return True
    return False</t>
<t tx="ekr.20210118024739.1">def convert(old_func, new_func, root):
    print(f"{old_func} =&gt; {new_func}\n")
    for p in root.subtree():
        pattern = rf"\b{old_func}\b"
        p.h = re.sub(pattern, new_func, p.h)
        p.b = re.sub(pattern, new_func, p.b)
        # g.printObj(g.splitLines(s2), tag='p.h')
    print('')</t>
<t tx="ekr.20210124064805.1">@language rest
@wrap

- Explore various ways of using leoserver.py:

Could Leo be a Jupyter kernel? This might be a good place to play with JS frameworks like vue.js, etc. Could vim interact with leoserver.py?

- Explore other technologies, including templating systems.

Post re Sabbatical:
- An attitude: exploratory, no tedious work, big picture, fun.
- Could be a permanent attitude.
- Sabbaticals usually involve travel. Maybe later this year.</t>
<t tx="ekr.20210128141640.1">gnx: ekr.20201012111338.2
unl: Declarations (leo_cloud.py)
gnx: ekr.20201012111338.3
unl: init (leo_cloud.py)
gnx: ekr.20201012111338.4
unl: onCreate (leo_cloud.py)
gnx: ekr.20201012111338.5
unl: onSave (leo_cloud.py)
gnx: ekr.20201012111338.6
unl: lc_read_current (leo_cloud.py)
gnx: ekr.20201012111338.7
unl: lc_write_current (leo_cloud.py)
gnx: ekr.20201012111338.8
unl: class LeoCloudIOBase
gnx: ekr.20201012111338.9
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.__init__
gnx: ekr.20201012111338.10
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.get_subtree
gnx: ekr.20201012111338.11
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.put_subtree
gnx: ekr.20201012111338.12
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)
gnx: ekr.20201012111338.13
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.14
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.15
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.16
unl: class LeoCloudIOGit(LeoCloudIOBase)
gnx: ekr.20201012111338.17
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.18
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase)._run_git
gnx: ekr.20201012111338.19
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.20
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.21
unl: class LeoCloud
gnx: ekr.20201012111338.22
unl: class LeoCloud--&gt;LeoCloud.__init__
gnx: ekr.20201012111338.23
unl: class LeoCloud--&gt;LeoCloud.bg_check
gnx: ekr.20201012111338.24
unl: class LeoCloud--&gt;LeoCloud.bg_post_process
gnx: ekr.20201012111338.25
unl: class LeoCloud--&gt;LeoCloud.find_at_leo_cloud
gnx: ekr.20201012111338.26
unl: class LeoCloud--&gt;LeoCloud._find_clouds_recursive
gnx: ekr.20201012111338.27
unl: class LeoCloud--&gt;LeoCloud.find_clouds
gnx: ekr.20201012111338.28
unl: class LeoCloud--&gt;LeoCloud._from_dict_recursive
gnx: ekr.20201012111338.29
unl: class LeoCloud--&gt;LeoCloud.from_dict
gnx: ekr.20201012111338.30
unl: class LeoCloud--&gt;LeoCloud.io_from_node
gnx: ekr.20201012111338.31
unl: class LeoCloud--&gt;LeoCloud.kw_from_node
gnx: ekr.20201012111338.32
unl: class LeoCloud--&gt;LeoCloud.load_clouds
gnx: ekr.20201012111338.33
unl: class LeoCloud--&gt;LeoCloud.read_current
gnx: ekr.20201012111338.34
unl: class LeoCloud--&gt;LeoCloud.recursive_hash
gnx: ekr.20201012111338.35
unl: class LeoCloud--&gt;LeoCloud.save_clouds
gnx: ekr.20201012111338.36
unl: class LeoCloud--&gt;LeoCloud.subtree_changed
gnx: ekr.20201012111338.37
unl: class LeoCloud--&gt;LeoCloud._to_json_serial
gnx: ekr.20201012111338.38
unl: class LeoCloud--&gt;LeoCloud.to_json
gnx: ekr.20201012111338.39
unl: class LeoCloud--&gt;LeoCloud._to_dict_recursive
gnx: ekr.20201012111338.40
unl: class LeoCloud--&gt;LeoCloud.to_dict
gnx: ekr.20201012111338.41
unl: class LeoCloud--&gt;LeoCloud._ua_clean
gnx: ekr.20201012111338.42
unl: class LeoCloud--&gt;LeoCloud.write_current
</t>
<t tx="ekr.20210129094203.1">g.cls()
import time
if c.changed:
    c.save()
g.execute_shell_commands('start cmd /k "python leoserver.py"')
time.sleep(0.5)
g.execute_shell_commands('start cmd /k "python leoclient.py"')
if 0:
    time.sleep(8)
    g.execute_shell_commands(r'moz c:\test\index.html')

</t>
<t tx="ekr.20210129104613.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1813

@language python
@nosearch
</t>
<t tx="ekr.20210202110128.29">class LeoServer:
    """Leo Server Controller"""
    @others
</t>
<t tx="ekr.20210202110128.30">def __init__(self, testing=False):

    import leo.core.leoApp as leoApp
    import leo.core.leoBridge as leoBridge
    import leo.core.leoExternalFiles as leoExternalFiles
    global g
    t1 = time.process_time()
    #
    # Init ivars first.
    self.c = None  # Currently Selected Commander.
    self.dummy_c = None  # Set below, after we set g.
    self.action = None
    self.bad_commands_list = []  # Set below.
    self.config = None
    self.current_id = 0  # Id of action being processed.
    self.log_flag = False  # set by "log" key
    #
    # Start the bridge.
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=False,   # True: attempt to load plugins.
        readSettings=False,  # True: read standard settings files.
        silent=True,         # True: don't print signon messages.
        verbose=False,       # True: prints messages that would be sent to the log pane.
    )
    self.g = g = self.bridge.globals()
    self.dummy_c = g.app.newCommander(fileName=None)  # To inspect commands
    self.bad_commands_list = self._bad_commands(self.dummy_c)
    #
    # Complete the initialization, as in LeoApp.initApp.
    g.app.idleTimeManager = leoApp.IdleTimeManager()
    g.app.idleTimeManager.start()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController(None)
    t2 = time.process_time()
    print(f"LeoServer: init leoBridge in {t2-t1:4.2} sec.")
</t>
<t tx="ekr.20210202110128.51">def _es(self, s):  # pragma: no cover (tested in client).
    """
    Send a response that does not correspond to a request.
    
    The response *must* have an "async" key, but *not* an "id" key.
    """
    tag = '_es'
    message = g.toUnicode(s)
    package = {"async": "", "s": message}
    response = json.dumps(package, separators=(',', ':'))
    if self.loop:
        self.loop.create_task(self._async_output(response))
    else:
        print(f"{tag}: Error loop not ready {message}")
</t>
<t tx="ekr.20210202110128.52">def _init_connection(self, web_socket):  # pragma: no cover (tested in client).
    """Begin the connection."""
    self.web_socket = web_socket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="ekr.20210202110128.54">def _do_message(self, d):
    """
    Handle d, a python dict representing the incoming request.
    d must have at least the following keys:
    
    - "id": A positive integer.
    - "action": A string, which is either:
        - The name of public method of this class.
        - The name of a Leo command.
    
    Return a dict, created by _make_response, containing least these keys:

    - "id":         Same as the incoming id.
    - "action":     Same as the incoming action.
    - "commander":  A dict describing self.c.
    - "node":       None, or an archived position describing self.c.p.
    """
    tag = '_do_message'
    # Require "id" and "action" keys. The "package" key is optional.
    id_ = d.get("id")
    if id_ is None:  # pragma: no cover
        raise ServerError(f"{tag}: no id")
    action = d.get("action")
    if action is None:  # pragma: no cover
        raise ServerError("f{tag}: no action")
    package = d.get('package', {})
    # Set log flag.
    self.log_flag = package.get("log")
    # Set the current_id and action ivars for _make_response.
    self.current_id = id_
    self.action = action
    # Execute the requested action.
    if action == "execute-leo-command":
        func = self._do_leo_command
    else:
        func = self._do_server_command
    result = func(action, package)
    if result is None:  # pragma: no cover
        raise ServerError(f"{tag}: no response: {action}")
    return result
</t>
<t tx="ekr.20210202110128.55">def get_all_open_commanders(self, package):
    """Return array describing each commander in g.app.commanders()."""
    files = [
        {
            "changed": c.isChanged(),
            "name": c.fileName(),
            "selected": c == self.c,
        } for c in g.app.commanders()
    ]
    return self._make_response({"open-commanders": files})
</t>
<t tx="ekr.20210202110128.57">def open_file(self, package):
    """
    Open a leo file with the given filename.
    Create a new document if no name.
    """
    found, tag = False, 'open_file'
    filename = package.get('filename')  # Optional.
    if filename:
        for c in g.app.commanders():
            if c.fileName() == filename:
                found = True
    if not found:
        c = self.bridge.openLeoFile(filename)
        c.findCommands.ftm = StringFindTabManager(c)
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: bridge did not open {filename!r}")
    if not c.frame.body.wrapper:  # pragma: no cover
        raise ServerError(f"{tag}: no wrapper")
    # Assign self.c
    self.c = c
    c.selectPosition(c.rootPosition())  # Required.
    # Check the outline!
    self._check_outline(c)
    if self.log_flag:  # pragma: no cover
        self._dump_outline(c)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.58">def close_file(self, package):
    """Closes an outline opened with open_file."""
    c = self._check_c()
    # Close the outline, even if it is dirty!
    c.clearChanged()
    c.close()
    # Select the first open outline, if any.
    commanders = g.app.commanders()
    self.c = commanders and commanders[0] or None
    # Return a response describing self.c, not the closed outline.
    return self._make_response()
</t>
<t tx="ekr.20210202110128.61">def get_ui_states(self, package):
    """
    Return the enabled/disabled UI states for the open commander, or defaults if None.
    """
    c = self._check_c()
    tag = 'get_ui_states'
    try:
        states = {
            "changed": c and c.changed,
            "canUndo": c and c.canUndo(),
            "canRedo": c and c.canRedo(),
            "canDemote": c and c.canDemote(),
            "canPromote": c and c.canPromote(),
            "canDehoist": c and c.canDehoist(),
        }
    except Exception as e:  # pragma: no cover
        raise ServerError(f"{tag}: Exception setting state: {e}")
    return self._make_response({"states": states})
</t>
<t tx="ekr.20210202110128.63">def page_up(self, package):
    """
    Selects a node "N" steps up in the tree to simulate page up.
    """
    c = self._check_c()
    n = package.get("n", 3)
    for z in range(n):
        c.selectVisBack()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.64">def page_down(self, package):
    """
    Selects a node "n" steps down in the tree to simulate page down.
    """
    c = self._check_c()
    n = package.get("n", 3)
    for z in range(n):
        c.selectVisNext()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.66">def get_body_states(self, package):
    """
    Return body data for p, where p is c.p if package["ap"] is missing.
    """
    c = self._check_c()
    p = self._get_p(package)
    wrapper = c.frame.body.wrapper
    
    def row_col_dict(i):
        junk, line, col = wrapper.toPythonIndexRowCol(i)
        return {"line": line, "col": col}
        
    # Get the language.
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language')
        or g.getLanguageFromAncestorAtFileNode(p)
        or c.config.getLanguage('target-language')
        or 'plain'
    )
    # get values from wrapper if it's the selected node.
    if c.p.v.gnx == p.v.gnx:
        active = wrapper.getInsertPoint()
        start, end = wrapper.getSelectionRange(True)
        scroll = wrapper.getYScrollPosition()
    else:  # pragma: no cover
        active = p.v.insertSpot
        start = p.v.selectionStart
        end = p.v.selectionStart + p.v.selectionLength
        scroll = p.v.scrollBarSpot
    states = {
        'language': language.lower(),
        'selection': {
            # "gnx": p.v.gnx,  # EKR: Not needed. The reponse will have p.v.gnx.
            "scroll": scroll,
            "active": row_col_dict(active),
            "start": row_col_dict(start),
            "end": row_col_dict(end),
        }
    }
    return self._make_response({"body-states": states})
</t>
<t tx="ekr.20210202110128.68">def get_children(self, package):
    """
    Return the node data for children of p, where p is c.p if package["ap"] is missing."""
    self._check_c()
    p = self._get_p(package)
    return self._make_response({
        # "children": [self._p_to_ap(child) for child in p.children()]
        "children": [self._get_position_d(child) for child in p.children()]
    })
</t>
<t tx="ekr.20210202110128.69">def get_parent(self, package):
    """Return the node data for the parent of position p, where p is c.p if package["ap"] is missing."""
    self._check_c()
    p = self._get_p(package)
    parent = p.parent()
    data = self._get_position_d(parent) if parent else None
    return self._make_response({"parent": data})
</t>
<t tx="ekr.20210202110128.71">def get_all_positions(self, package):
    """
    Return a list of position data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = [
        self._get_position_d(p) for p in c.all_positions(copy=False)
    ]
    return self._make_response({"position-data-list": result})
</t>
<t tx="ekr.20210202110128.72">def get_body(self, package):
    """
    Return p.b, where p is c.p if package["ap"] is missing.
    
    Note: There is no need for a separate get_body_length command,
          because _make_response always adds "body-length": len(p.b)
    """
    self._check_c()
    p = self._get_p(package)
    # _make_response adds all the cheap redraw data, including "body-length"
    return self._make_response({"body": p.b})
    
</t>
<t tx="ekr.20210202110128.74">def set_body(self, package):
    """
    Undoably set p.b, where p is c.p if package["ap"] is missing.
    """
    tag = 'set_body'
    c = self._check_c()
    p = self._get_p(package)
    u, wrapper = c.undoer, c.frame.body.wrapper
    body = package.get('body')
    if body is None:  # pragma: no cover
        raise ServerError(f"{tag}: no body given")
    bunch = u.beforeChangeNodeContents(p)
    p.v.setBodyString(body)
    u.afterChangeNodeContents(p, "Body Text", bunch)
    if c.p == p:
        wrapper.setAllText(body)
    if not self.c.isChanged():  # pragma: no cover
        c.setChanged()
    if not p.v.isDirty():  # pragma: no cover
        p.setDirty()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.75">def set_selection(self, package):
    """
    Set the selection range for p.b, where p is c.p if package["ap"] is missing.
    
    Set the selection in the wrapper if p == c.p
    
    Package has these keys:
        
    - "ap":     An archived position for position p.
    - "start":  The start of the selection.
    - "end":    The end of the selection.
    - "insert": The insert point. Must be either start or end.
    - "scroll": An optional scroll position.
    """
    c = self._check_c()
    p = self._get_p(package)  # Will raise ServerError if p does not exist.
    v = p.v
    wrapper = c.frame.body.wrapper
    start = package.get('start', 0)
    end = package.get('end', 0)
    insert = package.get('insert', 0)
    scroll = package.get('scroll', 0)
    if p == c.p:
        wrapper.setSelectionRange(start, end, insert)
        wrapper.setYScrollPosition(scroll)
    # Always set vnode attrs.
    v.scrollBarSpot = scroll
    v.insertSpot = insert
    v.selectionStart = start
    v.selectionLength = abs(start - end)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.76">def set_headline(self, package):
    """
    Undoably set p.h, where p is c.p if package["ap"] is missing.
    """
    tag = 'set_headline'
    c = self._check_c()
    p = self._get_p(package)
    u = c.undoer
    h = package.get('headline')
    if not h:  # pragma: no cover
        raise ServerError(f"{tag}: no headline")
    bunch = u.beforeChangeNodeContents(p)
    p.h = h
    u.afterChangeNodeContents(p, 'Change Headline', bunch)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.77">def set_current_position(self, package):
    """Select position p, where p is c.p if package["ap"] is missing."""
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    return self._make_response()
</t>
<t tx="ekr.20210202110128.78">def expand_node(self, package):
    """
    Expand the node at position p, where p is c.p if package["ap"] is missing.
    
    To expand c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "expand-node",
    }
    """
    self._check_c()
    p = self._get_p(package)
    p.expand()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.79">def contract_node(self, package):
    """
    Contract the node at position p, where p is c.p if package["ap"] is missing.
    
    To contract c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "contract-node",
    }
    """
    self._check_c()
    p = self._get_p(package)
    p.contract()
    return self._make_response()
</t>
<t tx="ekr.20210202110128.84">def _test_round_trip_positions(self, c):  # pragma: no cover (tested in client).
    """Test the round tripping of p_to_ap and ap_to_p."""
    tag = '_test_round_trip_positions'
    for p in c.all_unique_positions():
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        if p != p2:
            self._dump_outline(c)
            raise ServerError(f"{tag}: round-trip failed: ap: {ap}, p: {p}, p2: {p2}")
</t>
<t tx="ekr.20210202110128.85">def _ap_to_p(self, ap):
    """
    Convert ap (archived position, a dict) to a valid Leo position.
    Raise ServerError on any kind of error.
    """
    tag = '_ap_to_p'
    c = self._check_c()
    gnx_d = c.fileCommands.gnxDict
    outer_stack = ap.get('stack')
    if outer_stack is None:  # pragma: no cover.
        raise ServerError(f"{tag}: no stack in ap: {ap}")
    if not isinstance(outer_stack, (list, tuple)):  # pragma: no cover.
        raise ServerError(f"{tag}: stack must be tuple or list: {outer_stack}")
    
    def d_to_childIndex_v (d):
        """Helper: return childIndex and v from d ["childIndex"] and d["gnx"]."""
        childIndex = d.get('childIndex')
        if childIndex is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no childIndex in {d}")
        try:
            childIndex = int(childIndex)
        except Exception:  # pragma: no cover.
            raise ServerError(f"{tag}: bad childIndex: {childIndex!r}")
        gnx = d.get('gnx')
        if gnx is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no gnx in {d}.")
        v = gnx_d.get(gnx)
        if v is None:  # pragma: no cover.
            raise ServerError(f"{tag}: gnx not found: {gnx}")
        return childIndex, v
    #
    # Compute p.childIndex and p.v.
    childIndex, v = d_to_childIndex_v(ap)
    #
    # Create p.stack.
    stack = []
    for stack_d in outer_stack:
        stack_childIndex, stack_v = d_to_childIndex_v(stack_d)
        stack.append((stack_v, stack_childIndex))
    #
    # Make p and check p.
    p = Position(v, childIndex, stack)
    if not c.positionExists(p):  # pragma: no cover.
        print(
            f"{tag}: Bad ap: {ap}\n"
            # f"{tag}: position: {p!r}\n"
            f"{tag}: v {v!r} childIndex: {childIndex}\n"
            f"{tag}: stack: {stack}")
        raise ServerError(f"{tag}: p does not exist in {c.shortFileName()}")
    return p
</t>
<t tx="ekr.20210202110128.86">def _p_to_ap(self, p):
    """
    Convert Leo position p to a serializable archived position.
    
    This returns only position-related data.
    get_position_data returns all data needed to redraw the screen.
    """
    self._check_c()
    stack = [{'gnx': v.gnx, 'childIndex': childIndex}
        for (v, childIndex) in p.stack]
    return {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'stack': stack,
    }
</t>
<t tx="ekr.20210202183724.1">def save_file(self, package):  # pragma: no cover (too dangerous).
    """Save the leo outline."""
    c = self._check_c()
    c.save()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.10">def toggle_mark(self, package):
    """
    Toggle the mark at position p, where p is c.p if package["ap"] is missing.
    
    To *toggle* the mark of c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "toggle-mark",
    }
    """
    self._check_c()
    p = self._get_p(package)
    if p.isMarked():
        p.clearMarked()
    else:
        p.setMarked()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.11">def clone_node(self, package):
    """
    Clone the node at position p, where p is c.p if package["ap"] is missing.
    
    To clone c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "clone",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.clone()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.12">def cut_node(self, package):  # pragma: no cover (too dangerous, for now)
    """
    Cut the node (and its descendants) at position p, where p is c.p if package["ap"] is missing.
    
    To cut c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "cut-node",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.cutOutline()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.13">def delete_node(self, package):  # pragma: no cover (too dangerous, for now)
    """
    Delete the node (and its descendants) at position p, where p is c.p if package["ap"] is missing.
    
    To delete c.p, use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "delete-node",
    }
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.deleteOutline()  # Handles undo.
    return self._make_response()
</t>
<t tx="ekr.20210202183724.15">def insert_node(self, package):
    """
    Insert a new node at position p, where p is c.p if package["ap"] is missing.

    This node has 'newHeadline' as its headline.
    
    To insert a new node at c.p (with the default headline), use this request:
    {
        "action": "execute-leo-command",
        "leo-command-name": "insert-node",
    }
    
    Use the 'set_headline' method to undoably set any node's headlines.
    """
    c = self._check_c()
    p = self._get_p(package)
    c.selectPosition(p)
    c.insertHeadline()  # Handles undo, sets c.p
    return self._make_response()
</t>
<t tx="ekr.20210202183724.16">def undo(self, package):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canUndo():
        u.undo()
    # Félix: Caller can get focus using other calls.
    return self._make_response()
</t>
<t tx="ekr.20210202183724.17">def redo(self, package):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canRedo():
        u.redo()
    return self._make_response()
</t>
<t tx="ekr.20210202183724.2">def get_buttons(self, package):  # pragma: no cover (no scripting controller)
    """Gets the currently opened file's @buttons list"""
    d = self._check_button_command('get_buttons')
    return self._make_response({
        "buttons": sorted(list(d.get.keys()))
    })
</t>
<t tx="ekr.20210202183724.3">def remove_button(self, package):  # pragma: no cover (no scripting controller)
    """Remove button by name."""
    tag = 'remove_button'
    name = package.get("name")
    if not name:
        raise ServerError(f"{tag}: no button name given")
    d = self._check_button_command(tag)
    if name not in d:
        raise ServerError(f"{tag}: button {name!r} does not exist")
    try:
        del d [name]
    except Exception as e:
        raise ServerError(f"{tag}: exception removing button {name}: {e}")
    return self._make_response({
        "buttons": sorted(list(d.get.keys()))
    })
</t>
<t tx="ekr.20210202183724.4">def click_button(self, package):  # pragma: no cover (no scripting controller)
    """Handles buttons clicked in client from the '@button' panel"""
    tag = 'click_button'
    name = package.get("name")
    if not name:
        raise ServerError(f"{tag}: no button name given")
    d = self._check_button_command(tag)
    button = d.get(name)
    if not button:
        raise ServerError(f"{tag}: button {name!r} does not exist")
    try:
        button.command()
    except Exception as e:
        raise ServerError(f"{tag}: exception clicking button {name}: {e}")
    return self._make_response()
</t>
<t tx="ekr.20210202183724.5">def get_all_leo_commands(self, package):
    """Return a list of all Leo commands that make sense in leoInteg."""
    tag = 'get_all_leo_commands'
    c = self.dummy_c  # Use the dummy commander.
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands(c)  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:  # pragma: no cover
        print('duplicate command names...')
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:  # pragma: no cover
            print('no func:', command_name)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:  # pragma: no cover
            print('no name', command_name)
            continue
        doc = func.__doc__ or ''
        result.append({
            "command-name": command_name,
            "func":  func_name,
            "detail": doc,
        })
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(result)} leo commands\n")
        g.printObj([z.get("command-name") for z in result], tag=tag)
    return self._make_response({"commands": result})
</t>
<t tx="ekr.20210202183724.6">def _bad_commands(self, c):
    """Return the list of Leo's command names that leoInteg should ignore."""
    d = c.commandsDict  # keys are command names, values are functions.
    bad = []
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="ekr.20210202183724.7">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',
        'clone-find-all-flattened',
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-all-settings',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="ekr.20210202193505.1"></t>
<t tx="ekr.20210202193540.1"></t>
<t tx="ekr.20210202193642.1"></t>
<t tx="ekr.20210202193709.1"># These will fail unless the open_file inits c.theScriptingController.
</t>
<t tx="ekr.20210204145818.1">async def _async_output(self, json):  # pragma: no cover (tested in server)
    """Output json string to the web_socket"""
    tag = '_async_output'
    if self.web_socket:
        await self.web_socket.send(bytes(json, 'utf-8'))
    else:
        g.trace(f"{tag}: no web socket. json: {json}")
</t>
<t tx="ekr.20210204154548.1"></t>
<t tx="ekr.20210205102806.1"></t>
<t tx="ekr.20210205102818.1">def error(self, package):
    """For unit testing. Raise ServerError"""
    raise ServerError(f"error called")
</t>
<t tx="ekr.20210205103759.1">def shut_down(self, package):
    """Shut down the server."""
    tag = 'shut_down'
    n = len(g.app.commanders())
    if n:  # pragma: no cover
        raise ServerError(f"{tag}: {n} open outlines")
    raise TerminateServer(f"client requested shut down")
</t>
<t tx="ekr.20210206062654.1">def get_sign_on(self, package):
    """Synchronous version of _sign_on"""
    g.app.computeSignon()
    signon = []
    for z in (g.app.signon, g.app.signon1):
        for z2 in z.split('\n'):
            signon.append(z2.strip())
    return self._make_response({"sign-on": "\n".join(signon)})
</t>
<t tx="ekr.20210206182638.1">def _make_response(self, package=None):
    """
    Return a json string representing a response dict.
    
    The 'package' kwarg, if present, must be a python dict describing a
    response. package may be an empty dict or None.
    
    The 'p' kwarg, if present, must be a position.
    
    First, this method creates a response (a python dict) containing all
    the keys in the 'package' dict, with the following added keys:
        
    - "id":         The incoming id.
    - "action":     The incoming action.
    - "commander":  A dict describing self.c.
    - "node":       None, or an archived position describing self.c.p.
    
    Finally, this method returns the json string corresponding to the
    response.
    """
    tag = '_make_response'
    c = self.c  # It is valid for c to be None.
    if package is None:
        package = {}
    p = package.get("p")
    if p:
        del package ["p"]
    # Raise an *internal* error if checks fail.
    if isinstance(package, str):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad package kwarg: {package!r}")
    if p and not isinstance(p, Position):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad p kwarg: {p!r}")
    if p and not c:  # pragma: no cover
        raise InternalServerError(f"{tag}: p but not c")
    if p and not c.positionExists(p):  # pragma: no cover
        raise InternalServerError(f"{tag}: p does not exist")
    if c and not c.p:  # pragma: no cover
        raise InternalServerError(f"{tag}: empty c.p")
    #
    # Always add these keys.
    package ["id"] = self.current_id
    package ["action"] = self.action
    # The following keys are relevant only if there is an open commander.
    if c:
        # Allow commands, especially _get_redraw_d, to specify p!
        p = p or c.p
        package ["commander"] = {
            "changed": c.isChanged(),
            "file_name": c.fileName(), # Can be None for new files.
        }
        # Add all the node data, including:
        # - "node": self._p_to_ap(p) # Contains p.gnx, p.childIndex and p.stack.
        # - All the *cheap* redraw data for p.
        redraw_d = self._get_position_d(p)
        for key, value in redraw_d.items():
            if key in package:  # pragma: no cover
                raise InternalServerError(f"{tag}: key {key} in package: {package}")
            package [key] = value
    if self.log_flag:  # pragma: no cover
        g.printObj(package, tag=f"{tag} returns")
    return json.dumps(package, separators=(',', ':')) 
</t>
<t tx="ekr.20210207051720.1">def _check_button_command(self, tag):  # pragma: no cover (no scripting controller)
    """
    Check that a button command is possible.
    Raise ServerError if not. Otherwise, return sc.buttonsDict.
    """
    c = self._check_c()
    sc = getattr(c, "theScriptingController", None)
    if not sc:
        # This will happen unless mod_scripting is loaded!
        raise ServerError(f"{tag}: no scripting controller")
    return sc.buttonsDict
</t>
<t tx="ekr.20210207054237.1">def _check_c(self):
    """Return self.c or raise ServerError if self.c is None."""
    tag = '_check_c'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no open commander")
    return c
</t>
<t tx="ekr.20210208163018.1">class TestLeoServer (unittest.TestCase):  # pragma: no cover
    """Tests of LeoServer class."""
    request_number = 0

    @others
</t>
<t tx="ekr.20210208163409.1">"""Run unittest on leoserver.py: good for debugging."""
g.cls()
import os
if c.changed:
    c.save()
leo_dir = os.path.join(g.app.loadDir, '..', '..')
assert os.path.exists(leo_dir), repr(leo_dir)
os.chdir(leo_dir)
# leoserver.main detects and removes the --unittest command-line arg.
g.execute_shell_commands('python -m leo.core.leoserver --unittest')
</t>
<t tx="ekr.20210208171319.1">def test_open_and_close(self):
    # server = self.server
    test_dot_leo = g.os_path_finalize_join(g.app.loadDir, '..', 'test', 'test.leo')
    assert os.path.exists(test_dot_leo), repr(test_dot_leo)
    log = False
    table = [
        # Open file.
        ("open_file", {"log": log, "filename": "xyzzy.leo"}),  # Does not exist.
        # Switch to the second file.
        ("open_file", {"log": log, "filename": test_dot_leo}),   # Does exist.
        # Open again. This should be valid.
        ("open_file", {"log": False, "filename": test_dot_leo}),
        # Better test of _ap_to_p.
        ("set_current_position", {
            "ap": {
                "gnx": "ekr.20180311131424.1",  # Recent
                "childIndex": 1,
                "stack": [],
            }
        }),
        ("get_ua", {"log": log}),
        # Close the second file.
        ("close_file", {"log": log, }),
        # Close the first file.
        ("close_file", {"log": log, }),
    ]
    for action, package in table:
        self._request(action, package)
</t>
<t tx="ekr.20210208171819.1">def _request(self, action, package=None):
    server = self.server
    self.request_number += 1
    log_flag = package.get("log")
    d = {
        "action": action,
        "id": self.request_number
    }
    if package:
        d ["package"] = package
    response = server._do_message(d)
    # _make_response calls json_dumps. Undo it with json.loads.
    answer = json.loads(response)
    if log_flag:
        g.printObj(answer, tag=f"response to {action}")
    return answer
</t>
<t tx="ekr.20210209055518.1">def get_all_server_commands(self, package):
    """
    Public server method:
    Return the names of all callable public methods of the server.
    """
    tag = 'get_all_server_commands'
    names = self._get_all_server_commands()
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(names)} server commands\n")
        g.printObj(names, tag=tag)
    return self._make_response({"server-commands": names})

def _get_all_server_commands(self):
    """
    Private server method:
    Return the names of all callable public methods of the server.
    """
    members = inspect.getmembers(self, inspect.ismethod)
    return sorted([name for (name, value) in members if not name.startswith('_')])
</t>
<t tx="ekr.20210209062536.1">def _do_leo_command(self, action, package):
    """
    Execute the leo command given by package ["leo-command-name"].
    
    The client must open an outline before calling this method.
    """
    # We *can* require self.c to exist, because:
    # 1. all commands imply c.
    # 2. The client must call open_file to set self.c.
    tag = '_execute_leo_command'
    c = self._check_c()
    command_name = package.get("leo-command-name")
    if not command_name:  # pragma: no cover
        raise ServerError(f"{tag}: no 'leo-command-name' key in package")
    if command_name in self.bad_commands_list:  # pragma: no cover
        raise ServerError(f"{tag}: disallowed command: {command_name}")
    func = c.commandsDict.get(command_name)
    if not func:  # pragma: no cover
        raise ServerError(f"{tag}: Leo command not found: {command_name}")
    value = func(event={"c":c})
    return self._make_response({"return-value": value})
</t>
<t tx="ekr.20210209085438.1">def _do_server_command(self, action, package):
    tag = '_do_server_command'
    # Disallow hidden methods.
    if action.startswith('_'):  # pragma: no cover
        raise ServerError(f"{tag}: action starts with '_': {action}")
    # Find and execute the server method.
    func = getattr(self, action, None)
    if not func:
        raise ServerError(f"{tag}: action not found: {action}")  # pragma: no cover
    if not callable(func):
        raise ServerError(f"{tag}: not callable: {func}")  # pragma: no cover
    return func(package)
</t>
<t tx="ekr.20210209150755.1">@nosearch

# Ignore Case, Head, Body

# found 12 nodes</t>
<t tx="ekr.20210209151428.1">@nosearch

# Ignore Case, Head, Body

# found 11 nodes</t>
<t tx="ekr.20210209151948.1">@nosearch

# Word, Ignore Case, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210209152020.1">@nosearch

# Word, Ignore Case, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210209152725.1">@nosearch

# Word, Ignore Case, Head, Body

# found 10 nodes</t>
<t tx="ekr.20210209153451.1">@nosearch

# Word, Ignore Case, Head, Body

# found 6 nodes</t>
<t tx="ekr.20210210060738.1">@nosearch</t>
<t tx="ekr.20210210081236.1">def _get_p(self, package):
    """Return _ap_to_p(package["ap"]) or c.p."""
    tag = '_get_ap'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no c")
    ap = package.get("ap")
    if ap:
        p = self._ap_to_p(ap)
        if not p:  # pragma: no cover
            raise ServerError(f"{tag}: no p")
        if not c.positionExists(p):  # pragma: no cover
            raise ServerError(f"{tag}: position does not exist. ap: {ap}")
    if not c.p:  # pragma: no cover
        raise ServerError(f"{tag}: no c.p")
    return c.p
</t>
<t tx="ekr.20210210102638.1">def test_most_public_server_methods(self):
    server=self.server
    assert isinstance(server, g_leoserver.LeoServer), self.server
    test_dot_leo = g.os_path_finalize_join(g.app.loadDir, '..', 'test', 'test.leo')
    assert os.path.exists(test_dot_leo), repr(test_dot_leo)
    methods = server._get_all_server_commands()
    # Ensure that some methods happen at the end.
    for z in ('toggle_mark', 'undo', 'redo'):
        methods.remove(z)
    for z in ('toggle_mark', 'toggle_mark', 'undo', 'redo'):
        methods.append(z)
    # g.printObj(methods, tag=methods)
    exclude = [
        # Find methods...
        'change_all', 'change_then_find',
        'clone_find_all', 'clone_find_all_flattened', 'clone_find_tag',
        'find_all', 'find_def', 'find_next', 'find_previous', 'find_var',
        'tag_children',  
        # Other methods
        'delete_node', 'cut_node',  # dangerous.
        'click_button', 'get_buttons', 'remove_button',  # Require plugins.
        'save_file',  # way too dangerous!
        # 'set_selection',  ### Not ready yet.
        'open_file', 'close_file',  # Done by hand.
        'shut_down',  # Don't shut down the server.
    ]
    expected = ['error']
    package_d = {
        # "apply_config": {"config": {"whatever": True}},
        "get_focus": {"log": False},
        "set_body": {"body": "new body\n"},
        "set_headline": {"headline": "new headline"},
        "get_all_server_commands": {"log": False},
        "get_all_leo_commands": {"log": False},
    }
    # First open a test file &amp; performa all tests.
    server.open_file({"filename": test_dot_leo})  # A real file.
    try:
        id_ = 0
        for method_name in methods:
            id_ += 1
            if method_name not in exclude:
                assert getattr(server, method_name), method_name
                package = package_d.get(method_name, {})
                message = {
                    "id": id_,
                    "action": method_name,
                    "package": package,
                }
                try:
                    # Don't call the method directly.
                    # That would disable trace/verbose logic, checking, etc.
                    server._do_message(message)
                except Exception as e:
                    if method_name not in expected:
                        print(f"Exception in test_most_public_server_methods: {method_name} {e}")
    finally:
        server.close_file({"filename": test_dot_leo})
</t>
<t tx="ekr.20210210174801.1">def test_leo_commands (self):
    server = self.server
    table = [
        # Toggle mark twice.
        ("toggle-mark", {}),
        ("toggle-mark", {}),
    ]
    # First open a test file.
    server.open_file({"filename": "xyzzy.leo"})
    try:
        action = "execute-leo-command"
        for command_name, package in table:
            package ["leo-command-name"] = command_name
            self._request(action, package)
    finally:
        server.close_file({"filename": "xyzzy.leo"})
</t>
<t tx="ekr.20210211053733.1">def _get_position_d(self, p):
    """
    Return a python dict containing:
    - "node": self._p_to_ap(p).
    - All *cheap* redraw data..
    
    Use get_ua to get p.ua *plus* all this redraw data.
    
    Note: v.computeIcon sets iconVal as follows:
        v, val = self, 0
        if v.hasBody(): val += 1
        if v.isMarked(): val += 2
        if v.isCloned(): val += 4
        if v.isDirty(): val += 8
    """
    return {
        "node": self._p_to_ap(p), # Contains p.gnx, p.childIndex and p.stack.
        # The cheap redraw data...
        "body-length": len(p.b),  # *Not* p.b.
        "has-children": p.hasChildren(),  # *Not* p.children().
        "has-ua": bool(p.v.u),  # *Not* p.v.u.
        "headline": p.h,
        "icon-val": p.v.iconVal,  # An int between 0 and 15.
        "is-at-file": p.isAnyAtFileNode(),
        "level": p.level(),  # Useful for debugging.
    }
</t>
<t tx="ekr.20210211053955.1">def get_position_data_dict(self, package):
    """
    Return a dict of postition data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = {
        p.v.gnx: self._get_position_d(p)
            for p in c.all_unique_positions(copy=False)
    }
    return self._make_response({"position-data-dict": result})
</t>
<t tx="ekr.20210211084004.1"></t>
<t tx="ekr.20210211085544.1">@classmethod
def setUpClass(cls):
    # Assume we are running in the leo-editor directory.
    # pylint: disable=import-self
    import leo.core.leoserver as leoserver
    global g, g_leoserver, g_server
    g_leoserver = leoserver
    g_server = leoserver.LeoServer(testing=True)
    g = g_server.g
    assert g

@classmethod
def tearDownClass(cls):
    global g_leoserver, g_server
    try:
        g_server.shut_down({})
        print('===== server did not terminate properly ====')
    except g_leoserver.TerminateServer:
        pass

def setUp(self):
    global g_server
    self.server = g_server
    g.unitTesting = True
    
def tearDown(self):
    g.unitTesting = False 
    
</t>
<t tx="ekr.20210211131234.1">def _check_outline(self, c):
    """Check self.c for consistency."""
    # Check that all positions exist.
    self._check_outline_positions(c)
    # Test round-tripping.
    self._test_round_trip_positions(c)
</t>
<t tx="ekr.20210211131707.1">def _dump_outline(self, c):  # pragma: no cover
    """Dump the outline."""
    tag = '_dump_outline'
    print(f"{tag}: {c.shortFileName()}...\n")
    for p in c.all_positions():
        self._dump_position(p)
    print('')

def _dump_position(self, p):  # pragma: no cover
    level_s = ' ' * 2 * p.level()
    print(f"{level_s}{p.childIndex():2} {p.v.gnx} {p.h}")
</t>
<t tx="ekr.20210211131827.1">def _check_outline_positions(self, c):
    """Verify that all positions in c exist."""
    tag = '_check_outline_positions'
    for p in c.all_positions(copy=False):
        if not c.positionExists(p):  # pragma: no cover
            message = f"{tag}: position {p} does not exist in {c.shortFileName()}"
            print(message)
            self._dump_position(p)
            raise ServerError(message)
</t>
<t tx="ekr.20210211233814.1">def get_ua(self, package):
    """Return p.v.u, making sure it can be serialized."""
    self._check_c()
    p = self._get_p(package)
    try:
        ua = {"ua": p.v.u}
        json.dumps(ua, separators=(',', ':'))
        response = {"p": p, "ua": p.v.u} 
    except Exception:  # pragma: no cover
        response = {"p": p, "bad-ua": repr(p.v.u)} 
    # _make_response adds all the cheap redraw data.
    return self._make_response(response)
</t>
<t tx="ekr.20210212004223.1">- End nameless fears. Trace.
- Does scrolling ever cause redraw?
- QTree.ensureVisible?
- What do leoflexx and curses gui do?</t>
<t tx="ekr.20210212051716.1">"""Run py-cov on leoserver.py"""
g.cls()
import os
if c.changed:
    c.save()
leo_dir = os.path.join(g.app.loadDir, '..', '..')
assert os.path.exists(leo_dir), repr(leo_dir)
os.chdir(leo_dir)
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
command = prolog + r"leo.core.leoserver leo\core\leoserver.py"
g.execute_shell_commands(command)
</t>
<t tx="ekr.20210212092848.1"></t>
<t tx="ekr.20210212092854.1">def find_all(self, package):
    """Run Leo's find-all command and return results."""
    tag = 'find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210212093613.1">def test_find_commands(self):
    
    tag = 'test_find_commands'
    test_dot_leo = g.os_path_finalize_join(g.app.loadDir, '..', 'test', 'test.leo')
    assert os.path.exists(test_dot_leo), repr(test_dot_leo)
    log = False
    # Open the file &amp; create the StringFindTabManager.
    self._request("open_file", {"log": False, "filename": test_dot_leo})
    #
    # Batch find commands: The answer is a count of found nodes.
    for method in ('find_all', 'clone_find_all', 'clone_find_all_flattened'):
        answer = self._request(method, {"log": log, "find_text": "def"})
        if log: g.printObj(answer, tag=f"{tag}:{method}: answer")
    #
    # Find commands that may select text: The answer is (p, pos, newpos).
    for method in ('find_next', 'find_previous', 'find_def', 'find_var'):
        answer = self._request(method, {"log": log, "find_text": "def"})
        if log: g.printObj(answer, tag=f"{tag}:{method}: answer")
    #
    # Change commands: The answer is a count of changed nodes.
    for method in ('change_all', 'change_then_find'):
        answer = self._request(method, {"log": log, "find_text": "def", "change_text": "DEF"})
        if log: g.printObj(answer, tag=f"{tag}:{method}: answer")
    #
    # Tag commands. Why they are in leoFind.py??
    for method in ('clone_find_tag', 'tag_children'):
        answer = self._request(method, {"log": log, "tag": "my-tag"})
        if log: g.printObj(answer, tag=f"{tag}:{method}: answer")
   
</t>
<t tx="ekr.20210212094817.1">def _get_find_settings(self, c):
    """Return a g.Bunch containing the present find settings settings."""
    return c.findCommands.ftm.get_settings()
    ###
        # # For now, return EKR defaults.
        # return g.Bunch(
            # find_text=None, change_text=None,
            # search_body=True, search_headline=True,
            # ignore_case=True, pattern_match=False, whole_word=True,
            # mark_changes=False, mark_finds=False,
            # node_only=False, suboutline_only=False,
            # entry_focus=None,
        # )  
</t>
<t tx="ekr.20210214154432.1"></t>
<t tx="ekr.20210214154702.1">def get_focus(self, packages):
    """
    Return a representation of the focs widget,
    one of ("body", "tree", "headline", repr(the_widget)).
    """
    w = g.app.gui.get_focus()
    focus = g.app.gui.widget_name(w)
    return self._make_response({"focus": focus})
</t>
<t tx="ekr.20210215070414.1">"""Run unittest on leoserver.py: good for debugging."""
g.cls()
import os
if c.changed:
    c.save()
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
g.execute_shell_commands('python -m unittest leo.core.leoFind')
</t>
<t tx="ekr.20210216094444.1">def test_find_prev(self):
    c, settings, x = self.c, self.settings, self.x
    settings.find_text = 'def top1'
    # Start at end, so we stay in the node.
    last = c.lastTopLevel()
    child = last.firstChild()
    grand_child = child.firstChild()
    assert grand_child.h == 'child 6', grand_child.h
    settings.p = grand_child.copy()
    settings.find_text = 'def child2'
    # Set c.p in the command.
    x.c.selectPosition(grand_child)
    p, pos, newpos = x.do_find_prev(settings)
    assert p and p.h == 'child 2', repr(p and p.h)
    s = p.b[pos:newpos]
    assert s == settings.find_text, repr(s)
</t>
<t tx="ekr.20210216102036.1">"""Run py-cov on leoserver.py"""
g.cls()
import os
if c.changed:
    c.save()
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
prolog = "python -m pytest --cov-report html --cov-report term-missing --cov "
command = prolog + r"leo.core.leoFind leo\core\leoFind.py"
g.execute_shell_commands(command)
</t>
<t tx="ekr.20210217060252.1">def trimTrailingLines(self, p):
    """Trims trailing blank lines from a node.

    It is surprising difficult to do this during Untangle."""
    ### c = self
    body = p.b
    lines = body.split('\n')
    i = len(lines) - 1; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line, 0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1; changed = True
        else: break
    if changed:
        p.b = ''.join(body) + '\n'  # Add back one last newline.
        # Don't set the dirty bit: it would just be annoying.
</t>
<t tx="ekr.20210218065110.1">@language rest
@wrap

ekr-keyboard branch.

See https://github.com/leo-editor/leo-editor/issues/1563 concerning German keyboards.

</t>
<t tx="ekr.20210218070942.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/pull/1818
</t>
<t tx="ekr.20210218130800.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1821

docs: https://leoeditor.com/coloring.html#match-mark-previous

*** Bug: specifying @edit creates @path node.

@language python
@nosearch</t>
<t tx="ekr.20210219120137.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/pull/1822

@language python
</t>
<t tx="ekr.20210219175850.1">def test_batch_change_word(self):
    # settings, x = self.settings, self.x
    c, x = self.c, self.x
    settings = dict(
        ignore_case=False,
        node_only=False,
        pattern_match=False,
        search_body=True,
        search_headline=True,
        suboutline_only=False,
        whole_word=True,
    )
    n = x.batch_change(
        root=c.rootPosition(),
        replacements=(('def', 'DEF'),),
        settings=settings)
    assert n &gt; 0
    
</t>
<t tx="ekr.20210219181001.1">def test_batch_change_regex(self):
    c, x = self.c, self.x
    # self.dump_tree()
    # Test 1: Match in body.
    settings = dict(
        ignore_case=False,
        node_only=False,
        pattern_match=True,
        search_body=True,
        search_headline=True,
        suboutline_only=False,
        whole_word=False,
    )
    # Test 1: Match in body.
    n = x.batch_change(
        root=c.rootPosition(),
        replacements=((r'^def\b', 'DEF'),),
        settings=settings)
    assert n &gt; 3, n  # Test 1.
    # Test 2: Match in headline.
    n = x.batch_change(
        root=c.rootPosition(),
        replacements=((r'^Node\b', 'DEF'),),
        settings=settings)
    assert n == 2, n  # Test 2.
    # Test 3: node-only.
    settings ['node_only'] = True
    n = x.batch_change(
        root=c.rootPosition(),
        replacements=((r'^DEF\b', 'def'),),
        settings=settings)
    assert n == 1, n  # Text 3.
    # Test 4: suboutline-only.
    settings ['node_only'] = False
    settings ['suboutline_only'] = True
    n = x.batch_change(
        root=c.rootPosition(),
        replacements=((r'^def\b', 'DEF'),),
        settings=settings)
    assert n == 1, n  # Test 4.
</t>
<t tx="ekr.20210220070051.1">def make_find_tab_manager(self, c):
    """
    Create a proxy FindTabManager sufficient to run unit tests.
    In the Qt gui, the DynamicWindow class creates the FindTabManager.
    """
    from leo.core.leoGui import StringLineEdit
    from leo.plugins.qt_frame import FindTabManager
    x = self.x
    x.ftm = FindTabManager(c)
    #
    # Create a find_findbox for find.set_find_text.
    x.ftm.find_findbox = StringLineEdit(name='findbox', disabled=False)
    #
    # Create widgets for set_find_scope.
    class StringWidget:
        """A widget simulating both a Qt checkbox and a Qt radio button."""

        value = False
        
        def toggle(self):  # For radio buttons.
            self.value = not self.value
            
        def isChecked(self):  # For checkboxes.
            return self.value
            
        checkState = isChecked
        
    x.ftm.radio_button_suboutline_only = StringWidget()
    # Similar to the table in find.compute_find_options_in_status_area:
    table = (
        'check_box_whole_word',
        'check_box_ignore_case',
        'check_box_regexp',
        'check_box_search_body',
        'check_box_search_headline',
        'check_box_mark_changes',
        'check_box_mark_finds',
    )
    for ivar in table:
        setattr(x.ftm, ivar, StringWidget())
</t>
<t tx="ekr.20210220072631.1">def test_find_next_suboutline_only(self):
    settings, x = self.settings, self.x
    settings.find_text = 'def root()'
    settings.suboutline_only = True
        # init_ivars_from_settings will set the ivar.
    p, pos, newpos = x.do_find_next(settings)
    assert p and p.h == 'Root', repr(p)  # Test2
    s = p.b[pos:newpos]
    assert s == settings.find_text, repr(s)  # Test 2.
</t>
<t tx="ekr.20210220091434.1">def test_change_all_with_at_file_node(self):
    c, settings, x = self.c, self.settings, self.x
    root = c.rootPosition().next()  # Must have children.
    settings.find_text = 'def'
    settings.change_text = '_DEF_'
    settings.ignore_case = False
    settings.match_word = True
    settings.pattern_match = False
    settings.suboutline_only = False
    # Ensure that the @file node is marked dirty.
    root.h = '@file xyzzy.py'
    root.b = ''
    root.v.clearDirty()
    assert root.anyAtFileNodeName()
    x.do_change_all(settings)
    assert root.v.isDirty(), root.h

</t>
<t tx="ekr.20210220091434.2">def test_change_all_headline(self):
    settings, x = self.settings, self.x
    settings.find_text = 'child'
    settings.change_text = '_CHILD_'
    settings.ignore_case = False
    settings.in_headline = True
    settings.match_word = True
    settings.pattern_match = False
    settings.suboutline_only = False
    x.do_change_all(settings)
</t>
<t tx="ekr.20210220145825.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1824

@language python
@nosearch
</t>
<t tx="ekr.20210220145920.1">@language rest
@wrap

pr: File "N:\git\leo-editor\leo\core\leoCommands.py", line 411, in finishCreate
pr: c.frame.finishCreate()
pr: File "N:\git\leo-editor\leo\plugins\cursesGui2.py", line 2166, in finishCreate
pr: self.createFindTab()
pr: File "N:\git\leo-editor\leo\plugins\cursesGui2.py", line 2177, in createFindTab
pr: self.create_find_checkboxes()
pr: File "N:\git\leo-editor\leo\plugins\cursesGui2.py", line 2240, in create_find_checkboxes
pr: assert getattr(ftm, name) is None
pr: AttributeError: 'StringFindTabManager' object has no attribute 'check_box_wrap_around'</t>
<t tx="ekr.20210221042145.1">def change_all(self, package):
    """Run Leo's change-all command and return results."""
    tag = 'change_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    change_text = package.get("change_text")
    if change_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no change text")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    settings.change_text = change_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042406.1">def change_then_find(self, package):
    """Run Leo's change-then-find command and return results."""
    tag = 'change_then_find'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_then_find(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042541.1">def clone_find_all(self, package):
    """Run Leo's clone-find-all command and return results."""
    tag = 'clone_find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042633.1">def clone_find_all_flattened(self, package):
    """Run Leo's clone-find-all-flattened command and return results."""
    tag = 'clone_find_all_flattened'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all_flattened(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="ekr.20210221042719.1">def clone_find_tag(self, package):
    """Run Leo's clone-find-tag command and return results."""
    tag = 'clone_find_tag'
    c = self._check_c()
    fc = c.findCommands
    the_tag = package.get("tag")
    if not the_tag:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    settings = self._get_find_settings(c)
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    n, p = fc.do_clone_find_tag(settings)
    if self.log_flag:  # pragma: no cover
        g.trace("tag: {the_tag} n: {n} p: {p and p.h!r}")
    return self._make_response({"n": n, "p": p})
</t>
<t tx="ekr.20210221042808.1">def find_next(self, package):
    """Run Leo's find-next command and return results."""
    tag = 'find_next'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_next(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos} newpos {newpos}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221042851.1">def find_previous(self, package):
    """Run Leo's find-previous command and return results."""
    tag = 'find_previous'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_prev(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos} newpos {newpos}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043043.1">def find_def(self, package):
    """Run Leo's find-def command and return results."""
    tag = 'find_def'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_def(settings, word=find_text, strict=False)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos} newpos {newpos}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043134.1">def find_var(self, package):
    """Run Leo's find-var command and return results."""
    tag = 'find_var'
    c = self._check_c()
    fc = c.findCommands
    find_text = package.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_var(settings, word=find_text)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos} newpos {newpos}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="ekr.20210221043224.1">def tag_children(self, package):
    """Run Leo's tag-children command and return results."""
    # This is not a find command!
    tag = 'tag_children'
    c = self._check_c()
    fc = c.findCommands
    the_tag = package.get("tag")
    if the_tag is None:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    # Unlike find commands, do_tag_children does not use a settings dict.
    fc.do_tag_children(c.p, the_tag)
    return self._make_response({})
</t>
<t tx="ekr.20210221084048.1">def make_find_tab_manager(self, c):
    """
    Create a proxy FindTabManager sufficient to run unit tests.
    In the Qt gui, the DynamicWindow class creates the FindTabManager.
    """
    from leo.core.leoGui import StringFindTabManager
    self.ftm = ftm = StringFindTabManager(c)


    #
    # Create a find_findbox for find.set_find_text.
    ftm.find_findbox = StringLineEdit(name='findbox', disabled=False)
    #
    # Create widgets for set_find_scope.
    class StringWidget:
        """A widget simulating both a Qt checkbox and a Qt radio button."""

        value = False
        
        def toggle(self):  # For radio buttons.
            self.value = not self.value
            
        def isChecked(self):  # For checkboxes.
            return self.value
            
        checkState = isChecked
        
    ftm.radio_button_suboutline_only = StringWidget()
    # Similar to the table in find.compute_find_options_in_status_area:
    table = (
        'check_box_whole_word',
        'check_box_ignore_case',
        'check_box_regexp',
        'check_box_search_body',
        'check_box_search_headline',
        'check_box_mark_changes',
        'check_box_mark_finds',
    )
    for ivar in table:
        setattr(ftm, ivar, StringWidget())
</t>
<t tx="ekr.20210221130549.1">class StringFindTabManager:
    """A string-based FindTabManager class for unit tests."""
    @others
</t>
<t tx="ekr.20210221130549.2">@nobeautify

def __init__(self, c):
    """Ctor for the FindTabManager class."""
    self.c = c
    self.entry_focus = None  # Accessed directly from code(!)
    # Find/change text boxes...
    self.find_findbox = StringLineEdit('find_text')
    self.find_replacebox = StringLineEdit('change_text')
    # Check boxes...
    self.check_box_ignore_case      = StringCheckBox('ignore_case')
    self.check_box_mark_changes     = StringCheckBox('mark_changes')
    self.check_box_mark_finds       = StringCheckBox('mark_finds')
    self.check_box_regexp           = StringCheckBox('pattern_match')
    self.check_box_search_body      = StringCheckBox('search_body')
    self.check_box_search_headline  = StringCheckBox('search_headline')
    self.check_box_whole_word       = StringCheckBox('whole_word')
    # Radio buttons...
    self.radio_button_entire_outline  = StringRadioButton('entire_outline')
    self.radio_button_node_only       = StringRadioButton('node_only')
    self.radio_button_suboutline_only = StringRadioButton('suboutline_only')
    # Init the default values.
    self.init_widgets()
</t>
<t tx="ekr.20210221130549.3">def get_find_text(self):
    s = self.find_findbox.text()
    if s and s[-1] in ('\r', '\n'):
        s = s[:-1]
    return s

def get_change_text(self):
    s = self.find_replacebox.text()
    if s and s[-1] in ('\r', '\n'):
        s = s[:-1]
    return s

def set_find_text(self, s):
    w = self.find_findbox
    w.clear()
    w.insert(s)

def set_change_text(self, s):
    w = self.find_replacebox
    w.clear()
    w.insert(s)
</t>
<t tx="ekr.20210221130549.4">@nobeautify

def get_settings(self):
    """
    Return a g.bunch representing all widget values.
    
    Similar to LeoFind.default_settings, but only for find-tab values.
    """
    return g.Bunch(
        # Find/change strings...
        find_text   = self.find_findbox.text(),
        change_text = self.find_replacebox.text(),
        # Find options...
        ignore_case     = self.check_box_ignore_case.isChecked(),
        mark_changes    = self.check_box_mark_changes.isChecked(),
        mark_finds      = self.check_box_mark_finds.isChecked(),
        node_only       = self.radio_button_node_only.isChecked(),
        pattern_match   = self.check_box_regexp.isChecked(),
        search_body     = self.check_box_search_body.isChecked(),
        search_headline = self.check_box_search_headline.isChecked(),
        suboutline_only = self.radio_button_suboutline_only.isChecked(),
        whole_word      = self.check_box_whole_word.isChecked(),
    )
</t>
<t tx="ekr.20210221130549.5">def clear_focus(self):
    pass

def init_focus(self):
    pass

def set_entry_focus(self):
    pass
</t>
<t tx="ekr.20210221130549.7">def init_widgets(self):
    """
    Init widgets and ivars from c.config settings.
    Create callbacks that always keep the LeoFind ivars up to date.
    """
    c, find = self.c, self.c.findCommands
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', '&lt;find pattern here&gt;'),
        ('find_replacebox', 'change_text', ''),
    )
    for widget_ivar, setting_name, default in table:
        w = getattr(self, widget_ivar)
        s = c.config.getString(setting_name) or default
        w.insert(s)
    # Check boxes.
    table = (
        ('ignore_case', 'check_box_ignore_case'),
        ('mark_changes', 'check_box_mark_changes'),
        ('mark_finds', 'check_box_mark_finds'),
        ('pattern_match', 'check_box_regexp'),
        ('search_body', 'check_box_search_body'),
        ('search_headline', 'check_box_search_headline'),
        ('whole_word', 'check_box_whole_word'),
    )
    for setting_name, widget_ivar in table:
        w = getattr(self, widget_ivar)
        val = c.config.getBool(setting_name, default=False)
        setattr(find, setting_name, val)
        if val:
            w.toggle()
    # Radio buttons
    table = (
        ('node_only', 'node_only', 'radio_button_node_only'),
        ('entire_outline', None, 'radio_button_entire_outline'),
        ('suboutline_only', 'suboutline_only', 'radio_button_suboutline_only'),
    )
    for setting_name, ivar, widget_ivar in table:
        w = getattr(self, widget_ivar)
        val = c.config.getBool(setting_name, default=False)
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            w.toggle()
    # Ensure one radio button is set.
    if not find.node_only and not find.suboutline_only:
        w = self.radio_button_entire_outline
        w.toggle()
</t>
<t tx="ekr.20210221130549.8">@nobeautify

def set_radio_button(self, name):
    """Set the value of the radio buttons"""
    d = {
        'node-only':       self.radio_button_node_only,
        'entire-outline':  self.radio_button_entire_outline,
        'suboutline-only': self.radio_button_suboutline_only,
    }
    w = d.get(name)
    if not w.isChecked():
        w.toggle()
</t>
<t tx="ekr.20210221130549.9">@nobeautify

def toggle_checkbox(self, checkbox_name):
    """Toggle the value of the checkbox whose name is given."""
    d = {
        'ignore_case':     self.check_box_ignore_case,
        'mark_changes':    self.check_box_mark_changes,
        'mark_finds':      self.check_box_mark_finds,
        'pattern_match':   self.check_box_regexp,
        'search_body':     self.check_box_search_body,
        'search_headline': self.check_box_search_headline,
        'whole_word':      self.check_box_whole_word,
    }
    w = d.get(checkbox_name)
    w.toggle()
</t>
<t tx="ekr.20210221134134.1"></t>
<t tx="ekr.20210221134759.1"></t>
<t tx="ekr.20210222033958.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1810

- YouTube vids: https://stackoverflow.com/questions/48103685/youtube-video-embedding-pyqt
- Math: https://stackoverflow.com/questions/56760843/how-to-display-mathematical-typesetting-mathjax-latex-etc-in-qt-using-pyqt5
- Matplotlib plots: https://www.learnpyqt.com/tutorials/plotting-matplotlib/
- leaflet maps: https://github.com/skylarkdrones/pyqtlet
- Quizlet flash cards: https://quizlet.com/cn/213650959/pyqt-flash-cards/
- Screen shots: 3Blue1Brown: https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw

@language python
@nosearch
</t>
<t tx="ekr.20210223083935.1"></t>
<t tx="ekr.20210223083944.1">ID,Type,SKU,Name,Short description,Description,Date sale price starts,Date sale price ends,Tax status,Tax class,In stock?,Stock,Backorders allowed?,Sold individually?,Weight (lbs),Length (in),Width (in),Height (in),Allow customer reviews?,Purchase note,Sale price,Regular price,Categories,Tags,Shipping class,Images,Download limit,Download expiry days,Parent,Grouped products,Upsells,Cross-sells,External URL,Button text,Position,Attribute 1 name,Attribute 1 value(s),Attribute 1 visible,Attribute 1 global,Attribute 2 name,Attribute 2 value(s),Attribute 2 visible,Attribute 2 global,Meta: _wpcom_is_markdown,Download 1 name,Download 1 URL,Download 2 name,Download 2 URL


,,5100.1,Chenille Scarf Red x Black,Chenille Scarf,,,,,,1,1,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5102.4,Silk Scarf Azalea x Fine,Silk Scarf,,,,,,1,1,,,,,,,,,,99,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,6533,Mohair Hat,"Mohair Hat, Mitten &amp; Scarf",,,,,,1,1,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,2148,Mohair Mitten,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5104,Mohair Scarf,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,59,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7108,Silk Cowl Canyons x Pacific,Silk Cowl,,,,,,,,,,,,,,,,,??,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7144, Long Cowl Canyons Chenile  x Peacock Silk,Chenille &amp; Silk Cowl,,,,,,,,,,,,,,,,,89,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,Deflected Doubleweave Scarf,,,,,,,,,,,,,,,,,139,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,Rayon &amp; Chenille Scarf,,,,,,,,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
</t>
<t tx="ekr.20210223084024.1">,,5100.1,Chenille Scarf Red x Black,Chenille Scarf,,,,,,1,1,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5102.4,Silk Scarf Azalea x Fine,Silk Scarf,,,,,,1,1,,,,,,,,,,99,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,6533,Mohair Hat,"Mohair Hat, Mitten &amp; Scarf",,,,,,1,1,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,2148,Mohair Mitten,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,39,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5104,Mohair Scarf,"Mohair Hat, Mitten &amp; Scarf",,,,,,,,,,,,,,,,,59,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7108,Silk Cowl Canyons x Pacific,Silk Cowl,,,,,,,,,,,,,,,,,??,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,7144, Long Cowl Canyons Chenile  x Peacock Silk,Chenille &amp; Silk Cowl,,,,,,,,,,,,,,,,,89,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,Deflected Doubleweave Scarf,,,,,,,,,,,,,,,,,139,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
,,5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,Rayon &amp; Chenille Scarf,,,,,,,,,,,,,,,,,79,Clothing,,,,,,,,,,,,,,,,,,,,,,,,,
</t>
<t tx="ekr.20210223084115.1">root = g.findTopLevelNode(c, '@csv')
assert root
for s in g.splitlines(p.b):
    fields = ???
    child = root.insertAsLastChild()
    child.h = </t>
<t tx="ekr.20210224081636.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1815

when c.config.create_nonexistent_directories is false, the OK value is not defined.

@language python
@nosearch
</t>
<t tx="ekr.20210226104255.1">g.cls()
p = c.lastTopLevel()
lines = g.splitLines(p.b)
n = lines[0].count(',')
# print(n)
for i, s in enumerate(lines):
    if s.strip():
        n2 = s.count(',')
        if n != n2:
            print(i, n2)
print('done')
</t>
<t tx="ekr.20210226104315.1">SKU,Description,In stock?,Stock,Regular price,Categories,Images
5100.1,Chenille Scarf Red x Black,1,1,79.00,Clothing,https://rrhandwovens.com/5100-1-scarf-red-x-black-chenille/
5102.4,Silk Scarf Azalea x Fine,1,1,99.00,Clothing,https://rrhandwovens.com/5102-4-scarf-azalea-x-fine-med-navy-silk/
6533,Mohair Hat,1,1,39.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
2148,Mohair Mitten,1,1,39.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
5104,Mohair Scarf,1,1,59.00,Clothing,https://rrhandwovens.com/5104-3-mohair-scarf6535-hat-2148-millten-cirque-x-lipstickjpeg/
7108,Silk Cowl Canyons x Pacific,1,1,98.00,Clothing,https://rrhandwovens.com/7108-silk-cowl-canyons-x-pacific/
7144, Long Cowl Canyons Chenile  x Peacock Silk,1,1,89.00,Clothing,https://rrhandwovens.com/7144-long-cowl-canyons-chenill-x-peacock-silk/
5112.1,Alpaca Tencel Silk Scarf Deflected Doubleweave,1,1,139.00,Clothing,https://rrhandwovens.com/5112-1-deflected-double-weave-2-tencel-alpaca-silk-scarf/
5112.6,Rayon Chenille Scarf Forest Floor x Gray/Green,1,1,79.00,Clothing,https://rrhandwovens.com/5112-6-forest-floor-x-grey-green-chenille/
</t>
<t tx="ekr.20210228045040.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1557

PR: https://github.com/leo-editor/leo-editor/pull/1830

Config file: http://mypy.readthedocs.io/en/latest/config_file.html

@language python
@nosearch
</t>
<t tx="ekr.20210228045338.1">- Make Rebecca an admin.

- Sign in to stripe.
- Add contact page.
- Customize my-account page.
- Set tax and payment methods.
</t>
<t tx="ekr.20210228133838.1"></t>
<t tx="ekr.20210301131322.1">@nosearch

# Word, Ignore Case, Regex, Head, Body

# found 5 nodes</t>
<t tx="ekr.20210302111645.1">@language rest
@wrap

In ekr-mypy branch.
https://github.com/leo-editor/leo-editor/issues/1831

@language python
@nosearch
</t>
<t tx="ekr.20210302111730.1">@g.command('mypy')
def mypy_command(event):
    """
    Run mypy on all @&lt;file&gt; nodes of the selected tree, or the first
    @&lt;file&gt; node in an ancestor. Running mypy on a single file usually
    suffices.
    
    For example, you can run mypy on most of Leo's files by selecting
    
      `@edit ../../launchLeo.py`
      
    in leoPy.leo, then running Leo's mypy command.
    
    Unlike running mypy outside of Leo, Leo's mypy command creates
    clickable links in Leo's log pane for each error.
    """
    c = event.get('c')
    if not c:
        return
    if c.isChanged():
        c.save()
    if mypy:
        MypyCommand(c).run(c.p)
    else:
        g.es_print('can not import mypy')
</t>
<t tx="ekr.20210303123525.1">def findNodeByPath(c, path):
    """Return the first @&lt;file&gt; node in Cmdr c whose path is given."""
    for p in c.all_positions():
        if p.isAnyAtFileNode() and path == g.fullPath(c, p):
            return p
    return False
</t>
<t tx="ekr.20210305085324.1">@language rest
@wrap

ekr-scripting branch

https://github.com/leo-editor/leo-editor/issues/1715

Test on Rust

@language python
@nosearch
</t>
<t tx="ekr.20210305133229.1">def execute_external_language_script(self,
    error_regex = None,
    language_command = None,
    script_language = None,
):
    """
    A general-purpose helper that composes and runs a Leonine script for
    languages other than python.
    
    command:         The external command that runs the language processor.
    error_regex:     Optional regular expression matching error messages.
    regex_flags:     Optional flags for the regular expression.
    script_language: The name of the language.
    """
    ### How to specify file name?
    c = self
</t>
<t tx="ekr.20210306054001.1">Weight:
- Lost 20 lbs.
- Went off diuretic pill.
- Been on plateau ever since, without panic.
- Logged all meals.
- Played with eating mindfully &amp; intuitively.

Movement:
- Sitting is the new smoking.
- Took regular breaks.
- Focus on moving more.
- Added new excercises.

Mindfulness &amp; Emotions
- Aha: can have multiple emotions simultaneously.

Goals &amp; Sabbatical
- Leo Sabbatical very successful.
- Sabbatical from music.</t>
<t tx="ekr.20210306153732.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1832

@language python
@nosearch
</t>
<t tx="ekr.20210307051727.1">g.cls()
import importlib
import leo.commands.editFileCommands as editFileCommands

if c.isChanged():
    c.save()

importlib.reload(editFileCommands)

path = r'c:\test\atRoot.leo'
hidden_c = g.createHiddenCommander(path)
editFileCommands.ConvertAtRoot().convert_file(hidden_c)
print('done')</t>
<t tx="ekr.20210307060752.1">class ConvertAtRoot:
    """
    A class to convert @root directives to @clean nodes:
    
    - Change @root directive in body to @clean in the headline.
    - Make clones of section references defined outside of @clean nodes,
      moving them so they are children of the nodes that reference them.
    """
    
    errors = 0
    root = None  # Root of @root tree.
    root_pat = re.compile(r'^@root\s+(.+)$', re.MULTILINE)
    section_pat = re.compile(r'\s*&lt;\&lt;.+&gt;\&gt;')
    units = []  # List of positions containing @unit.

    @others
</t>
<t tx="ekr.20210307060752.2">@cmd('convert-at-root')
def convert_file(self, c):
    """Convert @root to @clean in the the .leo file at the given path."""
    self.find_all_units(c)
    for p in c.all_positions():
        m = self.root_pat.search(p.b)
        path = m and m.group(1)
        if path:
            # Weird special case. Don't change section definition!
            if self.section_pat.match(p.h):
                print(f"\nCan not create @clean node: {p.h}\n")
                self.errors += 1
            else:
                self.root = p.copy()
                p.h = f"@clean {path}"
            self.do_root(p)
            self.root = None
    #
    # Check the results.
    link_errors = c.checkOutline(check_links=True)
    self.errors += link_errors
    print(f"{self.errors} error{g.plural(self.errors)} in {c.shortFileName()}")
    c.redraw()
    # if not self.errors: self.dump(c)
</t>
<t tx="ekr.20210307075117.1">def do_root(self, p):
    """
    Make all necessary clones for section defintions.
    """
    for p in p.self_and_subtree():
        self.make_clones(p)
</t>
<t tx="ekr.20210307075325.1">section_pat = re.compile(r'\s*&lt;\&lt;(.*)&gt;\&gt;')

def make_clones(self, p):
    """Make clones for all undefined sections in p.b."""
    header = False
    for s in g.splitLines(p.b):
        m = self.section_pat.match(s)
        if m:
            # if not header:
                # header = True
                # print('')
                # print(p.h)
            section_name = g.angleBrackets(m.group(1).strip())
            section_p = self.make_clone(p, section_name)
            if not section_p:
                print(f"MISSING: {section_name:30} {p.h}")
                self.errors += 1
</t>
<t tx="ekr.20210307080500.1">def make_clone(self, p, section_name):
    """Make c clone for section, if necessary."""
    
    def clone_and_move(parent, section_p):
        clone = section_p.clone()
        if self.check_clone_move(clone, parent):
            print(f"  CLONE: {section_p.h:30} parent: {parent.h}")
            clone.moveToLastChildOf(parent)
        else:
            print(f"Can not clone: {section_p.h:30} parent: {parent.h}")
            clone.doDelete()
            self.errors += 1
    #
    # First, look in p's subtree.
    section_p = self.find_section(p, section_name)
    if section_p:
        # g.trace('FOUND', section_name)
        # Already defined in a good place.
        return section_p
    #
    # Finally, look in the @unit tree.
    for unit_p in self.units:
        section_p = self.find_section(unit_p, section_name)
        if section_p:
            clone_and_move(p, section_p)
            return section_p
    return None
</t>
<t tx="ekr.20210307082125.1">def find_section(self, root, section_name):
    """Find the section definition node in root's subtree for the given section."""
    
    def munge(s):
        return s.strip().replace(' ','').lower()
        
    for p in root.subtree():
        if munge(p.h).startswith(munge(section_name)):
            # print(f"      Found {section_name:30} in {root.h}::{root.gnx}")
            return p
        
    # print(f"  Not found {section_name:30} in {root.h}::{root.gnx}")
    return None
</t>
<t tx="ekr.20210307085034.1">def find_all_units(self, c):
    """Scan for all @unit nodes."""
    for p in c.all_positions():
        if '@unit' in p.b:
            self.units.append(p.copy())
</t>
<t tx="ekr.20210308035356.1">- Explore screencast tools, demo.py &amp; Joe Orr's tools.
- Remove multiple @cmd decorators.</t>
<t tx="ekr.20210308035425.1">Goal: Play in rhythm with right notes.

Resume lessons after my second shot.
</t>
<t tx="ekr.20210308044128.1">def check_clone_move(self, p, parent):
    """
    Return False if p or any of p's descendents is a clone of parent
    or any of parents ancestors.
    """
    # Like as checkMoveWithParentWithWarning without warning.
    clonedVnodes = {}
    for ancestor in parent.self_and_parents(copy=False):
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v
    if not clonedVnodes:
        return True
    for p in p.self_and_subtree(copy=False):
        if p.isCloned() and clonedVnodes.get(p.v):
            return False
    return True
</t>
<t tx="ekr.20210308045306.1">def dump(self, c):
    print(f"Dump of {c.shortFileName()}...")
    for p in c.all_positions():
        print(' '*2*p.level(), p.h)
</t>
<t tx="ekr.20210308051724.1">@cmd('convert-at-root')
def convert_at_root(self, event=None):
    &lt;&lt; convert-at-root docstring &gt;&gt;
    c = event.get('c')
    if not c:
        return
    ConvertAtRoot().convert_file(c)
</t>
<t tx="ekr.20210309035627.1">@wrap
"""
The convert-at-root command converts @root to @clean throughout the
outline.

This command is not perfect. You will need to adjust the outline by hand if
the command reports errors. I recommend using git diff to ensure that the
resulting external files are roughly equivalent after running this command.

This command attempts to do the following:

- For each node with an @root &lt;path&gt; directive in the body, change the head to
  @clean &lt;path&gt;. The command does *not* change the headline if the node is
  a section definition node. In that case, the command reports an error.

- Clones and moves nodes as needed so that section definition nodes appear
  as descendants of nodes containing section references. To find section
  definition nodes, the command looks in all @unit trees. After finding the
  required definition node, the command makes a clone of the node and moves
  the clone so it is the last child of the node containing the section
  references. This move may fail. If so, the command reports an error.
"""
</t>
<t tx="ekr.20210309081334.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1789

See `script: check-files`.

@language python
@nosearch
</t>
<t tx="ekr.20210309083845.1">"""
Issue https://github.com/leo-editor/leo-editor/issues/1789
"""
g.cls()
import glob

def munge(s):
    return s.replace('\\','/').lower()
    
ignore = [
    # Core...
    'format-code.py',       # Script.
    'leoTangle.py',         # To be deleted.
    # External...
    'leoftsindex.py',       # User contributed.
    'sax2db.py',            # User contributed.
    'stringlist.py',        # User contributed.
    # Plugins...
    'baseNativeTree.py',    # No longer used. To be deleted?
    'leofts.py',            # User contributed.
    'qt_main.py',           # Created by Qt designer. Not used.
    'rst3.py',              # To be deleted?
]
ignore = [munge(z) for z in ignore]
# Find all paths for @&lt;file&gt; nodes.
seen = {}
for p in c.all_positions():
    if p.isAnyAtFileNode():
        path = munge(g.fullPath(c, p))
        seen [path] = path
# Check all .py files.  
for module in ('core', 'external', 'plugins'):
    print(f"checking {module}...")
    pat = g.os_path_finalize_join(g.app.loadDir, '..', module, '*.py')
    paths = glob.glob(pat)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    paths = [munge(z) for z in paths]
    # g.printObj(paths, tag=f"\n{len(paths)} files in {module}")
    for path in paths:
        if path not in seen and g.shortFileName(path) not in ignore:
            print(f"Missing: {path}")
    print('')
</t>
<t tx="ekr.20210309113434.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1817

fc.gnxDict may contain gnx for non-existent newHeadline node

@language python
@nosearch
</t>
<t tx="ekr.20210309113519.1">g.cls()
fc = c.fileCommands
d = fc.gnxDict
for key in sorted(d.keys()):
    v = d.get(key)
    if v.h.lower() == 'newheadline':
        print('in dict', key, v)
        for p in c.all_positions():
            if p.v == v:
                print(p)
        else:
            print('no position for', v)</t>
<t tx="ekr.20210309114903.1">@g.command('dump-gnx-dict')
def dump_clone_parents(event):
    c = event.get('c')
    if not c:
        return
    d = c.fileCommands.gnxDict
    g.printObj(d, tag='gnxDict')
</t>
<t tx="ekr.20210309125005.1"></t>
<t tx="ekr.20210311044628.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1839

&lt;Alt-x&gt;cff&lt;Return&gt; crashes:

check_event not leo event: g.Bunch()
    c: Commander 1447943460744: 'c:/leo.repo/leo-editor/leo/test/unitTest.leo'
    char: Enter
    stroke: Enter
    widget: &lt;StringTextWrapper: 1447949701576 body&gt;
, callers: interactive_cff,start_state_machine,get1Arg,get_arg

@language python
@nosearch
</t>
<t tx="ekr.20210311080304.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1840

@language python
@nosearch
</t>
<t tx="ekr.20210311154845.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1841

@language python
@nosearch
</t>
<t tx="ekr.20210311154956.1">@cmd('copy-gnx')
def copyGnx(self, event):
    """Copy c.p.gnx to the clipboard and display it in the status area."""
    c = self.c
    if not c:
        return
    gnx = c.p and c.p.gnx
    if not gnx:
        return
    g.app.gui.replaceClipboardWith(gnx)
    status_line = getattr(c.frame, "statusLine", None)
    if status_line:
        status_line.put(f"gnx: {gnx}")
</t>
<t tx="ekr.20210312120503.1">def set_body_and_headline_checkbox(self):
    """Return the search-body and search-headline checkboxes to their defaults."""
    # #1840: headline-only one-shot
    c = self.c
    find = c.findCommands
    if not find:
        return
    table = (
        ('search_body', self.check_box_search_body),
        ('search_headline', self.check_box_search_headline),
    )
    for setting_name, w in table:
        val = c.config.getBool(setting_name, default=False)
        if val != w.isChecked():
            w.toggle()
    if find.minibuffer_mode:
        find.show_find_options_in_status_area()
</t>
<t tx="ekr.20210312122351.1">def set_body_and_headline_checkbox(self):
    """Return the search-body and search-headline checkboxes to their defaults."""
    # #1840: headline-only one-shot
    c = self.c
    find = c.findCommands
    if not find:
        return
    table = (
        ('search_body', self.check_box_search_body),
        ('search_headline', self.check_box_search_headline),
    )
    for setting_name, w in table:
        val = c.config.getBool(setting_name, default=False)
        if val != w.isChecked():
            w.toggle()
</t>
<t tx="ekr.20210312123435.1"></t>
<t tx="ktenney.20041211072654.14">def processDirectory(self, path, node):

    """
    create child nodes for each member of the directory

    @path is a path object for a directory
    @node is the node to work with
    """
    # delete all nodes before creating, to avoid duplicates
    while node.firstChild():
        node.firstChild().doDelete(node)

    for file in path.files():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name

    for file in path.dirs():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name
</t>
<t tx="sps.20100618004337.20951"># This method handles all the body text.

def skip_body(self, p, delims):
    &lt;&lt; skip_body docstring &gt;&gt;
    # c = self.c
    s = p.b
    code = doc = None; i = 0
    anyChanged = False
    if self.start_mode == "code":
        j = g.skip_blank_lines(s, i)
        i, code, new_delims, reflist = self.skip_code(s, j, delims)
        if code:
            &lt;&lt; Define a section for a leading code part &gt;&gt;
        delims = new_delims
    if not code:
        i, doc, delims = self.skip_doc(s, i, delims) # Start in doc section by default.
        if i &gt;= len(s) and doc:
            &lt;&lt; Define a section containing only an @doc part &gt;&gt;
    while i &lt; len(s):
        progress = i # progress indicator
        kind, end = self.token_type(s, i, report_errors=True)
        # if g.is_nl(s,i): i = g.skip_nl(s,i)
        i = g.skip_ws(s, i)
        if kind == section_def:
            &lt;&lt; Scan and define a section definition &gt;&gt;
        elif kind == at_code:
            i = g.skip_line(s, i)
            &lt;&lt; Scan and define an @code defininition &gt;&gt;
        elif kind == at_root:
            i = g.skip_line(s, i)
            &lt;&lt; Scan and define a root section &gt;&gt;
        elif kind in (at_doc, at_chapter, at_section):
            i = g.skip_line(s, i)
            i, more_doc, delims = self.skip_doc(s, i, delims)
            doc = doc + more_doc
        else:
            i = g.skip_line(s, i)
        assert(progress &lt; i) # we must make progress!
    # Only call trimTrailingLines if we have changed its body.
    if anyChanged:
        self.trimTrailingLines(p)
    return delims
</t>
<t tx="sps.20100618004337.20952">if self.header_name:
    # Tangle code.
    part = self.st_enter_section_name(
        self.header_name, code, doc, delims, new_delims)
    if not self.tangling:
        # Untangle code.
        if self.untangle_stage1:
            section = self.st_lookup(self.header_name)
            section.parts[part - 1].reflist(refs=reflist)
        else:
            head = s[: j]; tail = s[i:]
            s, i, changed = self.update_def(self.header, part, head, code, tail)
            if changed: anyChanged = True
    code = doc = None
# leading code without a header name gets silently dropped
</t>
<t tx="sps.20100618004337.20953">@
It's valid for an @doc directive to appear under a headline that does
not contain a section name. In that case, no section is defined.
@c
if self.header_name:
    # Tangle code.
    part = self.st_enter_section_name(self.header_name, code, doc, delims, delims)
    # Untangle code.
    if not self.tangling:
        # Untangle no longer updates doc parts.
        # 12/03/02: Mark the part as having been updated to suppress warning.
        junk, junk = self.ust_lookup(self.header_name, part, update_flag=True)
doc = None
</t>
<t tx="sps.20100618004337.20954"># We enter the code part and any preceding doc part into the symbol table.
# Skip the section definition line.
k = i; i, kind, junk = self.skip_section_name(s, i)
section_name = s[k: i]
assert(kind == section_def)
i = g.skip_to_end_of_line(s, i)
# Tangle code: enter the section name even if the code part is empty.
&lt;&lt;process normal section&gt;&gt;
code = None
doc = ''
</t>
<t tx="sps.20100618004337.20955"># All @c or @code directives denote &lt; &lt; headline_name &gt; &gt; =
if self.header_name:
    section_name = self.header_name
    &lt;&lt;process normal section&gt;&gt;
else:
    self.error("@c expects the headline: " + self.header + " to contain a section name")
code = None
doc = ''
</t>
<t tx="sps.20100618004337.20956"># We save the file name in case another @root ends the code section.
old_root_name = self.root_name
#
# Tangle code.
j = g.skip_blank_lines(s, i)
k, code, new_delims, reflist = self.skip_code(s, j, delims)
self.st_enter_root_name(old_root_name, code, doc, delims, new_delims)
delims = new_delims
if not self.tangling:
    # Untangle code.
    if self.untangle_stage1:
        root_section = self.st_lookup(old_root_name)
        assert(root_section)
        root_first_part = root_section.parts[0]
        assert(root_first_part)
        root_first_part.reflist(refs=reflist)
    else:
        part = 1 # Use 1 for root part.
        head = s[: j]; tail = s[k:]
        s, i, changed = self.update_def(old_root_name, part, head, code, tail, is_root_flag=True)
        if changed: anyChanged = True
code = None
doc = ''
</t>
<t tx="sps.20100618004337.20957">'''
The following subsections contain the interface between the Tangle and
Untangle commands. This interface is an important hack, and allows
Untangle to avoid duplicating the logic in skip_tree and its allies.

The aha is this: just at the time the Tangle command enters a
definition into the symbol table, all the information is present that
Untangle needs to update that definition.

To get whitespace exactly right we retain the outline's leading
whitespace and remove leading whitespace from the updated definition.
'''
</t>
<t tx="sps.20100716120121.12132"># Tangle code.
j = g.skip_blank_lines(s, i)
i, code, new_delims, reflist = self.skip_code(s, j, delims)
part = self.st_enter_section_name(section_name, code, doc, delims, new_delims)
delims = new_delims
# Untangle code
if not self.tangling:
    # part may be zero if there was an empty code section (doc part only)
    # In untangle stage1 such code produces no reference list,
    #    thus nothing to do.
    # In untangle stage2, such code cannot be updated because it
    # was either not emitted to the external file or emitted as a doc part only
    #     in either case, there is no code section to update, and we don't
    #     update doc parts.
    if part &gt; 0:
        if self.untangle_stage1:
            section = self.st_lookup(section_name)
            section.parts[part - 1].reflist(refs=reflist)
        else:
            head = s[: j]; tail = s[i:]
            s, i, changed = self.update_def(section_name, part, head, code, tail)
            if changed: anyChanged = True
</t>
<t tx="tbrown.20080613095157.10">def openDir(c,parent,d):
    """
    Expand / refresh an existing folder

    Note: With the addition of per folder inclusion/exclusion a check is done
    against both the current list of nodes and against the files/folders as
    they exist on the system. This check must be done in both places to keep
    the node list in sync with the file system while respecting the inc/exc
    lists - John Lunzer
    """

    # compare folder content to children
    try:
        path, dirs, files = next(os.walk(d))
    except StopIteration:
        # directory deleted?
        c.setHeadString(parent,'*'+parent.h.strip('*')+'*')
        return

    # parent.expand()  # why?

    oldlist = set()
    toRemove = set()
    newlist = []

    bodySplit = parent.b.splitlines()

    excdirs = False
    excfiles = False
    regEx = False
    if re.search('^excdirs', parent.b, flags=re.MULTILINE):
        excdirs = True
    if re.search('^excfiles', parent.b, flags=re.MULTILINE):
        excfiles = True
    if re.search('^re', parent.b, flags=re.MULTILINE):
        regEx = True

    inc = [line.replace('inc=','') for line in bodySplit if line.startswith('inc=')]
    exc = [line.replace('exc=','') for line in bodySplit if line.startswith('exc=')]

    #flatten lists if using comma separations
    inc = [item for line in inc for item in line.strip(' ').split(',')]
    exc = [item for line in exc for item in line.strip(' ').split(',')]

    # get children info
    for p in flattenOrganizers(parent):
        entry = p.h.strip('/*')
        if entry.startswith('@'):  # remove only the @part
            directive = entry.split(None,1)
            if len(directive) &gt; 1:
                entry = entry[len(directive[0]):].strip()
        #find existing inc/exc nodes to remove
        #using p.h allows for example exc=/ to remove all directories
        if not checkIncExc(p.h,inc,exc, regEx) or \
               (excdirs and entry in dirs) or \
               (excfiles and entry in files):
            toRemove.add(p.h) #must not strip '/', so nodes can be removed
        else:
            oldlist.add(entry)

    # remove existing found inc/exc nodes
    for headline in toRemove:
        found = g.findNodeInChildren(c,parent,headline)
        if found:
            found.doDelete()

    # dirs trimmed by toRemove to remove redundant checks
    for d2 in set(dirs)-set([h.strip('/') for h in toRemove]):
        if d2 in oldlist:
            oldlist.discard(d2)
        else:
            if checkIncExc(d2,
                           [i.strip('/') for i in inc],
                           [e.strip('/') for e in exc],
                           regEx) and not excdirs:
                newlist.append('/'+d2+'/')

    # files trimmed by toRemove, retains original functionality of plugin
    for f in set(files)-toRemove:
        if f in oldlist:
            oldlist.discard(f)
        else:
            if checkIncExc(f, inc, exc, regEx) and not excfiles:
                newlist.append(f)

    # insert newlist
    newlist.sort()
    ignored = 0
    newlist.reverse()  # un-reversed by the following loop
    for name in newlist:
        if inReList(name, c.__active_path['ignore']):
            ignored += 1
            continue

        p = parent.insertAsNthChild(0)
        c.setChanged()
        p.h = name
        if name.startswith('/'):
            # sufficient test of dirness as we created newlist
            p.b = '@path '+name.strip('/')
        elif (c.__active_path['do_autoload'] and
              inReList(name, c.__active_path['autoload'])):
            openFile(c, p, os.path.join(d, p.h), autoload=True)
        elif (c.__active_path['do_autoload'] and
              c.__active_path['load_docstring'] and
              name.lower().endswith(".py")):
            # do_autoload suppresses doc string loading because turning
            # autoload off is supposed to address situations where autoloading
            # causes problems, so don't still do some form of autoloading
            p.b = c.__active_path['DS_SENTINEL']+"\n\n"+loadDocstring(os.path.join(d, p.h))
        p.setMarked()
        p.contract()

    if ignored:
        g.es('Ignored %d files in directory' % ignored)

    # warn / mark for orphan oldlist
    for p in flattenOrganizers(parent):
        h = p.h.strip('/*')  # strip / and *
        if (h not in oldlist or
            (p.hasChildren() and not isDirNode(p))
        ):  # clears bogus '*' marks
            nh = p.h.strip('*')  # strip only *
        else:
            nh = '*'+p.h.strip('*')+'*'
            if isDirNode(p):
                for orphan in p.subtree():
                    c.setHeadString(orphan, '*'+orphan.h.strip('*')+'*')
        if p.h != nh:  # don't dirty node unless we must
            p.h = nh

    c.selectPosition(parent)
</t>
<t tx="tbrown.20080613095157.8">def createFile(c,parent,d):
    """Ask if we should create a new file"""
    directory = os.path.dirname(d)
    if not os.path.isdir(directory):
        g.error('Create parent directories first')
        return False

    d = os.path.basename(d)
    atType = c.config.getString('active-path-attype') or 'auto'
    ok = g.app.gui.runAskYesNoDialog(c, 'Create / load file?',
        'Create file @'+atType+' '+d+'?')
    if ok == 'no':
        return False
    parent.h = '@'+atType+' '+d
    c.bodyWantsFocus()
    return True
</t>
<t tx="tbrown.20090119215428.11">def __init__ (self,c):
    '''ctor for todoController class.'''
    self.c = c
    c.cleo = self
    self.donePriority = 100
    self.menuicons = {}  # menu icon cache
    self.recentIcons = []
    #X self.smiley = None
    self.redrawLevels = 0
    self._widget_to_style = None  # see updateStyle()
    self.reloadSettings()
    self.handlers = [
       ("close-frame",self.close),
       ('select3', self.updateUI),
       ('save2', self.loadAllIcons),
       ('idle', self.updateStyle),
    ]
    # chdir so the Icons can be located, needed for uic resources
    owd = os.getcwd()
    os.chdir(g.os_path_join(g.app.loadDir, '..', 'plugins'))
    self.ui = todoQtUI(self)
    os.chdir(owd)
    for i in self.handlers:
        g.registerHandler(i[0], i[1])
    self.loadAllIcons()
    # correct spinTime suffix:
    self.ui.UI.spinTime.setSuffix(" " + self.time_name)
    # #1591: patch labels if necessary.
    self.patch_1591()
</t>
<t tx="tbrown.20090119215428.12">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.time_name = c.config.getString('todo-time-name') or 'days'
    self.icon_location = c.config.getString('todo-icon-location') or 'beforeHeadline'
    self.prog_location = c.config.getString('todo-prog-location') or 'beforeHeadline'
    self.icon_order = c.config.getString('todo-icon-order') or 'pri-first'
</t>
<t tx="tbrown.20090119215428.34">@redrawer
def show_times(self, p=None, show=False):

    def rnd(x):
        return re.sub('.0$', '', '%.1f' % x)

    if p is None:
        p = self.c.currentPosition()

    for nd in p.self_and_subtree():
        p.h = re.sub(' &lt;[^&gt;]*&gt;$', '', nd.headString())
        tr = self.getat(nd.v, 'time_req')
        pr = self.getat(nd.v, 'progress')
        try: pr = float(pr)
        except Exception: pr = ''
        if tr != '' or pr != '':
            ans = ' &lt;'
            if tr != '':
                if pr == '' or pr == 0 or pr == 100:
                    ans += rnd(tr) + ' ' + self.time_name
                else:
                    ans += '%s+%s=%s %s' % (rnd(pr/100.*tr), rnd((1-pr/100.)*tr), rnd(tr), self.time_name)
                if pr != '': ans += ', '
            if pr != '':
                ans += rnd(pr) + '%'  # pr may be non-integer if set by recalc_time
            ans += '&gt;'

            if show:
                nd.h = nd.h+ans
            self.loadIcons(nd)  # update progress icon

</t>
<t tx="tbrown.20090119215428.49">def updateUI(self,tag=None,k=None):

    if k and k['c'] != self.c:
        return  # wrong number

    v = self.c.currentPosition().v

    # check work date &lt; due date and do stylesheet re-evaluation stuff
    nwd = self.getat(v, 'nextworkdate')
    due = self.getat(v, 'duedate')
    w = self.ui.UI.frmDates
    if nwd and due and str(nwd) &gt; str(due):
        w.setProperty('style_class', 'tododate_error')
    else:
        w.setProperty('style_class', '')
    # update style on this widget on idle, see updateStyle()
    self._widget_to_style = (w, time.time())

    self.ui.setProgress(int(self.getat(v, 'progress') or 0 ))
    self.ui.setTime(float(self.getat(v, 'time_req') or 0 ))

    self.ui.setDueDate(self.getat(v, 'duedate'))
    # default is "", which is understood by setDueDate()
    self.ui.setDueTime(self.getat(v, 'duetime'))
    # ditto

    self.ui.setDueDate(self.getat(v, 'duedate'))
    self.ui.setDueTime(self.getat(v, 'duetime'))
    self.ui.setNextWorkDate(self.getat(v, 'nextworkdate'))
    self.ui.setNextWorkTime(self.getat(v, 'nextworktime'))
    # pylint: disable=maybe-no-member
    created = self.getat(v,'created')
    if created and isinstance(created, datetime.datetime) and created.year &gt;= 1900:
        self.ui.UI.createdTxt.setText(created.strftime("%d %b %y"))
        self.ui.UI.createdTxt.setToolTip(created.strftime("Created %H:%M %d %b %Y"))
    else:
        # .strftime doesn't work here! This has has happened...
        try:
            gdate = self.c.p.v.gnx.split('.')[1][:12]
            created = datetime.datetime.strptime(gdate, '%Y%m%d%H%M')
            if created.year &lt; 1900:
                created = None
        except Exception:
            created = None
        if created:
            self.ui.UI.createdTxt.setText(created.strftime("Created %d %b %Y"))
            self.ui.UI.createdTxt.setToolTip(created.strftime("gnx created %H:%M %d %b %Y"))
        else:
            self.ui.UI.createdTxt.setText("")

    # Update the label.
    h = self.c and self.c.p and self.c.p.h
    due = self.getat(v, 'duedate')
    ago = (datetime.date.today()-created.date()).days if created else 0
    if due:
        days = (due - datetime.date.today()).days
        txt = f"{h}\nCreated {ago} days ago, due in {days}"
    else:
        txt = f"{h}\nCreated {ago} days ago"
    self.ui.UI.txtDetails.setText(txt)
    prisetdate = self.getat(v, 'prisetdate')
    self.ui.UI.txtDetails.setToolTip("Priority set %s" %
        (str(prisetdate).strip() or '?')
    )
</t>
<t tx="tbrown.20111010104549.26758">def get_UNL(
    self,
    with_file=True,
    with_proto=False,
    with_index=True,
    with_count=False,
):
    """
    Return a UNL representing a clickable link.

    with_file=True - include path to Leo file
    with_proto=False - include 'file://'
    with_index - include ',x' at end where x is child index in parent
    with_count - include ',x,y' at end where y zero based count of same headlines
    """
    aList = []
    for i in self.self_and_parents(copy=False):
        if with_index or with_count:
            count = 0
            ind = 0
            p = i.copy()
            while p.hasBack():
                ind = ind + 1
                p.moveToBack()
                if i.h == p.h:
                    count = count + 1
            aList.append(i.h.replace('--&gt;', '--%3E') + ":" + str(ind))
                # g.recursiveUNLFind and sf.copy_to_my_settings undo this replacement.
            if count or with_count:
                aList[-1] = aList[-1] + "," + str(count)
        else:
            aList.append(i.h.replace('--&gt;', '--%3E'))
                # g.recursiveUNLFind  and sf.copy_to_my_settings undo this replacement.
    UNL = '--&gt;'.join(reversed(aList))
    if with_proto:
        # return ("file://%s#%s" % (self.v.context.fileName(), UNL)).replace(' ', '%20')
        s = "unl:" + f"//{self.v.context.fileName()}#{UNL}"
        return s.replace(' ', '%20')
    if with_file:
        return f"{self.v.context.fileName()}#{UNL}"
    return UNL
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20150807090639.1">def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    
    returns composite icon for this node
    """
    dd = self.declutter_data
    iconVal = p.v.computeIcon()
    iconName = f'box{iconVal:02d}.png'
    loaded_images = self.loaded_images
    @others
    if (p.h, iconVal) in dd:
        text, new_icons = dd[(p.h, iconVal)]
        item.setText(0, text)
        new_icons = sorted_icons(p) + new_icons
    else:
        text = p.h
        new_icons = []
        for pattern, cmds in self.get_declutter_patterns():
            m = pattern.match(text) or pattern.search(text)
            if m:
                apply_declutter_rules(cmds)
        dd[(p.h, iconVal)] = item.text(0), new_icons
        new_icons = sorted_icons(p) + new_icons
        preload_images()
    self.nodeIconsDict[p.gnx] = new_icons
    h = ':'.join(new_icons)
    icon = g.app.gui.iconimages.get(h)
    if not icon:
        preload_images()
        images = [loaded_images.get(x) for x in new_icons]
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ville.20090614224528.8141">def auto_walk(c, directory, parent=None, isroot=True):
    """
    source: http://leo.zwiki.org/CreateShadows

    (create @auto files instead)
    """
    from os import listdir
    from os.path import join, abspath, basename, normpath, isfile
    from fnmatch import fnmatch
    # import os

    RELATIVE_PATHS = False
    patterns_to_ignore = ['*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']
    patterns_to_import = ['*.py','*.c', '*.cpp']
    match = lambda s: any(fnmatch(s, p) for p in patterns_to_ignore)

    is_ignorable = lambda s: any([ s.startswith('.'), match(s) ])

    p = c.currentPosition()

    if not RELATIVE_PATHS: directory = abspath(directory)
    if isroot:
        p.h = "@path %s" % normpath(directory)
    for name in listdir(directory):

        if is_ignorable(name):
            continue

        path = join(directory, name)

        if isfile(path) and not any(fnmatch(name, p) for p in patterns_to_import):
            continue

        if isfile(path):
            g.es('file:', path)
            headline = '@auto %s' % basename(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
        else:
            g.es('dir:', path)
            headline = basename(path)
            body = "@path %s" % normpath(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
            child.initBodyString(body)
            auto_walk(c,path, parent=child, isroot=False)

@g.command('project-wizard')
def project_wizard(event):
    """ Launch project wizard """
    import os
    c = event['c']
    table = [("All files","*"),
        ("Python files","*.py"),]

    fname = g.app.gui.runOpenFileDialog(c,
        title = "Open",filetypes = table,defaultextension = ".leo")

    pth = os.path.dirname(os.path.abspath(fname))

    g.es(pth)
    tgt = c.currentPosition().insertAsLastChild()
    c.selectPosition(tgt)
    auto_walk(c, pth, tgt)
    g.es('Import ok. Do read-at-auto-nodes to parse')
    c.redraw()


#project_wizard()
</t>
<t tx="vitalije.20170708161511.1">def handleInputShortcut(self, event, stroke):
    c, k, p, u = self.c, self, self.c.p, self.c.undoer
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body.wrapper
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = u.beforeChangeNodeContents(p)
        pos = w.getYScrollPosition()
        i = len(before)
        j = max(i, len(before) + len(sel) - 1)
        w.setAllText(before + sel + after)
        w.setSelectionRange(i, j, insert=j)
        w.setYScrollPosition(pos)
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = u.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
</t>
<t tx="vitalije.20170709151653.1">_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
</t>
<t tx="vitalije.20170709151658.1">def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
</t>
<t tx="vitalije.20170709202924.1">def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
</t>
<t tx="vitalije.20200327162532.1">def get_declutter_patterns(self):
    "Initializes self.declutter_patterns from configuration and returns it"
    if self.declutter_patterns is not None:
        return self.declutter_patterns
    c = self.c
    patterns = []
    warned = False
    lines = c.config.getData("tree-declutter-patterns")
    for line in lines:
        try:
            cmd, arg = line.split(None, 1)
        except ValueError:
            # Allow empty arg, and guard against user errors.
            cmd = line.strip()
            arg = ''
        if cmd.startswith('#'):
            pass
        elif cmd == 'RULE':
            patterns.append((re.compile(arg), []))
        else:
            if patterns:
                patterns[-1][1].append((cmd, arg))
            elif not warned:
                warned = True
                g.log('Declutter patterns must start with RULE*',
                    color='error')
    self.declutter_patterns = patterns
    return patterns
</t>
<t tx="vitalije.20200327163522.1">def apply_declutter_rules(cmds):
    """Applies all commands for the matched rule."""
    for cmd, arg in cmds:
        if not declutter_replace(arg, cmd):
            declutter_style(arg, cmd)
</t>
<t tx="vitalije.20200329153148.1">def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
</t>
<t tx="vitalije.20200329153154.1">def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
</t>
<t tx="vitalije.20200329153544.1">def sorted_icons(p):
    '''
    Returns a list of icon filenames for this node.
    The list is sorted to owner the 'where' key of image dicts.
    '''
    icons = c.editCommands.getIconList(p)
    a = [x['file'] for x in icons if x['where'] == 'beforeIcon']
    a.append(iconName)
    a.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
    return a
</t>
<t tx="vitalije.20200329160945.1"></t>
<t tx="vitalije.20200329162015.1">def preload_images():
    for f in new_icons:
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
</t>
</tnodes>
</leo_file>
